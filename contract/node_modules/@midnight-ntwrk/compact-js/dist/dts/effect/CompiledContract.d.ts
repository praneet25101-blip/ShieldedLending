import type { Types } from 'effect';
import { type Pipeable } from 'effect/Pipeable';
import type * as CompactContext from './CompactContext.js';
import type { Contract } from './Contract.js';
import * as CompactContextInternal from './internal/compactContext.js';
export declare const TypeId: unique symbol;
export type TypeId = typeof TypeId;
/**
 * A binding to a Compact compiled contract.
 *
 * @remarks
 * Alongside the imported type and contract instance, we also need to provide an implementation of the
 * witnesses that the contract expects, along with a mechanism to retrieve the compiled ZK assets associated
 * with the compiled contract. A {@link CompiledContract} represents such a container within a hosting
 * TypeScript program. In order to make a contract executable, you should use the `ContractExecutable` module.
 *
 * @see {@link getContext} to retrieve the publicly visible properties associated with the compiled contract.
 */
export interface CompiledContract<in out C extends Contract<PS>, in out PS, out R = never> extends CompiledContract.Variance<C, PS, R>, Pipeable {
    /**
     * Gets the tag assigned to this compiled contract.
     */
    readonly tag: string;
    readonly [CompactContextInternal.TypeId]: Partial<CompactContextInternal.Context<C>>;
}
export declare namespace CompiledContract {
    /**
     * The context required to fully build a {@link CompiledContract}.
     *
     * @remarks
     * When looking to use a Compact compiled contract in a TypeScript program, we need to provide path
     * information to where the generated ZK assets can be found, along with an implementation of the witnesses
     * expected by the contract.
     */
    type Context<C extends Contract.Any> = CompactContext.Witnesses<C> | CompactContext.CompiledAssetsPath;
}
/**
 * Initializes an object that represents a binding to a Compact compiled contract.
 *
 * @param tag A unique identifier that represents this type of contract.
 * @param ctor The contract constructor, as imported from the compiled Compact output.
 * @returns A {@link CompiledContract}.
 *
 * @category constructors
 */
export declare const make: <C extends Contract<PS>, PS = Contract.PrivateState<C>, R = CompiledContract.Context<C>>(tag: string, ctor: Types.Ctor<C>) => CompiledContract<C, PS, R>;
/**
 * Associates an object that implements the contract witnesses for the Compact compiled contract.
 *
 * @category combinators
 */
export declare const withWitnesses: {
    /**
     * @param witnesses An object implementing the witness functions required by the Compact compiled contract.
     * @returns A function that receives the {@link CompiledContract} that `witnesses` will be attached to.
     */
    <C extends Contract<PS>, PS, R>(witnesses: R extends CompactContext.Witnesses<C, infer W> ? W : never): (self: CompiledContract<C, PS, R>) => CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>>;
    /**
     * @param self The {@link CompiledContract} that `witnesses` will be attached to.
     * @param witnesses An object implementing the witness functions required by the Compact compiled contract.
     */
    <C extends Contract<PS>, PS, R>(self: CompiledContract<C, PS, R>, witnesses: R extends CompactContext.Witnesses<C, infer W> ? W : never): CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>>;
};
/**
 * Associates _vacant_ witnesses with a Compact compiled contract that specifies no witnesses.
 *
 * @param self The {@link CompiledContract} for which no witnesses are required.
 *
 * @category combinators
 */
export declare const withVacantWitnesses: <C extends Contract<PS>, PS, R>(self: CompiledContract<C, PS, R>) => CompiledContract<C, PS, Exclude<R, CompactContext.Witnesses<C>>>;
/**
 * Associates a file path of where to find the compiled assets for the Compact compiled contract.
 *
 * @remarks
 * Relative file paths will be resolved relative to the base paths provided to each service that accesses
 * the compiled file assets.
 *
 * @category combinators
 */
export declare const withCompiledFileAssets: {
    /**
     * @param compiledAssetsPath The file path.
     * @returns A function that receives the {@link CompiledContract} that `compiledAssetsPath` will be attached to.
     */
    <C extends Contract<PS>, PS, R>(compiledAssetsPath: R extends CompactContext.CompiledAssetsPath ? string : never): (self: CompiledContract<C, PS, R>) => CompiledContract<C, PS, Exclude<R, CompactContext.CompiledAssetsPath>>;
    /**
     * @param self The {@link CompiledContract} that `compiledAssetsPath` will be attached to.
     * @param compiledAssetsPath The file path.
     */
    <C extends Contract<PS>, PS, R>(self: CompiledContract<C, PS, R>, compiledAssetsPath: R extends CompactContext.CompiledAssetsPath ? string : never): CompiledContract<C, PS, Exclude<R, CompactContext.CompiledAssetsPath>>;
};
/**
 * Retrieves a path to file based assets associated with a compiled contract.
 *
 * @param self The {@link CompiledContract} from which the assets path should be retrieved.
 * @returns A string representing a path to the file assets configured for `self`.
 */
export declare const getCompiledAssetsPath: <C extends Contract<PS>, PS>(self: CompiledContract<C, PS>) => string;
//# sourceMappingURL=CompiledContract.d.ts.map