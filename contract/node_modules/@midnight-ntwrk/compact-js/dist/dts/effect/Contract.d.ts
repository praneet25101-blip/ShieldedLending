/**
 * Provides types and utilities for working directly with Compact generated contract executables.
 *
 * @module
 */
import type { CircuitContext, CircuitResults, ConstructorContext, ConstructorResult, WitnessContext } from '@midnight-ntwrk/compact-runtime';
import { Brand } from 'effect';
export type Witness<PS, U = any> = (context: WitnessContext<U, PS>, ...args: any[]) => [PS, U];
export type Witnesses<PS> = Record<string, Witness<PS>>;
export type Circuit<PS, U = any> = (context: CircuitContext<PS>, ...args: any[]) => CircuitResults<PS, U>;
export type Circuits<PS> = Record<string, Circuit<PS>>;
export type ImpureCircuit<PS, U = any> = (context: CircuitContext<PS>, ...args: any[]) => CircuitResults<PS, U>;
export type ImpureCircuits<PS> = Record<string, ImpureCircuit<PS>>;
export type VerifierKey = Uint8Array & Brand.Brand<'VerifierKey'>;
export declare const VerifierKey: Brand.Brand.Constructor<VerifierKey>;
export type ZKIR = Uint8Array & Brand.Brand<'ZKIR'>;
export declare const ZKIR: Brand.Brand.Constructor<ZKIR>;
export type ImpureCircuitId<C extends Contract.Any = Contract.Any, K = Contract.ImpureCircuitId<C>> = K & Brand.Brand<'ImpureCircuitId'>;
export declare const ImpureCircuitId: <C extends Contract.Any>(id: Brand.Brand.Unbranded<ImpureCircuitId<C>>) => ImpureCircuitId<C>;
export interface Contract<PS, W extends Witnesses<PS> = Witnesses<PS>> {
    witnesses: W;
    circuits: Circuits<PS>;
    impureCircuits: ImpureCircuits<PS>;
    initialState(context: ConstructorContext<PS>, ...args: any[]): ConstructorResult<PS>;
}
export declare namespace Contract {
    type Any = Contract<any>;
    type PrivateState<C> = C extends Contract<infer PS> ? PS : never;
    type Witnesses<C> = C extends Contract<any, infer W> ? keyof W extends never ? never : W : never;
    type InitializeParameters<C extends Contract<any>> = Parameters<C['initialState']> extends [ConstructorContext<any>, ...infer A] ? A : never;
    type ImpureCircuitId<C extends Contract<any>> = keyof C['impureCircuits'] & string;
    type CircuitParameters<C extends Contract<any>, K extends ImpureCircuitId<C>> = Parameters<C['impureCircuits'][K]> extends [CircuitContext<any>, ...infer A] ? A : never;
    type CircuitReturnType<C extends Contract<any>, K extends ImpureCircuitId<C>> = ReturnType<C['impureCircuits'][K]> extends CircuitResults<any, infer U> ? U : never;
}
export declare const getImpureCircuitIds: <C extends Contract.Any>(contract: C) => ImpureCircuitId<C>[];
//# sourceMappingURL=Contract.d.ts.map