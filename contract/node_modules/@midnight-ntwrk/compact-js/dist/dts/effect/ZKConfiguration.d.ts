import { Context, type Effect, type Option } from 'effect';
import type { CompiledContract } from './CompiledContract.js';
import type * as Contract from './Contract.js';
import type * as ZKConfigurationError from './ZKConfigurationReadError.js';
declare const ZKConfiguration_base: Context.TagClass<ZKConfiguration, "compact-js/ZKConfiguration", ZKConfiguration.Service>;
/**
 * Provides utilities for working with the ZK assets of a compiled Compact contract.
 *
 * @category services
 */
export declare class ZKConfiguration extends ZKConfiguration_base {
}
export declare namespace ZKConfiguration {
    /**
     * Provides utilities for working with the ZK assets of a compiled Compact contract.
     */
    interface Service {
        /**
         * Creates a ZK asset reader for a given compiled Compact contract.
         *
         * @param compiledContract The Compact compiled contract.
         * @returns An `Effect` that yields a {@link Reader}.
         */
        readonly createReader: <C extends Contract.Contract<PS>, PS>(compiledContract: CompiledContract<C, PS, never>) => Effect.Effect<ZKConfiguration.Reader<C, PS>>;
    }
    /**
     * Reads ZK assets.
     */
    interface Reader<C extends Contract.Contract<PS>, PS> {
        /**
         * Reads a verifier key for a given circuit identifier.
         *
         * @param impureCircuitId The identifier of the circuit to be read.
         * @returns An `Effect` that yields an `Option` containing a {@link Contract.VerifierKey | VerifierKey} for
         * `impureCircuitId` if the compiled contract was configured for verifier key generation; or fails with a
         * {@link ZKConfigurationError.ZKConfigurationReadError | ZKConfigurationReadError}.
         */
        getVerifierKey(impureCircuitId: Contract.ImpureCircuitId<C>): Effect.Effect<Option.Option<Contract.VerifierKey>, ZKConfigurationError.ZKConfigurationReadError>;
        /**
         * Batch reads the verifier keys for an array of circuit identifiers.
         *
         * @param impureCircuitIds The identifiers of the circuits to be read.
         * @returns An `Effect` that yields an array of tuples describing an `Option` containing a
         * {@link Contract.VerifierKey | VerifierKey} and its associated circuit identifier if the compiled contract
         * was configured for verifier key generation; or fails with a
         * {@link ZKConfigurationError.ZKConfigurationReadError | ZKConfigurationReadError}.
         */
        getVerifierKeys(impureCircuitIds: Contract.ImpureCircuitId<C>[]): Effect.Effect<readonly [Contract.ImpureCircuitId<C>, Option.Option<Contract.VerifierKey>][], ZKConfigurationError.ZKConfigurationReadError>;
    }
}
export {};
//# sourceMappingURL=ZKConfiguration.d.ts.map