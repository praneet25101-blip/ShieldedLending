import type * as Contract from './Contract.js';
declare const TypeId: unique symbol;
type TypeId = typeof TypeId;
/**
 * Describes a type of ZK asset.
 */
export type AssetType = 'verifier-key' | 'ZKIR' | 'prover-key';
declare const ZKConfigurationReadError_base: new <A extends Record<string, any>>(args: import("effect/Types").Simplify<A>) => import("effect/Cause").YieldableError & Record<typeof TypeId, typeof TypeId> & {
    readonly _tag: "ZKConfigurationReadError";
} & Readonly<A>;
/**
 * Error indicating a failure to read a ZK asset.
 *
 * @category errors
 */
export declare class ZKConfigurationReadError extends ZKConfigurationReadError_base<{
    /** A displayable message. */
    readonly message: string;
    /** The underlying cause of the failed read operation. */
    readonly cause?: unknown;
    /** The tag of the compiled contract being read. */
    readonly contractTag: string;
    /** The circuit of the compiled contract being read. */
    readonly impureCircuitId: Contract.ImpureCircuitId;
    /** The type of asset that was being read. */
    readonly assetType: AssetType;
}> {
}
/**
 * Determines if a value is a ZK configuration read error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ZKConfigurationReadError}; `false` otherwise.
 *
 * @category guards
 */
export declare const isReadError: (u: unknown) => u is ZKConfigurationReadError;
/**
 * Creates a new {@link ZKConfigurationReadError}.
 *
 * @category constructors
 */
export declare const make: <C extends Contract.Contract.Any>(contractTag: string, impureCircuitId: Contract.ImpureCircuitId<C>, assetType: AssetType, cause?: unknown) => ZKConfigurationReadError;
export {};
//# sourceMappingURL=ZKConfigurationReadError.d.ts.map