// This file is part of Compact.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as ocrt from '@midnight-ntwrk/onchain-runtime-v2';
import { CompactError } from './error.js';
/**
 * Runtime type of {@link NativePoint}
 */
export const CompactTypeNativePoint = {
    alignment() {
        return [
            { tag: 'atom', value: { tag: 'field' } },
            { tag: 'atom', value: { tag: 'field' } },
        ];
    },
    fromValue(value) {
        const x = value.shift();
        const y = value.shift();
        if (x == undefined || y == undefined) {
            throw new CompactError('expected NativePoint');
        }
        else {
            return {
                x: ocrt.valueToBigInt([x]),
                y: ocrt.valueToBigInt([y]),
            };
        }
    },
    toValue(value) {
        return ocrt.bigIntToValue(value.x).concat(ocrt.bigIntToValue(value.y));
    },
};
/**
 * Runtime type of {@link MerkleTreeDigest}
 */
export const CompactTypeMerkleTreeDigest = {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'field' } }];
    },
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError('expected MerkleTreeDigest');
        }
        else {
            return { field: ocrt.valueToBigInt([val]) };
        }
    },
    toValue(value) {
        return ocrt.bigIntToValue(value.field);
    },
};
/**
 * Runtime type of {@link MerkleTreePathEntry}
 */
export const CompactTypeMerkleTreePathEntry = {
    alignment() {
        return CompactTypeMerkleTreeDigest.alignment().concat(CompactTypeBoolean.alignment());
    },
    fromValue(value) {
        const sibling = CompactTypeMerkleTreeDigest.fromValue(value);
        const goes_left = CompactTypeBoolean.fromValue(value);
        return {
            sibling: sibling,
            goes_left: goes_left,
        };
    },
    toValue(value) {
        return CompactTypeMerkleTreeDigest.toValue(value.sibling).concat(CompactTypeBoolean.toValue(value.goes_left));
    },
};
/**
 * Runtime type of {@link MerkleTreePath}
 */
export class CompactTypeMerkleTreePath {
    leaf;
    path;
    constructor(n, leaf) {
        this.leaf = leaf;
        this.path = new CompactTypeVector(n, CompactTypeMerkleTreePathEntry);
    }
    alignment() {
        return this.leaf.alignment().concat(this.path.alignment());
    }
    fromValue(value) {
        const leaf = this.leaf.fromValue(value);
        const path = this.path.fromValue(value);
        return {
            leaf: leaf,
            path: path,
        };
    }
    toValue(value) {
        return this.leaf.toValue(value.leaf).concat(this.path.toValue(value.path));
    }
}
/**
 * Runtime type of the builtin `Field` type
 */
export const CompactTypeField = {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'field' } }];
    },
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError('expected Field');
        }
        else {
            return ocrt.valueToBigInt([val]);
        }
    },
    toValue(value) {
        return ocrt.bigIntToValue(value);
    },
};
/**
 * Runtime type of an enum with a given number of entries
 */
export class CompactTypeEnum {
    maxValue;
    length;
    constructor(maxValue, length) {
        this.maxValue = maxValue;
        this.length = length;
    }
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: this.length } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError(`expected Enum[<=${this.maxValue}]`);
        }
        else {
            let res = 0;
            for (let i = 0; i < val.length; i++) {
                res += (1 << (8 * i)) * val[i];
            }
            if (res > this.maxValue) {
                throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
            }
            return res;
        }
    }
    toValue(value) {
        return CompactTypeField.toValue(BigInt(value));
    }
}
/**
 * Runtime type of the builtin `Unsigned Integer` types
 */
export class CompactTypeUnsignedInteger {
    maxValue;
    length;
    constructor(maxValue, length) {
        this.maxValue = maxValue;
        this.length = length;
    }
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: this.length } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
        }
        else {
            let res = 0n;
            for (let i = 0; i < val.length; i++) {
                res += (1n << (8n * BigInt(i))) * BigInt(val[i]);
            }
            if (res > this.maxValue) {
                throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
            }
            return res;
        }
    }
    toValue(value) {
        return CompactTypeField.toValue(value);
    }
}
/**
 * Runtime type of the builtin `Vector` types
 */
export class CompactTypeVector {
    length;
    type;
    constructor(length, type) {
        this.length = length;
        this.type = type;
    }
    alignment() {
        const inner = this.type.alignment();
        let res = [];
        for (let i = 0; i < this.length; i++) {
            res = res.concat(inner);
        }
        return res;
    }
    fromValue(value) {
        const res = [];
        for (let i = 0; i < this.length; i++) {
            res.push(this.type.fromValue(value));
        }
        return res;
    }
    toValue(value) {
        if (value.length != this.length) {
            throw new CompactError(`expected ${this.length}-element array`);
        }
        let res = [];
        for (let i = 0; i < this.length; i++) {
            res = res.concat(this.type.toValue(value[i]));
        }
        return res;
    }
}
/**
 * Runtime type of the builtin `Boolean` type
 */
export const CompactTypeBoolean = {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: 1 } }];
    },
    fromValue(value) {
        const val = value.shift();
        if (val == undefined || val.length > 1 || (val.length == 1 && val[0] != 1)) {
            throw new CompactError('expected Boolean');
        }
        return val.length == 1;
    },
    toValue(value) {
        if (value) {
            return [new Uint8Array([1])];
        }
        else {
            return [new Uint8Array(0)];
        }
    },
};
/**
 * Runtime type of the builtin `Bytes` types
 */
export class CompactTypeBytes {
    length;
    constructor(length) {
        this.length = length;
    }
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: this.length } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined || val.length > this.length) {
            throw new CompactError(`expected Bytes[${this.length}]`);
        }
        if (val.length == this.length) {
            return val;
        }
        const res = new Uint8Array(this.length);
        res.set(val, 0);
        return res;
    }
    toValue(value) {
        let end = value.length;
        while (end > 0 && value[end - 1] == 0) {
            end -= 1;
        }
        return [value.slice(0, end)];
    }
}
/**
 * Runtime type of `Opaque["Uint8Array"]`
 */
export const CompactTypeOpaqueUint8Array = {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'compress' } }];
    },
    fromValue(value) {
        return value.shift();
    },
    toValue(value) {
        return [value];
    },
};
/**
 * Runtime type of `Opaque["string"]`
 */
export const CompactTypeOpaqueString = {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'compress' } }];
    },
    fromValue(value) {
        return new TextDecoder('utf-8').decode(value.shift());
    },
    toValue(value) {
        return [new TextEncoder().encode(value)];
    },
};
/**
 * The following are type descriptors used to implement {@link createCoinCommitment}. They are not intended for direct
 * consumption.
 */
export const Bytes32Descriptor = new CompactTypeBytes(32);
export const MaxUint8Descriptor = new CompactTypeUnsignedInteger(18446744073709551615n, 8);
export const ShieldedCoinInfoDescriptor = {
    alignment() {
        return Bytes32Descriptor.alignment().concat(Bytes32Descriptor.alignment().concat(MaxUint8Descriptor.alignment()));
    },
    fromValue(value) {
        return {
            nonce: Bytes32Descriptor.fromValue(value),
            color: Bytes32Descriptor.fromValue(value),
            value: MaxUint8Descriptor.fromValue(value),
        };
    },
    toValue(value) {
        return Bytes32Descriptor.toValue(value.nonce).concat(Bytes32Descriptor.toValue(value.color).concat(MaxUint8Descriptor.toValue(value.value)));
    },
};
export const ZswapCoinPublicKeyDescriptor = {
    alignment() {
        return Bytes32Descriptor.alignment();
    },
    fromValue(value) {
        return {
            bytes: Bytes32Descriptor.fromValue(value),
        };
    },
    toValue(value) {
        return Bytes32Descriptor.toValue(value.bytes);
    },
};
export const ContractAddressDescriptor = {
    alignment() {
        return Bytes32Descriptor.alignment();
    },
    fromValue(value) {
        return {
            bytes: Bytes32Descriptor.fromValue(value),
        };
    },
    toValue(value) {
        return Bytes32Descriptor.toValue(value.bytes);
    },
};
export const ShieldedCoinRecipientDescriptor = {
    alignment() {
        return CompactTypeBoolean.alignment().concat(ZswapCoinPublicKeyDescriptor.alignment().concat(ContractAddressDescriptor.alignment()));
    },
    fromValue(value) {
        return {
            is_left: CompactTypeBoolean.fromValue(value),
            left: ZswapCoinPublicKeyDescriptor.fromValue(value),
            right: ContractAddressDescriptor.fromValue(value),
        };
    },
    toValue(value) {
        return CompactTypeBoolean.toValue(value.is_left).concat(ZswapCoinPublicKeyDescriptor.toValue(value.left).concat(ContractAddressDescriptor.toValue(value.right)));
    },
};
//# sourceMappingURL=compact-types.js.map