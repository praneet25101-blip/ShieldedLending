import { CompiledContract, Contract as Contract$1 } from '@midnight-ntwrk/compact-js';
import { Contract } from '@midnight-ntwrk/compact-js/effect/Contract';
import { ContractAddress, CoinPublicKey, ContractState, StateValue, Op, AlignedValue, ZswapLocalState, SigningKey } from '@midnight-ntwrk/compact-runtime';
import { ZswapChainState, PartitionedTranscript, ContractAddress as ContractAddress$1, UnprovenTransaction, ShieldedCoinInfo, EncPublicKey, SigningKey as SigningKey$1 } from '@midnight-ntwrk/ledger-v7';
import { MidnightProviders, PrivateStateId, PublicDataProvider, PrivateStateProvider, FinalizedTxData, ZKConfigProvider, VerifierKey, UnshieldedBalances } from '@midnight-ntwrk/midnight-js-types';

/**
 * Describes the target of a circuit invocation.
 */
type CallOptionsBase<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = {
    /**
     * The contract defining the circuit to call.
     */
    readonly compiledContract: CompiledContract.CompiledContract<C, any>;
    /**
     * The identifier of the circuit to call.
     */
    readonly circuitId: ICK;
    /**
     * The address of the contract being executed.
     */
    readonly contractAddress: ContractAddress;
};
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the options for a circuit call.
 */
type CallOptionsWithArguments<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = Contract.CircuitParameters<C, ICK> extends [] ? CallOptionsBase<C, ICK> : CallOptionsBase<C, ICK> & {
    /**
     * Arguments to pass to the circuit being called.
     */
    readonly args: Contract.CircuitParameters<C, ICK>;
};
/**
 * Data retrieved via providers that should be included in the call options.
 */
type CallOptionsProviderDataDependencies = {
    /**
     * The Zswap public key of the current user.
     */
    readonly coinPublicKey: CoinPublicKey;
    /**
     * The initial public state of the contract to run the circuit against.
     */
    readonly initialContractState: ContractState;
    /**
     * The initial public Zswap state of the contract to run the circuit against.
     */
    readonly initialZswapChainState: ZswapChainState;
};
/**
 * Call options with circuit arguments and data
 */
type CallOptionsWithProviderDataDependencies<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = CallOptionsWithArguments<C, ICK> & CallOptionsProviderDataDependencies;
/**
 * Call options for contracts with private state.
 */
type CallOptionsWithPrivateState<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = CallOptionsWithProviderDataDependencies<C, ICK> & {
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: Contract.PrivateState<C>;
};
/**
 * Call options for a given contract and circuit.
 */
type CallOptions<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = CallOptionsWithProviderDataDependencies<C, ICK> | CallOptionsWithPrivateState<C, ICK>;
/**
 * The private (sensitive) portions of the call result.
 */
type CallResultPrivate<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = {
    /**
     * ZK representation of the circuit arguments.
     */
    readonly input: AlignedValue;
    /**
     * ZK representation of the circuit result.
     */
    readonly output: AlignedValue;
    /**
     * ZK representation of the circuit witness call results.
     */
    readonly privateTranscriptOutputs: AlignedValue[];
    /**
     * The JS representation of the input to the circuit.
     */
    readonly result: Contract.CircuitReturnType<C, ICK>;
    /**
     * The private state resulting from executing the circuit.
     */
    readonly nextPrivateState: Contract.PrivateState<C>;
    /**
     * The Zswap local state resulting from executing the circuit.
     */
    readonly nextZswapLocalState: ZswapLocalState;
};
/**
 * The public portions of the call result.
 */
type CallResultPublic = {
    /**
     * The public state resulting from executing the circuit.
     */
    readonly nextContractState: StateValue;
    /**
     * The public transcript resulting from executing the circuit.
     */
    readonly publicTranscript: Op<AlignedValue>[];
    /**
     * A {@link publicTranscript} partitioned into guaranteed and fallible sections.
     * The guaranteed section of a public transcript must succeed for the corresponding
     * transaction to be considered valid. The fallible section of a public transcript
     * can fail without invalidating the transaction, as long as the guaranteed section succeeds.
     */
    readonly partitionedTranscript: PartitionedTranscript;
};
/**
 * Contains all information resulting from circuit execution.
 */
type CallResult<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = {
    /**
     * The public/non-sensitive data produced by the circuit execution.
     */
    readonly public: CallResultPublic;
    /**
     * The private/sensitive data produced by the circuit execution.
     */
    readonly private: CallResultPrivate<C, ICK>;
};

/**
 * Describes the target of a circuit invocation.
 */
type ContractConstructorOptionsBase<C extends Contract$1.Any> = {
    /**
     * The compiled contract defining the circuit to call.
     */
    readonly compiledContract: CompiledContract.CompiledContract<C, any>;
};
/**
 * Conditional type that optionally adds the inferred contract constructor argument types
 * to the constructor options.
 */
type ContractConstructorOptionsWithArguments<C extends Contract$1.Any> = Contract$1.InitializeParameters<C> extends [] ? ContractConstructorOptionsBase<C> : ContractConstructorOptionsBase<C> & {
    /**
     * Arguments to pass to the circuit being called.
     */
    readonly args: Contract$1.InitializeParameters<C>;
};
/**
 * Data retrieved via providers that should be included in the constructor call options.
 */
type ContractConstructorOptionsProviderDataDependencies = {
    /**
     * The current user's ZSwap public key.
     */
    readonly coinPublicKey: CoinPublicKey;
};
/**
 * Contract constructor options including arguments and provider data.
 */
type ContractConstructorOptionsWithProviderDataDependencies<C extends Contract$1.Any> = ContractConstructorOptionsWithArguments<C> & ContractConstructorOptionsProviderDataDependencies;
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the target of a circuit invocation.
 */
type ContractConstructorOptionsWithPrivateState<C extends Contract$1.Any> = ContractConstructorOptionsWithProviderDataDependencies<C> & {
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: Contract$1.PrivateState<C>;
};
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the target of a circuit invocation.
 */
type ContractConstructorOptions<C extends Contract$1.Any> = ContractConstructorOptionsWithProviderDataDependencies<C> | ContractConstructorOptionsWithPrivateState<C>;
/**
 * The updated states resulting from executing a contract constructor.
 */
type ContractConstructorResult<C extends Contract$1.Any> = {
    /**
     * The public state resulting from executing the contract constructor.
     */
    readonly nextContractState: ContractState;
    /**
     * The private state resulting from executing the contract constructor.
     */
    readonly nextPrivateState: Contract$1.PrivateState<C>;
    /**
     * The Zswap local state resulting from executing the contract constructor.
     */
    readonly nextZswapLocalState: ZswapLocalState;
};

/**
 * Convenience type for representing the set of providers necessary to use
 * a given contract.
 */
type ContractProviders<C extends Contract.Any = Contract.Any, ICK extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>, PS = Contract.PrivateState<C>> = MidnightProviders<ICK, PrivateStateId, PS>;

/**
 * Object containing the publicly visible states of a contract.
 */
type PublicContractStates = {
    /**
     * The (public) Zswap chain state of a contract.
     */
    readonly zswapChainState: ZswapChainState;
    /**
     * The (public) ledger state of a contract.
     */
    readonly contractState: ContractState;
};
/**
 * Object containing the publicly visible states of a contract and the private
 * state of a contract.
 */
type ContractStates<PS> = PublicContractStates & {
    /**
     * The private state of a contract.
     */
    readonly privateState: PS;
};
/**
 * Fetches only the public visible (Zswap and ledger) states of a contract.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
declare const getPublicStates: (publicDataProvider: PublicDataProvider, contractAddress: ContractAddress$1) => Promise<PublicContractStates>;
/**
 * Retrieves the Zswap, ledger, and private states of the contract corresponding
 * to the given identifier using the given providers.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param privateStateProvider The provider to use to fetch the private state.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier for the private state of the contract.
 */
declare const getStates: <PS>(publicDataProvider: PublicDataProvider, privateStateProvider: PrivateStateProvider<PrivateStateId, PS>, contractAddress: ContractAddress$1, privateStateId: PrivateStateId) => Promise<ContractStates<PS>>;

/**
 * Configuration for {@link submitTx}.
 */
type SubmitTxOptions<ICK extends Contract.ImpureCircuitId<Contract.Any>> = {
    /**
     * The transaction to prove, balance, and submit.
     */
    readonly unprovenTx: UnprovenTransaction;
    /**
     * A circuit identifier to use to fetch the ZK artifacts needed to prove the
     * transaction. Only defined if a call transaction is being submitted.
     *
     * @remarks
     * Where a transaction involves multiple circuits (e.g., when circuit calls are scoped to a transaction
     * context), this may be an array of circuit IDs.
     */
    readonly circuitId?: ICK | ICK[];
};
/**
 * Providers required to submit an unproven deployment transaction. Since {@link submitTx} doesn't
 * manipulate private state, the private state provider can be omitted.
 */
type SubmitTxProviders<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = Omit<ContractProviders<C, ICK>, 'privateStateProvider'>;
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * ## Blocking Behavior
 *
 * This method **waits indefinitely** for the transaction to appear on the blockchain via
 * `providers.publicDataProvider.watchForTxData(txId)`. It will not return until:
 * - The transaction is successfully included in the blockchain, OR
 * - An error occurs during proving, balancing, or submission
 *
 * ## Conditions When Transaction May Not Appear
 *
 * A submitted transaction may fail to appear on-chain if:
 * - Transaction is invalid in ways not detected during local validation
 * - Network issues prevent propagation to validators
 * - Transaction is rejected by validator consensus
 * - Insufficient fees or resources
 * - Contract state has changed making the transaction invalid
 *
 * ## Implications of Aborting This Method
 *
 * If the application terminates this method before it returns:
 * - Transaction may still be pending/processing on-chain
 * - **Private state updates are NOT stored** (even if transaction later succeeds on-chain)
 * - **Signing keys are NOT updated** (for deploy/replace authority transactions)
 * - Application state will be out of sync with blockchain state
 * - Manual recovery may be required to reconcile state
 *
 * **Recommendation**: Use {@link submitTxAsync} for non-blocking submission with manual
 * finalization handling and timeout control.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
declare const submitTx: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: SubmitTxOptions<ICK>) => Promise<FinalizedTxData>;
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options. Unlike {@link submitTx},
 * this function returns immediately after submission without waiting for finalization.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the transaction ID immediately after submission,
 *          or rejects if an error occurs during preparation or submission.
 *          To watch for finalization, use providers.publicDataProvider.watchForTxData(txId).
 */
declare const submitTxAsync: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: SubmitTxOptions<ICK>) => Promise<string>;

/**
 * Data relevant to any unsubmitted transaction.
 */
type UnsubmittedTxData = {
    /**
     * The unproven ledger transaction produced.
     */
    readonly unprovenTx: UnprovenTransaction;
    /**
     * New coins created during the construction of the transaction.
     */
    readonly newCoins: ShieldedCoinInfo[];
};
/**
 * Base type for public data relevant to an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxPublicData = {
    /**
     * The ledger address of the contract that was deployed.
     */
    readonly contractAddress: ContractAddress;
    /**
     * The initial public state of the contract deployed to the blockchain.
     */
    readonly initialContractState: ContractState;
};
/**
 * Base type for private data relevant to an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxPrivateData<C extends Contract$1.Any> = {
    /**
     * The signing key that was added as the deployed contract's maintenance authority.
     */
    readonly signingKey: SigningKey;
    /**
     * The initial private state of the contract deployed to the blockchain. This
     * value is persisted if the transaction succeeds.
     */
    readonly initialPrivateState: Contract$1.PrivateState<C>;
};
/**
 * Base type for data relevant to an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxDataBase<C extends Contract$1.Any> = {
    /**
     * The public data (data that will be revealed upon tx submission) relevant to the deployment transaction.
     */
    readonly public: UnsubmittedDeployTxPublicData;
    /**
     * The private data (data that will not be revealed upon tx submission) relevant to the deployment transaction.
     */
    readonly private: UnsubmittedDeployTxPrivateData<C>;
};
/**
 * Data for an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxData<C extends Contract$1.Any> = UnsubmittedDeployTxDataBase<C> & {
    /**
     * The data of this transaction that is only visible on the user device.
     */
    readonly private: UnsubmittedTxData & {
        /**
         * The Zswap state produced as a result of running the contract constructor. Useful for when
         * inputs or outputs are created in the contract constructor.
         */
        readonly initialZswapState: ZswapLocalState;
    };
};
/**
 * Data for a finalized deploy transaction submitted in this process.
 */
type FinalizedDeployTxDataBase<C extends Contract$1.Any> = UnsubmittedDeployTxDataBase<C> & {
    /**
     * The data of this transaction that is visible on the blockchain.
     */
    readonly public: FinalizedTxData;
};
/**
 * Data for a finalized deploy transaction submitted in this process.
 */
type FinalizedDeployTxData<C extends Contract$1.Any> = UnsubmittedDeployTxData<C> & {
    /**
     * The data of this transaction that is visible on the blockchain.
     */
    readonly public: FinalizedTxData;
};
/**
 * Data for an unsubmitted call transaction.
 */
type UnsubmittedCallTxData<C extends Contract$1.Any, ICK extends Contract$1.ImpureCircuitId<C>> = CallResult<C, ICK> & {
    /**
     * Private data relevant to this call transaction.
     */
    readonly private: UnsubmittedTxData;
};
/**
 * Data for a submitted, finalized call transaction.
 */
type FinalizedCallTxData<C extends Contract$1.Any, ICK extends Contract$1.ImpureCircuitId<C>> = UnsubmittedCallTxData<C, ICK> & {
    /**
     * Public data relevant to this call transaction.
     */
    readonly public: FinalizedTxData;
};
/**
 * Data returned from an asynchronous call transaction submission.
 * Contains the transaction ID and call transaction data without waiting for finalization.
 */
type SubmittedCallTx<C extends Contract$1.Any, ICK extends Contract$1.ImpureCircuitId<C>> = {
    /**
     * The transaction ID returned from submission.
     */
    readonly txId: string;
    /**
     * The unproven call transaction data including private state.
     */
    readonly callTxData: UnsubmittedCallTxData<C, ICK>;
};

/** @internal */
declare const Submit: unique symbol;
/** @internal */
declare const MergeUnsubmittedCallTxData: unique symbol;
/** @internal */
declare const CacheStates: unique symbol;

declare const TypeId: unique symbol;
type TypeId = typeof TypeId;
/**
 * Encapsulates the context for managing a scoped contract transaction.
 */
interface TransactionContext<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>> {
    readonly [TypeId]: TypeId;
    readonly [Submit]: () => Promise<FinalizedCallTxData<C, ICK>>;
    readonly [MergeUnsubmittedCallTxData]: (circuitId: ICK, callData: UnsubmittedCallTxData<C, ICK>, privateStateId?: PrivateStateId) => void;
    readonly [CacheStates]: (states: ContractStates<Contract.PrivateState<C>> | PublicContractStates) => void;
    /**
     * Gets the current cached contract states within the transaction context.
     *
     * @return A cached {@link ContractStates} instance, or `undefined` if circuit calls are yet to be made.
     *
     * @remarks
     * The returned states represent the unsubmitted _running_ state of the contract within the transaction context,
     * reflecting any unsubmitted circuit calls made to the contract during the scope of the transaction.
     */
    getCurrentStates(): ContractStates<Contract.PrivateState<C>> | PublicContractStates | undefined;
    /**
     * Gets the last unsubmitted call transaction data.
     *
     * @return A tuple containing an {@link UnsubmittedCallTxData} instance, and an optional private state
     * ID, or `undefined` if circuit calls are yet to be made.
     */
    getLastUnsubmittedCallTxDataToTransact(): [UnsubmittedCallTxData<C, ICK>, PrivateStateId?] | undefined;
}
/**
 * Options for use when creating scoped transactions.
 */
type ScopedTransactionOptions = {
    /**
     * An optional name for the transaction scope.
     */
    readonly scopeName?: string;
};
/**
 * Executes a function within the context of a contract-scoped transaction.
 *
 * @param providers The contract providers to use within the transaction.
 * @param fn The function to execute within the transaction context.
 * @param options Optional transaction scope options.
 * @returns A `Promise` that resolves with the finalized transaction data of the single transaction
 * created for all circuit calls made within `fn`.
 *
 * @remarks
 * Where `fn` make circuit calls, these are batched together and submitted as a single transaction when
 * the function completes successfully. If `fn` throws an error, any unsubmitted circuit calls are discarded.
 */
declare const withContractScopedTransaction: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(providers: ContractProviders<C, ICK>, fn: (txCtx: TransactionContext<C, ICK>) => Promise<void>, options?: ScopedTransactionOptions) => Promise<FinalizedCallTxData<C, ICK>>;

declare function createUnprovenCallTxFromInitialStates<C extends Contract<undefined>, ICK extends Contract.ImpureCircuitId<C>>(zkConfigProvider: ZKConfigProvider<string>, options: CallOptionsWithProviderDataDependencies<C, ICK>, walletEncryptionPublicKey: EncPublicKey): Promise<UnsubmittedCallTxData<C, ICK>>;
declare function createUnprovenCallTxFromInitialStates<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(zkConfigProvider: ZKConfigProvider<string>, options: CallOptionsWithPrivateState<C, ICK>, walletEncryptionPublicKey: EncPublicKey): Promise<UnsubmittedCallTxData<C, ICK>>;
/**
 * Base type for configuration for a call transaction; identical to {@link CallOptionsWithArguments}.
 */
type CallTxOptionsBase<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = CallOptionsWithArguments<C, ICK>;
/**
 * Call transaction options with the private state ID to use to store the new private
 * state resulting from the circuit call. Since a private state should already be
 * stored at the given private state ID, we don't need an 'initialPrivateState' like
 * in {@link DeployTxOptionsWithPrivateState}.
 */
type CallTxOptionsWithPrivateStateId<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = CallTxOptionsBase<C, ICK> & {
    /**
     * The identifier for the private state of the contract.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * Call transaction configuration.
 */
type CallTxOptions<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = CallTxOptionsBase<C, ICK> | CallTxOptionsWithPrivateStateId<C, ICK>;
/**
 * The minimum set of providers needed to create a call transaction, the ZK
 * artifact provider and a wallet. By defining this type, users can choose to
 * omit a private state provider if they're creating a call transaction for a
 * contract with no private state.
 */
type UnprovenCallTxProvidersBase = Pick<ContractProviders, 'zkConfigProvider' | 'publicDataProvider' | 'walletProvider'>;
/**
 * Same providers as {@link UnprovenCallTxProvidersBase} with an additional private
 * state provider to store the new private state resulting from the circuit call -
 * only used when creating a call transaction for a contract with a private state.
 */
type UnprovenCallTxProvidersWithPrivateState<C extends Contract.Any> = UnprovenCallTxProvidersBase & Pick<ContractProviders<C>, 'privateStateProvider'>;
declare function createUnprovenCallTx<C extends Contract<undefined>, ICK extends Contract.ImpureCircuitId<C>>(providers: UnprovenCallTxProvidersBase, options: CallTxOptionsBase<C, ICK>, transactionContext?: TransactionContext<C, ICK>): Promise<UnsubmittedCallTxData<C, ICK>>;
declare function createUnprovenCallTx<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: UnprovenCallTxProvidersWithPrivateState<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>, transactionContext?: TransactionContext<C, ICK>): Promise<UnsubmittedCallTxData<C, ICK>>;

/**
 * A type that lifts each circuit defined in a contract to a function that builds
 * and submits a call transaction.
 */
type CircuitCallTxInterface<C extends Contract.Any> = {
    [ICK in Contract.ImpureCircuitId<C>]: {
        (...args: Contract.CircuitParameters<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;
        (txCtx: TransactionContext<C, ICK>, ...args: Contract.CircuitParameters<C, ICK>): Promise<CallResult<C, ICK>>;
    };
};
/**
 * Creates a {@link CallTxOptions} object from various data.
 */
declare const createCallTxOptions: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
circuitId: ICK, contractAddress: ContractAddress$1, privateStateId: PrivateStateId | undefined, args: Contract.CircuitParameters<C, ICK>) => CallTxOptions<C, ICK>;
/**
 * Creates a circuit call transaction interface for a contract.
 *
 * @param providers The providers to use to build transactions.
 * @param compiledContract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier of the state of the witnesses of the contract.
 */
declare const createCircuitCallTxInterface: <C extends Contract.Any>(providers: ContractProviders<C>, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1, privateStateId: PrivateStateId | undefined) => CircuitCallTxInterface<C>;
/**
 * An interface for creating maintenance transactions for a specific circuit defined in a
 * given contract.
 */
type CircuitMaintenanceTxInterface = {
    /**
     * Constructs and submits a transaction that removes the current verifier key stored
     * on the blockchain for this circuit at this contract's address.
     */
    removeVerifierKey(): Promise<FinalizedTxData>;
    /**
     * Constructs and submits a transaction that adds a new verifier key to the
     * blockchain for this circuit at this contract's address.
     *
     * @param newVk The new verifier key to add for this circuit.
     */
    insertVerifierKey(newVk: VerifierKey): Promise<FinalizedTxData>;
};
/**
 * Creates a {@link CircuitMaintenanceTxInterface}.
 *
 * @param providers The providers to use to create and submit transactions.
 * @param circuitId The circuit ID the interface is for.
 * @param contractAddress The address of the deployed contract for which this
 *                        interface is being created.
 */
declare const createCircuitMaintenanceTxInterface: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: ContractProviders<C, ICK>, circuitId: ICK, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1) => CircuitMaintenanceTxInterface;
/**
 * A set of maintenance transaction creation interfaces, one for each circuit defined in
 * a given contract, keyed by the circuit name.
 */
type CircuitMaintenanceTxInterfaces<C extends Contract.Any> = Record<Contract.ImpureCircuitId<C>, CircuitMaintenanceTxInterface>;
/**
 * Creates a {@link CircuitMaintenanceTxInterfaces}.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 */
declare const createCircuitMaintenanceTxInterfaces: <C extends Contract.Any>(providers: ContractProviders<C>, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1) => CircuitMaintenanceTxInterfaces<C>;
/**
 * Interface for creating maintenance transactions for a contract that was
 * deployed.
 */
interface ContractMaintenanceTxInterface {
    /**
     * Constructs and submits a transaction that replaces the maintenance
     * authority stored on the blockchain for this contract.
     *
     * @param newAuthority The new contract maintenance authority for this contract.
     */
    replaceAuthority(newAuthority: SigningKey): Promise<FinalizedTxData>;
}
/**
 * Creates a {@link ContractMaintenanceTxInterface}.
 *
 * @param providers The providers to use to build transactions.
 * @param contractAddress The ledger address of the contract.
 */
declare const createContractMaintenanceTxInterface: <C extends Contract.Any>(providers: ContractProviders, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1) => ContractMaintenanceTxInterface;

/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
declare const verifierKeysEqual: (a: Uint8Array, b: Uint8Array) => boolean;
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
declare const verifyContractState: (verifierKeys: [Contract$1.ImpureCircuitId<Contract$1.Any>, VerifierKey][], contractState: ContractState) => void;
/**
 * Base type for the configuration options for {@link findDeployedContract}.
 */
type FindDeployedContractOptionsBase<C extends Contract$1.Any> = {
    /**
     * The compiled contract to use to execute circuits.
     */
    readonly compiledContract: CompiledContract.CompiledContract<C, any>;
    /**
     * The address of a previously deployed contract.
     */
    readonly contractAddress: ContractAddress;
    /**
     * The signing key to use to perform contract maintenance updates. If defined, the given signing
     * key is stored for this contract address. This is useful when someone has already added the given signing
     * key to the contract maintenance authority. If undefined, and there is an existing signing key for the
     * contract address locally, the existing signing key is kept. This is useful when the contract was
     * deployed locally. If undefined, and there is not an existing signing key for the contract address
     * locally, a fresh signing key is generated and stored for the contract address locally. This is
     * useful when you want to give a signing key to someone else to add you as a maintenance authority.
     */
    readonly signingKey?: SigningKey;
};
/**
 * {@link findDeployedContract} base configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
type FindDeployedContractOptionsExistingPrivateState<C extends Contract$1.Any> = FindDeployedContractOptionsBase<C> & {
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * {@link findDeployedContract} configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
type FindDeployedContractOptionsStorePrivateState<C extends Contract$1.Any> = FindDeployedContractOptionsExistingPrivateState<C> & {
    /**
     * For types of contract that make no use of private state and or witnesses that operate upon it, this
     * property may be `undefined`. Otherwise, the value provided via this property should be same initial
     * state that was used when calling {@link deployContract}.
     */
    readonly initialPrivateState: Contract$1.PrivateState<C>;
};
/**
 * Configuration for {@link findDeployedContract}.
 */
type FindDeployedContractOptions<C extends Contract$1.Any> = FindDeployedContractOptionsBase<C> | FindDeployedContractOptionsExistingPrivateState<C> | FindDeployedContractOptionsStorePrivateState<C>;
/**
 * Base type for a deployed contract that has been found on the blockchain.
 */
type FoundContract<C extends Contract$1.Any> = {
    /**
     * Data for the finalized deploy transaction corresponding to this contract.
     */
    readonly deployTxData: FinalizedDeployTxDataBase<C>;
    /**
     * Interface for creating call transactions for a contract.
     */
    readonly callTx: CircuitCallTxInterface<C>;
    /**
     * An interface for creating maintenance transactions for circuits defined in the
     * contract that was deployed.
     */
    readonly circuitMaintenanceTx: CircuitMaintenanceTxInterfaces<C>;
    /**
     * Interface for creating maintenance transactions for the contract that was
     * deployed.
     */
    readonly contractMaintenanceTx: ContractMaintenanceTxInterface;
};
declare function findDeployedContract<C extends Contract$1<undefined>>(providers: ContractProviders<C, Contract$1.ImpureCircuitId<C>, unknown>, options: FindDeployedContractOptionsBase<C>): Promise<FoundContract<C>>;
declare function findDeployedContract<C extends Contract$1.Any>(providers: ContractProviders<C>, options: FindDeployedContractOptionsExistingPrivateState<C>): Promise<FoundContract<C>>;
declare function findDeployedContract<C extends Contract$1.Any>(providers: ContractProviders<C>, options: FindDeployedContractOptionsStorePrivateState<C>): Promise<FoundContract<C>>;

/**
 * Base type for configuration for {@link deployContract}; identical to
 * {@link ContractConstructorOptionsWithArguments} except the `signingKey` is
 * now optional, since {@link deployContract} will generate a fresh signing key
 * in the event that `signingKey` is undefined.
 */
type DeployContractOptionsBase<C extends Contract.Any> = ContractConstructorOptionsWithArguments<C> & {
    /**
     * The signing key to add as the to-be-deployed contract's maintenance authority.
     * If undefined, a new signing key is sampled and used as the CMA then stored
     * in the private state provider under the newly deployed contract's address.
     * Otherwise, the passed signing key is added as the CMA. The second case is
     * useful when you want to use the same CMA for two different contracts.
     */
    readonly signingKey?: SigningKey;
};
/**
 * {@link deployContract} base options with information needed to store private states;
 * only used if the contract being deployed has a private state.
 */
type DeployContractOptionsWithPrivateState<C extends Contract.Any> = DeployContractOptionsBase<C> & {
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateId: PrivateStateId;
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: Contract.PrivateState<C>;
};
/**
 * Configuration for {@link deployContract}.
 */
type DeployContractOptions<C extends Contract.Any> = DeployContractOptionsBase<C> | DeployContractOptionsWithPrivateState<C>;
/**
 * Interface for a contract that has been deployed to the blockchain.
 */
type DeployedContract<C extends Contract.Any> = FoundContract<C> & {
    /**
     * Data resulting from the deployment transaction that created this contract. The information in a
     * {@link deployTxData} contains additional private information that does not
     * exist in {@link FoundContract.deployTxData} because certain private data is only available to
     * the deployer of a contract.
     */
    readonly deployTxData: FinalizedDeployTxData<C>;
};
declare function deployContract<C extends Contract<undefined>>(providers: ContractProviders<C, Contract.ImpureCircuitId<C>, unknown>, options: DeployContractOptionsBase<C>): Promise<DeployedContract<C>>;
declare function deployContract<C extends Contract.Any>(providers: ContractProviders<C>, options: DeployContractOptionsWithPrivateState<C>): Promise<DeployedContract<C>>;

/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
declare class TxFailedError extends Error {
    readonly finalizedTxData: FinalizedTxData;
    readonly circuitId?: (Contract$1.ImpureCircuitId<Contract$1.Any> | Contract$1.ImpureCircuitId<Contract$1.Any>[]) | undefined;
    /**
     * @param finalizedTxData The finalization data of the transaction that failed.
     * @param circuitId The name of the circuit that was called to create the call
     *                  transaction that failed. Only defined if a call transaction
     *                  failed.
     */
    constructor(finalizedTxData: FinalizedTxData, circuitId?: (Contract$1.ImpureCircuitId<Contract$1.Any> | Contract$1.ImpureCircuitId<Contract$1.Any>[]) | undefined);
}
/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
declare class DeployTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the deployment transaction that failed.
     */
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
declare class CallTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the call transaction that failed.
     * @param circuitId The name of the circuit that was called to build the transaction.
     */
    constructor(finalizedTxData: FinalizedTxData, circuitId: Contract$1.ImpureCircuitId<Contract$1.Any> | Contract$1.ImpureCircuitId<Contract$1.Any>[]);
}
/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
declare class ContractTypeError extends TypeError {
    readonly contractState: ContractState;
    readonly circuitIds: Contract$1.ImpureCircuitId<Contract$1.Any>[];
    /**
     * Initializes a new {@link ContractTypeError}.
     *
     * @param contractState The initial deployed contract state.
     * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
     *                   key present in `contractState`.
     */
    constructor(contractState: ContractState, circuitIds: Contract$1.ImpureCircuitId<Contract$1.Any>[]);
}
/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
declare class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a verifier key removal transaction failed.
 */
declare class RemoveVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a verifier key insertion transaction failed.
 */
declare class InsertVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a private state ID was specified for a call transaction while a private
 * state provider was not. We want to let the user know so that they aren't under the impression the
 * private state of a contract was updated when it wasn't.
 */
declare class IncompleteCallTxPrivateStateConfig extends Error {
    constructor();
}
/**
 * An error indicating that an initial private state was specified for a contract find while a
 * private state ID was not. We can't store the initial private state if we don't have a private state ID,
 * and we need to let the user know that.
 */
declare class IncompleteFindContractPrivateStateConfig extends Error {
    constructor();
}

/**
 * Fetches the unshielded balances associated with a specific contract address.
 *
 * @param publicDataProvider The provider to use to fetch the unshielded balances from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
declare const getUnshieldedBalances: (publicDataProvider: PublicDataProvider, contractAddress: ContractAddress$1) => Promise<UnshieldedBalances>;

type SubmitCallTxProviders<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = ContractProviders<C> | SubmitTxProviders<C, ICK>;
declare function submitCallTx<C extends Contract<undefined>, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: CallTxOptionsBase<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;
declare function submitCallTx<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: ContractProviders<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;
declare function submitCallTx<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: ContractProviders<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>, transactionContext: TransactionContext<C, ICK>): Promise<CallResult<C, ICK>>;
declare function submitCallTx<C extends Contract<undefined>, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: CallTxOptionsBase<C, ICK>, transactionContext: TransactionContext<C, ICK>): Promise<CallResult<C, ICK>>;
/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract,
 * returning immediately after submission without waiting for finalization.
 *
 * Unlike {@link submitCallTx}, this function does not wait for transaction finalization,
 * check transaction status, or update private state. The caller must handle these steps manually.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Manual Post-Submission Steps
 *
 * After calling this function, you must manually:
 * 1. Watch for transaction finalization using `providers.publicDataProvider.watchForTxData(txId)`
 * 2. Check transaction status (compare against `SucceedEntirely`)
 * 3. Handle failures appropriately (throw errors, log, etc.)
 * 4. Update private state if transaction succeeded and `privateStateId` was provided
 *
 * ## Failure Behavior (Manual Handling Required)
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `watchForTxData` may reject or return error status
 * - You must NOT store private state updates
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `watchForTxData` returns transaction data with failed status
 * - You must NOT store private state updates
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the transaction ID and call transaction data immediately after submission;
 *         or rejects with an error if the submission fails.
 *
 * @example
 * ```typescript
 * // 1. Submit
 * const { txId, callTxData } = await submitCallTxAsync(providers, options);
 *
 * // 2. Watch (when ready)
 * const finalizedData = await providers.publicDataProvider.watchForTxData(txId);
 *
 * // 3. Check status
 * if (finalizedData.status !== SucceedEntirely) {
 *   throw new CallTxFailedError(finalizedData, options.circuitId);
 * }
 *
 * // 4. Update private state manually if needed
 * if (options.privateStateId) {
 *   await providers.privateStateProvider.set(
 *     privateStateId,
 *     callTxData.private.nextPrivateState
 *   );
 * }
 * ```
 */
declare function submitCallTxAsync<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitCallTxProviders<C, ICK>, options: CallTxOptions<C, ICK>): Promise<SubmittedCallTx<C, ICK>>;

/**
 * Base type for deploy transaction configuration.
 */
type DeployTxOptionsBase<C extends Contract.Any> = ContractConstructorOptionsWithArguments<C> & {
    /**
     * The signing key to add as the to-be-deployed contract's maintenance authority.
     */
    readonly signingKey: SigningKey;
};
/**
 * Configuration for creating deploy transactions for contracts with private state. This
 * configuration used as a base type for the {@link DeployTxOptionsWithPrivateStateId} configuration.
 * It is also used directly as parameter to {@link createUnprovenDeployTx} which doesn't need
 * to save private state (and therefore doesn't need a private state ID) but does need to supply an
 * initial private state to run the contract constructor against.
 */
type DeployTxOptionsWithPrivateState<C extends Contract.Any> = DeployTxOptionsBase<C> & {
    /**
     * The private state to run the contract constructor against.
     */
    readonly initialPrivateState: Contract.PrivateState<C>;
};
/**
 * Configuration for creating deploy transactions for contracts with private state. This
 * configuration is used when a deployment transaction is created and an initial private
 * state needs to be stored, as is the case in {@link submitDeployTx}.
 */
type DeployTxOptionsWithPrivateStateId<C extends Contract.Any> = DeployTxOptionsWithPrivateState<C> & {
    /**
     * The identifier for the private state of the contract.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * Configuration for creating unproven deploy transactions.
 */
type UnprovenDeployTxOptions<C extends Contract.Any> = DeployTxOptionsBase<C> | DeployTxOptionsWithPrivateState<C>;
declare function createUnprovenDeployTxFromVerifierKeys<C extends Contract<undefined>>(zkConfigProvider: ZKConfigProvider<string>, coinPublicKey: CoinPublicKey, options: DeployTxOptionsBase<C>, encryptionPublicKey: EncPublicKey): Promise<UnsubmittedDeployTxData<C>>;
declare function createUnprovenDeployTxFromVerifierKeys<C extends Contract.Any>(zkConfigProvider: ZKConfigProvider<string>, coinPublicKey: CoinPublicKey, options: DeployTxOptionsWithPrivateState<C>, encryptionPublicKey: EncPublicKey): Promise<UnsubmittedDeployTxData<C>>;
/**
 * Providers needed to create an unproven deployment transactions, just the ZK artifact
 * provider and a wallet.
 */
type UnprovenDeployTxProviders<C extends Contract.Any> = Pick<ContractProviders<C>, 'zkConfigProvider' | 'walletProvider'>;
declare function createUnprovenDeployTx<C extends Contract<undefined>>(providers: UnprovenDeployTxProviders<C>, options: DeployTxOptionsBase<C>): Promise<UnsubmittedDeployTxData<C>>;
declare function createUnprovenDeployTx<C extends Contract.Any>(providers: UnprovenDeployTxProviders<C>, options: DeployTxOptionsWithPrivateState<C>): Promise<UnsubmittedDeployTxData<C>>;

/**
 * Configuration for creating deploy transactions.
 */
type DeployTxOptions<C extends Contract$1.Any> = DeployTxOptionsBase<C> | DeployTxOptionsWithPrivateStateId<C>;
declare function submitDeployTx<C extends Contract$1<undefined>>(providers: ContractProviders<C, Contract$1.ImpureCircuitId<C>, unknown>, options: DeployTxOptionsBase<C>): Promise<FinalizedDeployTxData<C>>;
declare function submitDeployTx<C extends Contract$1.Any>(providers: ContractProviders<C>, options: DeployTxOptionsWithPrivateStateId<C>): Promise<FinalizedDeployTxData<C>>;

/**
 * Constructs and submits a transaction that adds a new verifier key to the
 * blockchain for the given circuit ID at the given contract address.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `InsertVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key is NOT added to the contract
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `InsertVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key may be partially added but not usable
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param compiledContract The compiled contract for which the maintenance authority
 *                         should be updated.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be inserted.
 * @param circuitId The circuit for which the verifier key should be inserted.
 * @param newVk The new verifier key for the circuit.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {InsertVerifierKeyTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
declare const submitInsertVerifierKeyTx: <C extends Contract.Any>(providers: ContractProviders, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1, circuitId: Contract.ImpureCircuitId<C>, newVk: VerifierKey) => Promise<FinalizedTxData>;

/**
 * Constructs and submits a transaction that removes the current verifier key stored
 * on the blockchain for the given circuit ID at the given contract address.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `RemoveVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key remains on the contract (unchanged)
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `RemoveVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key may be partially removed but contract state is inconsistent
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param compiledContract The compiled contract for which the maintenance authority
 *                         should be updated.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be removed.
 * @param circuitId The circuit for which the verifier key should be removed.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {RemoveVerifierKeyTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
declare const submitRemoveVerifierKeyTx: <C extends Contract.Any>(providers: ContractProviders, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1, circuitId: Contract.ImpureCircuitId<C>) => Promise<FinalizedTxData>;

/**
 * Constructs and submits a transaction that replaces the maintenance
 * authority stored on the blockchain for this contract. After the transaction is
 * finalized, the current signing key stored in the given private state provider
 * is overwritten with the given new authority key.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
 * - Signing key in private state provider is NOT updated (remains as current authority)
 * - Contract authority on-chain remains unchanged
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
 * - Signing key in private state provider is NOT updated (remains as current authority)
 * - Contract authority on-chain may be partially updated but inconsistent
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param compiledContract The compiled contract for which the maintenance authority
 *                         should be updated.
 * @param contractAddress The address of the contract for which the maintenance
 *                        authority should be updated.
 *
 * TODO: There are at least three options we should support in the future:
 *       1. Replace authority and maintain key (current).
 *       2. Replace authority and do not maintain key.
 *       3. Add additional authorities and maintain original key.
 */
declare const submitReplaceAuthorityTx: <C extends Contract.Any>(providers: ContractProviders, compiledContract: CompiledContract.CompiledContract<C, any>, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress: ContractAddress$1) => (newAuthority: SigningKey$1) => Promise<FinalizedTxData>;

export { CallTxFailedError, ContractTypeError, DeployTxFailedError, IncompleteCallTxPrivateStateConfig, IncompleteFindContractPrivateStateConfig, InsertVerifierKeyTxFailedError, RemoveVerifierKeyTxFailedError, ReplaceMaintenanceAuthorityTxFailedError, TxFailedError, createCallTxOptions, createCircuitCallTxInterface, createCircuitMaintenanceTxInterface, createCircuitMaintenanceTxInterfaces, createContractMaintenanceTxInterface, createUnprovenCallTx, createUnprovenCallTxFromInitialStates, createUnprovenDeployTx, createUnprovenDeployTxFromVerifierKeys, deployContract, findDeployedContract, getPublicStates, getStates, getUnshieldedBalances, submitCallTx, submitCallTxAsync, submitDeployTx, submitInsertVerifierKeyTx, submitRemoveVerifierKeyTx, submitReplaceAuthorityTx, submitTx, submitTxAsync, verifierKeysEqual, verifyContractState, withContractScopedTransaction };
export type { CallOptions, CallOptionsBase, CallOptionsProviderDataDependencies, CallOptionsWithArguments, CallOptionsWithPrivateState, CallOptionsWithProviderDataDependencies, CallResult, CallResultPrivate, CallResultPublic, CallTxOptions, CallTxOptionsBase, CallTxOptionsWithPrivateStateId, CircuitCallTxInterface, CircuitMaintenanceTxInterface, CircuitMaintenanceTxInterfaces, ContractConstructorOptions, ContractConstructorOptionsBase, ContractConstructorOptionsProviderDataDependencies, ContractConstructorOptionsWithArguments, ContractConstructorOptionsWithPrivateState, ContractConstructorOptionsWithProviderDataDependencies, ContractConstructorResult, ContractMaintenanceTxInterface, ContractProviders, ContractStates, DeployContractOptions, DeployContractOptionsBase, DeployContractOptionsWithPrivateState, DeployTxOptions, DeployTxOptionsBase, DeployTxOptionsWithPrivateState, DeployTxOptionsWithPrivateStateId, DeployedContract, FinalizedCallTxData, FinalizedDeployTxData, FinalizedDeployTxDataBase, FindDeployedContractOptions, FindDeployedContractOptionsBase, FindDeployedContractOptionsExistingPrivateState, FindDeployedContractOptionsStorePrivateState, FoundContract, PublicContractStates, ScopedTransactionOptions, SubmitTxOptions, SubmitTxProviders, SubmittedCallTx, TransactionContext, UnprovenCallTxProvidersBase, UnprovenCallTxProvidersWithPrivateState, UnprovenDeployTxOptions, UnprovenDeployTxProviders, UnsubmittedCallTxData, UnsubmittedDeployTxData, UnsubmittedDeployTxDataBase, UnsubmittedDeployTxPrivateData, UnsubmittedDeployTxPublicData, UnsubmittedTxData };
