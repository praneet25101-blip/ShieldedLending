import type { Contract } from '@midnight-ntwrk/compact-js/effect/Contract';
import { type CallResult } from './call';
import { type ContractProviders } from './contract-providers';
import type { SubmitTxProviders } from './submit-tx';
import { type TransactionContext } from './transaction';
import type { FinalizedCallTxData, SubmittedCallTx } from './tx-model';
import { type CallTxOptions, type CallTxOptionsBase, type CallTxOptionsWithPrivateStateId } from './unproven-call-tx';
export type SubmitCallTxProviders<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = ContractProviders<C> | SubmitTxProviders<C, ICK>;
export declare function submitCallTx<C extends Contract<undefined>, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: CallTxOptionsBase<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;
export declare function submitCallTx<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: ContractProviders<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;
export declare function submitCallTx<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: ContractProviders<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>, transactionContext: TransactionContext<C, ICK>): Promise<CallResult<C, ICK>>;
export declare function submitCallTx<C extends Contract<undefined>, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: CallTxOptionsBase<C, ICK>, transactionContext: TransactionContext<C, ICK>): Promise<CallResult<C, ICK>>;
/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract,
 * returning immediately after submission without waiting for finalization.
 *
 * Unlike {@link submitCallTx}, this function does not wait for transaction finalization,
 * check transaction status, or update private state. The caller must handle these steps manually.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Manual Post-Submission Steps
 *
 * After calling this function, you must manually:
 * 1. Watch for transaction finalization using `providers.publicDataProvider.watchForTxData(txId)`
 * 2. Check transaction status (compare against `SucceedEntirely`)
 * 3. Handle failures appropriately (throw errors, log, etc.)
 * 4. Update private state if transaction succeeded and `privateStateId` was provided
 *
 * ## Failure Behavior (Manual Handling Required)
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `watchForTxData` may reject or return error status
 * - You must NOT store private state updates
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `watchForTxData` returns transaction data with failed status
 * - You must NOT store private state updates
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the transaction ID and call transaction data immediately after submission;
 *         or rejects with an error if the submission fails.
 *
 * @example
 * ```typescript
 * // 1. Submit
 * const { txId, callTxData } = await submitCallTxAsync(providers, options);
 *
 * // 2. Watch (when ready)
 * const finalizedData = await providers.publicDataProvider.watchForTxData(txId);
 *
 * // 3. Check status
 * if (finalizedData.status !== SucceedEntirely) {
 *   throw new CallTxFailedError(finalizedData, options.circuitId);
 * }
 *
 * // 4. Update private state manually if needed
 * if (options.privateStateId) {
 *   await providers.privateStateProvider.set(
 *     privateStateId,
 *     callTxData.private.nextPrivateState
 *   );
 * }
 * ```
 */
export declare function submitCallTxAsync<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitCallTxProviders<C, ICK>, options: CallTxOptions<C, ICK>): Promise<SubmittedCallTx<C, ICK>>;
//# sourceMappingURL=submit-call-tx.d.ts.map