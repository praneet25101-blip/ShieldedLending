import type { Contract } from '@midnight-ntwrk/compact-js/effect/Contract';
import { type UnprovenTransaction } from '@midnight-ntwrk/ledger-v7';
import { type FinalizedTxData } from '@midnight-ntwrk/midnight-js-types';
import { type ContractProviders } from './contract-providers';
/**
 * Configuration for {@link submitTx}.
 */
export type SubmitTxOptions<ICK extends Contract.ImpureCircuitId<Contract.Any>> = {
    /**
     * The transaction to prove, balance, and submit.
     */
    readonly unprovenTx: UnprovenTransaction;
    /**
     * A circuit identifier to use to fetch the ZK artifacts needed to prove the
     * transaction. Only defined if a call transaction is being submitted.
     *
     * @remarks
     * Where a transaction involves multiple circuits (e.g., when circuit calls are scoped to a transaction
     * context), this may be an array of circuit IDs.
     */
    readonly circuitId?: ICK | ICK[];
};
/**
 * Providers required to submit an unproven deployment transaction. Since {@link submitTx} doesn't
 * manipulate private state, the private state provider can be omitted.
 */
export type SubmitTxProviders<C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>> = Omit<ContractProviders<C, ICK>, 'privateStateProvider'>;
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * ## Blocking Behavior
 *
 * This method **waits indefinitely** for the transaction to appear on the blockchain via
 * `providers.publicDataProvider.watchForTxData(txId)`. It will not return until:
 * - The transaction is successfully included in the blockchain, OR
 * - An error occurs during proving, balancing, or submission
 *
 * ## Conditions When Transaction May Not Appear
 *
 * A submitted transaction may fail to appear on-chain if:
 * - Transaction is invalid in ways not detected during local validation
 * - Network issues prevent propagation to validators
 * - Transaction is rejected by validator consensus
 * - Insufficient fees or resources
 * - Contract state has changed making the transaction invalid
 *
 * ## Implications of Aborting This Method
 *
 * If the application terminates this method before it returns:
 * - Transaction may still be pending/processing on-chain
 * - **Private state updates are NOT stored** (even if transaction later succeeds on-chain)
 * - **Signing keys are NOT updated** (for deploy/replace authority transactions)
 * - Application state will be out of sync with blockchain state
 * - Manual recovery may be required to reconcile state
 *
 * **Recommendation**: Use {@link submitTxAsync} for non-blocking submission with manual
 * finalization handling and timeout control.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
export declare const submitTx: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: SubmitTxOptions<ICK>) => Promise<FinalizedTxData>;
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options. Unlike {@link submitTx},
 * this function returns immediately after submission without waiting for finalization.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the transaction ID immediately after submission,
 *          or rejects if an error occurs during preparation or submission.
 *          To watch for finalization, use providers.publicDataProvider.watchForTxData(txId).
 */
export declare const submitTxAsync: <C extends Contract.Any, ICK extends Contract.ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: SubmitTxOptions<ICK>) => Promise<string>;
//# sourceMappingURL=submit-tx.d.ts.map