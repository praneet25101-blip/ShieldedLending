import { type Recipient, type ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import { type CoinPublicKey, type ContractAddress, type EncPublicKey, type QualifiedShieldedCoinInfo, type ShieldedCoinInfo, type UnprovenInput, type UnprovenOffer, type UnprovenOutput, type UnprovenTransient, type ZswapChainState } from '@midnight-ntwrk/ledger-v7';
export declare const checkKeys: (coinInfo: ShieldedCoinInfo) => void;
export declare const serializeCoinInfo: (coinInfo: ShieldedCoinInfo) => string;
export declare const serializeQualifiedShieldedCoinInfo: (coinInfo: QualifiedShieldedCoinInfo) => string;
export declare const deserializeCoinInfo: (coinInfo: string) => ShieldedCoinInfo;
export declare const createZswapOutput: ({ coinInfo, recipient }: {
    coinInfo: ShieldedCoinInfo;
    recipient: Recipient;
}, encryptionPublicKey: EncPublicKey, segmentNumber?: number) => UnprovenOutput;
export declare const unprovenOfferFromMap: <U extends UnprovenInput | UnprovenOutput | UnprovenTransient>(map: Map<string, U>, f: (u: U, type: string, value: bigint) => UnprovenOffer) => UnprovenOffer | undefined;
export declare const zswapStateToOffer: (zswapLocalState: ZswapLocalState, encryptionPublicKey: EncPublicKey, addressAndChainStateTuple?: {
    contractAddress: ContractAddress;
    zswapChainState: ZswapChainState;
}) => UnprovenOffer | undefined;
export declare const zswapStateToNewCoins: (receiverCoinPublicKey: CoinPublicKey, zswapState: ZswapLocalState) => ShieldedCoinInfo[];
export declare const encryptionPublicKeyForZswapState: (zswapState: ZswapLocalState, walletCoinPublicKey: CoinPublicKey, walletEncryptionPublicKey: EncPublicKey) => EncPublicKey;
//# sourceMappingURL=zswap-utils.d.ts.map