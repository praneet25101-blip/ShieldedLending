import { ContractExecutableRuntime, ZKConfiguration, ZKConfigurationReadError, Contract } from '@midnight-ntwrk/compact-js/effect';
import { ContractAddress } from '@midnight-ntwrk/platform-js';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import { Exit, Layer, Cause, Option, Effect, ConfigProvider } from 'effect';
export { Transaction } from '@midnight-ntwrk/ledger-v7';

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a ZK configuration reader by adapting a given {@link ZKConfigProvider}.
 *
 * @param zkConfigProvider The {@link ZKConfigProvider} that is to be adapted.
 * @returns A {@link ZKConfiguration.ZKConfiguration.Reader | ZKConfiguration.Reader} that reads from
 * `zkConfigProvider`.
 *
 * @internal
 */
const makeAdaptedReader = (zkConfigProvider) => (compiledContract) => Effect.gen(function* () {
    // TODO: Consider implementing the logic used in Compact.js (look at the contract manifest to determine
    // if the circuit is verifiable). See PM-21376.
    const getVerifierKey = (impureCircuitId) => Effect.tryPromise({
        try: () => zkConfigProvider.getVerifierKey(impureCircuitId).then((verifierKey) => Option.some(Contract.VerifierKey(verifierKey))),
        catch: (err) => ZKConfigurationReadError.make(compiledContract.tag, impureCircuitId, 'verifier-key', err)
    });
    return {
        getVerifierKey,
        getVerifierKeys: (impureCircuitIds) => Effect.forEach(impureCircuitIds, (impureCircuitId) => getVerifierKey(impureCircuitId).pipe(Effect.map((verifierKey) => [impureCircuitId, verifierKey])), { concurrency: 'unbounded', discard: false })
    };
});
const makeAdaptedRuntimeLayer = (zkConfigProvider, configMap) => Layer.mergeAll(Layer.succeed(ZKConfiguration.ZKConfiguration, ZKConfiguration.ZKConfiguration.of({
    createReader: makeAdaptedReader(zkConfigProvider)
})), Configuration.layer).pipe(Layer.provide(Layer.setConfigProvider(ConfigProvider.fromMap(configMap, { pathDelim: '_' }).pipe(ConfigProvider.constantCase))));
/**
 * Constructs an Effect managed runtime configured to execute contract executables.
 *
 * @param zkConfigProvider The {@link ZKConfigProvider} that is to be adapted.
 * @param options Values that will be mapped into and made available within the constructed runtime.
 * @returns An Effect {@link ManagedRuntime} that can be used to execute {@link ContractExecutable} instances.
 */
const makeContractExecutableRuntime = (zkConfigProvider, options) => {
    let config = [['KEYS_COIN_PUBLIC', options.coinPublicKey]];
    if (options.signingKey) {
        config = config.concat([['KEYS_SIGNING', options.signingKey]]);
    }
    return ContractExecutableRuntime.make(makeAdaptedRuntimeLayer(zkConfigProvider, new Map(config)));
};
/**
 * Unwraps an Effect `Exit` instance, returning its value if it is successful, or throwing the error contained
 * within it.
 *
 * @param exit The source Effect `Exit` instance.
 * @returns The value from `exit` if it is successful, otherwise throws the error contained within it.
 */
const exitResultOrError = (exit) => Exit.match(exit, {
    onSuccess: (a) => a,
    onFailure: (cause) => {
        if (Cause.isFailType(cause))
            throw cause.error;
        throw new Error(`Unexpected error: ${Cause.pretty(cause)}`);
    }
});
/**
 * Wraps an object into an `Option.some`.
 *
 * @param obj The value that should be wrapped into an `Option`.
 * @returns An `Option.some` for `obj`.
 */
const asEffectOption = (obj) => {
    return Option.some(obj);
};
/**
 * Constructs a branded contract address from a given string value.
 *
 * @param address A string value representing a contract address.
 * @returns A {@link ContractAddress.ContractAddress | ContractAddress} constructed from `address`.
 */
const asContractAddress = (address) => ContractAddress.ContractAddress(address);

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An error describing an invalid protocol scheme.
 */
class InvalidProtocolSchemeError extends Error {
    invalidScheme;
    allowableSchemes;
    /**
     * @param invalidScheme The invalid scheme.
     * @param allowableSchemes The valid schemes that are allowed.
     */
    constructor(invalidScheme, allowableSchemes) {
        super(`Invalid protocol scheme: '${invalidScheme}'. Allowable schemes are one of: ${allowableSchemes.join(',')}`);
        this.invalidScheme = invalidScheme;
        this.allowableSchemes = allowableSchemes;
    }
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A valid named log level.
 */
var LogLevel;
(function (LogLevel) {
    /**
     * Log levels typically used by DAapp developers.
     */
    LogLevel["INFO"] = "info";
    LogLevel["WARN"] = "warn";
    LogLevel["ERROR"] = "error";
    LogLevel["FATAL"] = "fatal";
    /**
     * Log levels used by Midnight.JS to report internal state.
     */
    LogLevel["DEBUG"] = "debug";
    LogLevel["TRACE"] = "trace";
})(LogLevel || (LogLevel = {}));

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**

 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
const createProverKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
const createVerifierKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
const createZKIR = (uint8Array) => {
    return uint8Array;
};
/**
 * Converts a ZKConfig object to ProvingKeyMaterial format.
 * @param zkConfig
 */
const zkConfigToProvingKeyMaterial = (zkConfig) => {
    return {
        proverKey: zkConfig.proverKey,
        verifierKey: zkConfig.verifierKey,
        ir: zkConfig.zkir,
    };
};
/**
 * Indicates that the segment update is invalid.
 */
const SegmentFail = 'SegmentFail';
/**
 * Indicates that the segment is valid.
 */
const SegmentSuccess = 'SegmentSuccess';
/**
 * Indicates that the transaction is invalid.
 */
const FailEntirely = 'FailEntirely';
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
const FailFallible = 'FailFallible';
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
const SucceedEntirely = 'SucceedEntirely';

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
 * three are used by the {@link ProofProvider} to create a proof for a call transaction. The implementation
 * of this provider depends on the runtime environment, since each environment has different conventions
 * for accessing static artifacts.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
class ZKConfigProvider {
    /**
     * Retrieves the verifier keys produced by `compact` compiler for the given circuits.
     * @param circuitIds The circuit IDs of the verifier keys to retrieve.
     */
    async getVerifierKeys(circuitIds) {
        return Promise.all(circuitIds.map(async (id) => {
            const key = await this.getVerifierKey(id);
            return [id, key];
        }));
    }
    /**
     * Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.
     * @param circuitId The circuit ID of the artifacts to retrieve.
     */
    async get(circuitId) {
        return {
            circuitId,
            proverKey: await this.getProverKey(circuitId),
            verifierKey: await this.getVerifierKey(circuitId),
            zkir: await this.getZKIR(circuitId)
        };
    }
    asKeyMaterialProvider() {
        return this;
    }
}

export { FailEntirely, FailFallible, InvalidProtocolSchemeError, LogLevel, SegmentFail, SegmentSuccess, SucceedEntirely, ZKConfigProvider, asContractAddress, asEffectOption, createProverKey, createVerifierKey, createZKIR, exitResultOrError, makeContractExecutableRuntime, zkConfigToProvingKeyMaterial };
//# sourceMappingURL=index.mjs.map
