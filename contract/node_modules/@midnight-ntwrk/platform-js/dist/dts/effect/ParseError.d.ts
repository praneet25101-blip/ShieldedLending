import { type Inspectable } from 'effect/Inspectable';
declare const TypeId: unique symbol;
type TypeId = typeof TypeId;
declare const ParseError_base: new <A extends Record<string, any>>(args: import("effect/Types").Simplify<A>) => import("effect/Cause").YieldableError & Record<typeof TypeId, typeof TypeId> & {
    readonly _tag: "ParseError";
} & Readonly<A>;
/**
 * Error indicating a failure to parse some string value.
 *
 * @category errors
 */
export declare class ParseError extends ParseError_base<{
    /** A displayable message. */
    readonly message: string;
    /** The source string that failed to parse. */
    readonly source: string;
    /** Inspectable data about the parse operation.  */
    readonly meta?: Inspectable;
    /** The underlying cause of the failed parse operation.  */
    readonly cause?: unknown;
}> {
}
/**
 * Determines if a value is a parse error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ParseError}; `false` otherwise.
 *
 * @category guards
 */
export declare const isParseError: (u: unknown) => u is ParseError;
/**
 * Creates a new `ParseError`.
 *
 * @category constructors
 */
export declare const make: {
    (message: string, source: string): ParseError;
    (message: string, source: string, meta: Inspectable): ParseError;
    (message: string, source: string, meta: Inspectable, cause: unknown): ParseError;
};
export {};
//# sourceMappingURL=ParseError.d.ts.map