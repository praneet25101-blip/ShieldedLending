/*
 * This file is part of midnight-sdk.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-use-before-define */
import * as Equal from 'effect/Equal';
import * as equivalence from 'effect/Equivalence';
import { dual } from 'effect/Function';
import * as Hash from 'effect/Hash';
import { NodeInspectSymbol } from 'effect/Inspectable';
import { pipeArguments } from 'effect/Pipeable';
import { hasProperty, isNumber, isString } from 'effect/Predicate';
const TypeId = Symbol.for('platform-js/effect/IntegerRange');
/**
 * Provides equivalence for {@link IntegerRange} instances.
 *
 * @remarks
 * For two {@link IntegerRange} instances to be considered equal, both their minimum and maximum values
 * must be equal, and they should both have the same type of inclusion (i.e., inclusive or exclusive). This is
 * not _range equivalence_ which determines if two {@link IntegerRange} instances represent the same sequence
 * of values.
 *
 * @category equivalence
 */
export const Equivalence = equivalence.struct({
    value: equivalence.struct({
        _tag: equivalence.string,
        min: equivalence.number,
        max: equivalence.number
    })
});
/**
 * Determines if a value is an integer range.
 *
 * @param u The value to check.
 * @returns `true` if `u` is an {@link IntegerRange}; `false` otherwise.
 *
 * @category guards
 */
export const isIntegerRange = (u) => hasProperty(u, TypeId);
/**
 * Determines if an integer range will be _inclusive_ of its maximum value.
 *
 * @param self The {@link IntegerRange} to check.
 * @returns `true` if `self` is an inclusive {@link IntegerRange}; `false` otherwise.
 *
 * @category guards
 */
export const isInclusive = (self) => self.value._tag === 'Inclusive';
/**
 * Determines if an integer range will be _exclusive_ of its maximum value.
 *
 * @param self The {@link IntegerRange} to check.
 * @returns `true` if `self` is an exclusive {@link IntegerRange}; `false` otherwise.
 *
 * @category guards
 */
export const isExclusive = (self) => self.value._tag === 'Exclusive';
/**
 * Determines if two integer ranges are equal.
 *
 * @category predicates
 */
export const equals = dual(2, (self, that) => Equivalence(self, that));
/**
 * Determines if an integer range is inclusive of a value.
 *
 * @category predicates
 */
export const contains = dual(2, (self, value) => {
    if (isInclusive(self)) {
        return contains(from([self.value.min, self.value.max + 1]), value);
    }
    const { min, max } = self.value;
    return value >= min && value < max;
});
/**
 * Creates _inclusive_ integer ranges.
 *
 * @category constructors
 */
export const inclusive = (range) => {
    if (isIntegerRange(range)) {
        return isInclusive(range)
            ? range // Already inclusive, return it.
            : make([range.value.min, range.value.max - 1], 'Inclusive');
    }
    return make(range, 'Inclusive');
};
/**
 * Creates _exclusive_ integer ranges.
 *
 * @category constructors
 */
export const exclusive = (range) => {
    if (isIntegerRange(range)) {
        return isExclusive(range)
            ? range // Already exclusive, return it.
            : make([range.value.min, range.value.max + 1], 'Exclusive');
    }
    return make(range, 'Exclusive');
};
/**
 * Creates an integer range.
 *
 * @param input The input to use when constructing the integer range.
 * @returns An {@link IntegerRange} derived from `input`.
 *
 * @remarks
 * The tuple form of {@link IntegerRangeInput}, will create an {@link IntegerRange} that is _exclusive_
 * of `max` ( i.e., `min <= x < max`).
 *
 * @category constructors
 */
export const from = (input) => make(input);
const RANGE_REGEXP = /(?<n>\d*)\.\.(?<inc>\=?)(?<x>\d*)/; // eslint-disable-line no-useless-escape
const DEFAULT_ARRAY_INPUT_MODE = 'Exclusive';
const IntegerRangeProto = {
    [TypeId]: TypeId,
    [Hash.symbol]() {
        return Hash.cached(this, Hash.structure(this.value));
    },
    [Equal.symbol](that) {
        return isIntegerRange(that) && equals(this, that);
    },
    toString() {
        const { min, max, _tag } = this.value;
        const sep = _tag === 'Inclusive' ? '..=' : '..';
        return `${min}${sep}${max}`;
    },
    toJSON() {
        return {
            _id: 'IntegerRange',
            ...this.value
        };
    },
    [NodeInspectSymbol]() {
        return this.toJSON();
    },
    pipe() {
        return pipeArguments(this, arguments); // eslint-disable-line prefer-rest-params
    }
};
const make = (input, arrayInputMode) => {
    const self = Object.create(IntegerRangeProto);
    if (isIntegerRange(input)) {
        self.value = input.value;
    }
    else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
        const [min, max] = input;
        self.value = {
            _tag: arrayInputMode ?? DEFAULT_ARRAY_INPUT_MODE,
            min,
            max
        };
    }
    else if (isString(input)) {
        const match = input.match(RANGE_REGEXP);
        if (!match || !match.groups) {
            throw new Error(`Invalid IntegerRange: ${input}`);
        }
        const { n, inc, x } = match.groups;
        const min = Number(n);
        const max = Number(x);
        if (!isNumber(min) || !isNumber(max)) {
            throw new TypeError(`Invalid IntegerRange: ${input}`);
        }
        self.value = {
            _tag: inc === '=' ? 'Inclusive' : 'Exclusive',
            min,
            max
        };
    }
    else {
        throw new Error('Invalid IntegerRange');
    }
    return self;
};
//# sourceMappingURL=IntegerRange.js.map