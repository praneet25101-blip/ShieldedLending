import { DustPublicKey, EncryptionSecretKey, UserAddress } from '@midnight-ntwrk/ledger-v7';
export declare const mainnet: unique symbol;
export type NetworkId = string | typeof mainnet;
export type FormatContext = {
    networkId: NetworkId;
};
export type Field = {
    bytes: number;
    modulus: bigint;
};
export declare const BLSScalar: Field;
export declare const ScaleBigInt: {
    encode: (data: bigint) => Buffer;
    decode: (repr: Uint8Array) => bigint;
};
export declare const Bech32mSymbol: unique symbol;
export type HasCodec<T> = {
    [Bech32mSymbol]: Bech32mCodec<T>;
};
export type CodecTarget<T> = T extends HasCodec<infer U> ? U : never;
export declare class MidnightBech32m {
    static readonly prefix = "mn";
    static encode<T extends HasCodec<T>>(networkId: NetworkId, item: T): MidnightBech32m;
    static validateSegment(segmentName: string, segment: string): void;
    static parse(bech32string: string): MidnightBech32m;
    readonly type: string;
    readonly network: NetworkId;
    readonly data: Buffer;
    constructor(type: string, network: NetworkId, data: Buffer);
    decode<TClass extends HasCodec<any>>(tclass: TClass, networkId: NetworkId): CodecTarget<TClass>;
    asString(): string;
    toString(): string;
}
export declare class Bech32mCodec<T> {
    readonly type: string;
    readonly dataToBytes: (data: T) => Buffer;
    readonly dataFromBytes: (bytes: Buffer) => T;
    constructor(type: string, dataToBytes: (data: T) => Buffer, dataFromBytes: (bytes: Buffer) => T);
    encode(networkId: NetworkId, data: T): MidnightBech32m;
    decode(networkId: NetworkId, repr: MidnightBech32m): T;
    static createContext(networkId: NetworkId): FormatContext;
}
export declare class ShieldedAddress {
    static readonly codec: Bech32mCodec<ShieldedAddress>;
    static readonly [Bech32mSymbol]: Bech32mCodec<ShieldedAddress>;
    readonly [Bech32mSymbol]: Bech32mCodec<ShieldedAddress>;
    readonly coinPublicKey: ShieldedCoinPublicKey;
    readonly encryptionPublicKey: ShieldedEncryptionPublicKey;
    constructor(coinPublicKey: ShieldedCoinPublicKey, encryptionPublicKey: ShieldedEncryptionPublicKey);
    coinPublicKeyString(): string;
    encryptionPublicKeyString(): string;
    equals(other: ShieldedAddress): boolean;
}
export declare class ShieldedEncryptionSecretKey {
    static readonly codec: Bech32mCodec<ShieldedEncryptionSecretKey>;
    readonly zswap: EncryptionSecretKey;
    constructor(zswap: EncryptionSecretKey);
}
export declare class ShieldedCoinPublicKey {
    static readonly keyLength = 32;
    static readonly codec: Bech32mCodec<ShieldedCoinPublicKey>;
    static fromHexString(hexString: string): ShieldedCoinPublicKey;
    readonly data: Buffer;
    constructor(data: Buffer);
    toHexString(): string;
    equals(other: string): boolean;
    equals(other: ShieldedCoinPublicKey): boolean;
}
export declare class ShieldedEncryptionPublicKey {
    static readonly keyLength = 32;
    static readonly codec: Bech32mCodec<ShieldedEncryptionPublicKey>;
    static fromHexString(hexString: string): ShieldedEncryptionPublicKey;
    readonly data: Buffer;
    constructor(data: Buffer);
    toHexString(): string;
    equals(other: string): boolean;
    equals(other: ShieldedEncryptionPublicKey): boolean;
}
export declare class UnshieldedAddress {
    readonly data: Buffer;
    static readonly keyLength = 32;
    static readonly codec: Bech32mCodec<UnshieldedAddress>;
    static readonly [Bech32mSymbol]: Bech32mCodec<UnshieldedAddress>;
    readonly [Bech32mSymbol]: Bech32mCodec<UnshieldedAddress>;
    constructor(data: Buffer);
    get hexString(): UserAddress;
    equals(other: string): boolean;
    equals(other: UnshieldedAddress): boolean;
}
export declare class DustAddress {
    readonly data: bigint;
    static readonly codec: Bech32mCodec<DustAddress>;
    static readonly [Bech32mSymbol]: Bech32mCodec<DustAddress>;
    readonly [Bech32mSymbol]: Bech32mCodec<DustAddress>;
    static readonly encodePublicKey: (networkId: string, publicKey: DustPublicKey) => string;
    constructor(data: bigint);
    serialize(): Buffer;
    equals(other: bigint): boolean;
    equals(other: DustAddress): boolean;
}
