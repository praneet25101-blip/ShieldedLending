{
  "version": 3,
  "sources": ["../../@subsquid/scale-codec/src/types.ts", "browser-external:assert", "../../@subsquid/util-internal-hex/src/hex.ts", "../../@subsquid/scale-codec/src/util.ts", "../../@subsquid/scale-codec/src/src.ts", "../../@subsquid/scale-codec/src/sink.ts", "../../@subsquid/scale-codec/src/types-codec.ts", "../../@subsquid/scale-codec/src/codec.ts", "../../@subsquid/util-internal-json/src/json.ts", "../../@subsquid/scale-codec/src/codec-json.ts", "../../@subsquid/scale-codec/src/index.ts", "../../@midnight-ntwrk/wallet-sdk-address-format/node_modules/@scure/base/index.ts", "../../@midnight-ntwrk/wallet-sdk-address-format/dist/index.js"],
  "sourcesContent": ["/**\n * Hex encoded binary data\n */\nexport type Bytes = string\n\n\nexport type Ti = number\n\n\nexport type Primitive =\n    'I8' | 'U8' |\n    'I16' | 'U16' |\n    'I32' | 'U32' |\n    'I64' | 'U64' |\n    'I128' | 'U128' |\n    'I256' | 'U256' |\n    'Bool' |\n    'Str' |\n    'Char'\n\n\nexport enum TypeKind {\n    Primitive,\n    Compact,\n    Sequence,\n    BitSequence,\n    Array,\n    Tuple,\n    Composite,\n    Variant,\n    Option,\n    DoNotConstruct,\n    BooleanOption,\n    Bytes,\n    BytesArray,\n    HexBytes,\n    HexBytesArray,\n    /**\n     * @internal\n     */\n    Struct\n}\n\n\nexport interface PrimitiveType {\n    kind: TypeKind.Primitive\n    primitive: Primitive\n}\n\n\nexport interface CompactType {\n    kind: TypeKind.Compact\n    type: Ti\n}\n\n\nexport interface SequenceType {\n    kind: TypeKind.Sequence\n    type: Ti\n}\n\n\nexport interface BitSequenceType {\n    kind: TypeKind.BitSequence\n    bitStoreType: Ti\n    bitOrderType: Ti\n}\n\n\nexport interface ArrayType {\n    kind: TypeKind.Array\n    len: number\n    type: Ti\n}\n\n\nexport interface BytesType {\n    kind: TypeKind.Bytes\n}\n\n\nexport interface BytesArrayType {\n    kind: TypeKind.BytesArray\n    len: number\n}\n\n\nexport interface HexBytesType {\n    kind: TypeKind.HexBytes\n}\n\n\nexport interface HexBytesArrayType {\n    kind: TypeKind.HexBytesArray\n    len: number\n}\n\n\nexport interface TupleType {\n    kind: TypeKind.Tuple\n    tuple: Ti[]\n}\n\n\nexport interface CompositeType {\n    kind: TypeKind.Composite\n    fields: Field[]\n}\n\n\nexport interface Field {\n    name?: string | undefined\n    type: Ti\n}\n\n\nexport interface VariantType {\n    kind: TypeKind.Variant\n    variants: Variant[]\n}\n\n\nexport interface Variant {\n    index: number\n    name: string\n    fields: Field[]\n}\n\n\nexport interface OptionType {\n    kind: TypeKind.Option\n    type: Ti\n}\n\n\nexport interface BooleanOption {\n    kind: TypeKind.BooleanOption\n}\n\n\nexport interface DoNotConstructType {\n    kind: TypeKind.DoNotConstruct\n}\n\n\nexport type Type =\n    PrimitiveType |\n    CompactType |\n    SequenceType |\n    BitSequenceType |\n    ArrayType |\n    BytesType |\n    BytesArrayType |\n    HexBytesType |\n    HexBytesArrayType |\n    TupleType |\n    CompositeType |\n    VariantType |\n    OptionType |\n    BooleanOption |\n    DoNotConstructType\n\n\nexport interface BitSequence {\n    bytes: Uint8Array\n    bitLength: number\n}\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"assert\" has been externalized for browser compatibility. Cannot access \"assert.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "import assert from \"assert\"\n\n\nexport function toHex(data: Uint8Array): string {\n    if (Buffer.isBuffer(data)) {\n        return '0x' + data.toString('hex')\n    } else {\n        return '0x' + Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString('hex')\n    }\n}\n\n\nexport function isHex(value: unknown): value is string {\n    return typeof value == 'string' && value.length % 2 == 0 && /^0x[a-f\\d]*$/i.test(value)\n}\n\n\nexport function decodeHex(value: string): Buffer {\n    assert(isHex(value))\n    return Buffer.from(value.slice(2), 'hex')\n}\n", "import assert from \"assert\"\n\n\nexport function assertNotNull<T>(val: T | undefined | null, msg?: string): T {\n    assert(val != null, msg)\n    return val\n}\n\n\nexport function throwUnexpectedCase(val?: unknown): never {\n    throw new Error(val ? `Unexpected case: ${val}` : `Unexpected case`)\n}\n\n\nfunction checkInt(val: unknown, sign: string, bitSize: number, min: number, max: number): asserts val is number {\n    let ok = Number.isInteger(val) && min <= (val as number) && max >= (val as number)\n    if (!ok) throw new Error(\n        `Invalid ${sign}${bitSize}: ${val}`\n    )\n}\n\n\nfunction checkBigInt(val: unknown, sign: string, bitSize: number, min: bigint, max: bigint): asserts val is bigint {\n    let ok = typeof val == 'bigint' && min <= val && max >= val\n    if (!ok) throw new Error(\n        `Invalid ${sign}${bitSize}: ${val}`\n    )\n}\n\n\nexport function checkSignedInt(val: unknown, bitSize: number): asserts val is number {\n    let min: number\n    let max: number\n    switch(bitSize) {\n        case 8:\n            min = -0x80\n            max = 0x7f\n            break\n        case 16:\n            min = -0x8000\n            max = 0x7fff\n            break\n        case 32:\n            min = -0x80000000\n            max = 0x7fffffff\n            break\n        default:\n            throwUnexpectedCase(bitSize)\n    }\n    checkInt(val, 'I', bitSize, min, max)\n}\n\n\nexport function checkSignedBigInt(val: unknown, bitSize: number): asserts val is bigint {\n    let min: bigint\n    let max: bigint\n    switch(bitSize) {\n        case 64:\n            min = -(2n ** 63n)\n            max = 2n ** 63n - 1n\n            break\n        case 128:\n            min = -(2n ** 127n)\n            max = 2n ** 127n - 1n\n            break\n        case 256:\n            min = -(2n ** 255n)\n            max = 2n ** 255n - 1n\n            break\n        default:\n            throwUnexpectedCase(bitSize)\n    }\n    checkBigInt(val, 'I', bitSize, min, max)\n}\n\n\nexport function checkUnsignedInt(val: unknown, bitSize: number): asserts val is number {\n    let max: number\n    switch(bitSize) {\n        case 8:\n            max = 0xff\n            break\n        case 16:\n            max = 0xffff\n            break\n        case 32:\n            max = 0xffffffff\n            break\n        default:\n            throwUnexpectedCase(bitSize)\n    }\n    checkInt(val, 'U', bitSize, 0, max)\n}\n\n\nexport function checkUnsignedBigInt(val: unknown, bitSize: number): asserts val is bigint {\n    let max: bigint\n    switch(bitSize) {\n        case 64:\n            max = 0xffffffffffffffffn\n            break\n        case 128:\n            max = 2n ** 128n - 1n\n            break\n        case 256:\n            max = 2n ** 256n - 1n\n            break\n        default:\n            throwUnexpectedCase(bitSize)\n    }\n    checkBigInt(val, 'U', bitSize, 0n, max)\n}\n\n\nexport function toSignedBigInt(val: unknown, bitSize: number): bigint {\n    assert(typeof val == 'string' || typeof val == 'number')\n    val = BigInt(val)\n    checkSignedBigInt(val, bitSize)\n    return val\n}\n\n\nexport function toUnsignedBigInt(val: unknown, bitSize: number): bigint {\n    assert(typeof val == 'string' || typeof val == 'number')\n    val = BigInt(val)\n    checkUnsignedBigInt(val, bitSize)\n    return val\n}\n\n\nexport const UTF8_DECODER = new TextDecoder(\"utf-8\", {\n    fatal: true,\n    ignoreBOM: false\n})\n\n\nexport const UTF8_ENCODER = new TextEncoder()\n\n\nexport function unsignedIntByteLength(val: bigint): number {\n    let len = 0\n    while (val > 0n) {\n        val = val >> 8n\n        len += 1\n    }\n    return len\n}\n\n\nexport function isObject(value: unknown): boolean {\n    return value != null && typeof value == 'object'\n}\n", "import {decodeHex} from '@subsquid/util-internal-hex'\nimport assert from 'assert'\n\nimport {Bytes} from './types'\nimport {UTF8_DECODER} from './util'\n\n\nexport class Src {\n    private idx = 0\n    private buf: Uint8Array\n\n    constructor(buf: Uint8Array | Bytes) {\n        if (typeof buf == 'string') {\n            this.buf = decodeHex(buf)\n        } else {\n            this.buf = buf\n        }\n    }\n\n    private byte(): number {\n        let b = this.buf[this.idx]\n        if (b === undefined) {\n            throw eof()\n        }\n        this.idx += 1\n        return b\n    }\n\n    i8(): number {\n        let b = this.byte()\n        return b | (b & 2 ** 7) * 0x1fffffe\n    }\n\n    u8(): number {\n        return this.byte()\n    }\n\n    i16(): number {\n        let val = this.u16()\n        return val | (val & 2 ** 15) * 0x1fffe\n    }\n\n    u16(): number {\n        let first = this.byte()\n        let last = this.byte()\n        return first + last * 2 ** 8\n    }\n\n    i32(): number {\n        return this.byte() + this.byte() * 2 ** 8 + this.byte() * 2 ** 16 + (this.byte() << 24)\n    }\n\n    u32(): number {\n        return this.byte() + this.byte() * 2 ** 8 + this.byte() * 2 ** 16 + this.byte() * 2 ** 24\n    }\n\n    i64(): bigint {\n        let lo = this.u32()\n        let hi = this.i32()\n        return BigInt(lo) + (BigInt(hi) << 32n)\n    }\n\n    u64(): bigint {\n        let lo = this.u32()\n        let hi = this.u32()\n        return BigInt(lo) + (BigInt(hi) << 32n)\n    }\n\n    i128(): bigint {\n        let lo = this.u64()\n        let hi = this.i64()\n        return lo + (hi << 64n)\n    }\n\n    u128(): bigint {\n        let lo = this.u64()\n        let hi = this.u64()\n        return lo + (hi << 64n)\n    }\n\n    i256(): bigint {\n        let lo = this.u128()\n        let hi = this.i128()\n        return lo + (hi << 128n)\n    }\n\n    u256(): bigint {\n        let lo = this.u128()\n        let hi = this.u128()\n        return lo + (hi << 128n)\n    }\n\n    compact(): number | bigint {\n        let b = this.byte()\n        let mode = b & 3\n        switch(mode) {\n            case 0:\n                return b >> 2\n            case 1:\n                return (b >> 2) + this.byte() * 2 ** 6\n            case 2:\n                return (b >> 2) + this.byte() * 2 ** 6 + this.byte() * 2 ** 14 + this.byte() * 2 ** 22\n            case 3:\n                return this.bigCompact(b >> 2)\n            default:\n                throw new Error('Reached unreachable statement')\n        }\n    }\n\n    private bigCompact(len: number): bigint | number {\n        let i = this.u32()\n        switch(len) {\n            case 0:\n                return i\n            case 1:\n                return i + this.byte() * 2 ** 32\n            case 2:\n                return i + this.byte() * 2 ** 32 + this.byte() * 2 ** 40\n        }\n        let n = BigInt(i)\n        let base = 32n\n        while (len--) {\n            n += BigInt(this.byte()) << base\n            base += 8n\n        }\n        return n\n    }\n\n    compactLength(): number {\n        let len = this.compact()\n        assert(typeof len == 'number')\n        return len\n    }\n\n    str(): string {\n        let len = this.compactLength()\n        let buf = this.bytes(len)\n        return UTF8_DECODER.decode(buf)\n    }\n\n    bytes(len: number): Uint8Array {\n        let beg = this.idx\n        let end = this.idx += len\n        if (this.buf.length < end) {\n            throw eof()\n        }\n        return this.buf.subarray(beg, end)\n    }\n\n    skip(len: number): void {\n        this.idx += len\n    }\n\n    bool(): boolean {\n        return !!this.byte()\n    }\n\n    hasBytes(): boolean {\n        return this.buf.length > this.idx\n    }\n\n    assertEOF(): void {\n        if (this.hasBytes()) {\n            throw new Error('Unprocessed data left')\n        }\n    }\n}\n\n\nfunction eof(): Error {\n    return new Error('Unexpected EOF')\n}\n", "import assert from 'assert'\nimport {\n    checkSignedBigInt,\n    checkSignedInt,\n    checkUnsignedBigInt,\n    checkUnsignedInt,\n    unsignedIntByteLength,\n    UTF8_ENCODER\n} from './util'\n\n\nexport abstract class Sink {\n    protected abstract write(byte: number): void\n\n    abstract bytes(b: Uint8Array): void\n\n    private uncheckedU16(val: number): void {\n        this.write(val & 0xff)\n        this.write(val >>> 8)\n    }\n\n    private uncheckedU32(val: number): void {\n        this.write(val & 0xff)\n        this.write((val >>> 8) & 0xff)\n        this.write((val >>> 16) & 0xff)\n        this.write(val >>> 24)\n    }\n\n    private uncheckedU64(val: bigint): void {\n        this.uncheckedU32(Number(val & 0xffffffffn))\n        this.uncheckedU32(Number(val >> 32n))\n    }\n\n    private uncheckedU128(val: bigint): void {\n        this.uncheckedU64(val & 0xffffffffffffffffn)\n        this.uncheckedU64(val >> 64n)\n    }\n\n    private uncheckedU256(val: bigint): void {\n        this.uncheckedU128(val & (2n ** 128n) - 1n)\n        this.uncheckedU128(val >> 128n)\n    }\n\n    u8(val: number): void {\n        checkUnsignedInt(val, 8)\n        this.write(val)\n    }\n\n    u16(val: number): void {\n        checkUnsignedInt(val, 16)\n        this.uncheckedU16(val)\n    }\n\n    u32(val: number): void {\n        checkUnsignedInt(val, 32)\n        this.uncheckedU32(val)\n    }\n\n    u64(val: bigint): void {\n        checkUnsignedBigInt(val, 64)\n        this.uncheckedU64(val)\n    }\n\n    u128(val: bigint): void {\n        checkUnsignedBigInt(val, 128)\n        this.uncheckedU128(val)\n    }\n\n    u256(val: bigint): void {\n        checkUnsignedBigInt(val, 256)\n        this.uncheckedU256(val)\n    }\n\n    i8(val: number): void {\n        checkSignedInt(val, 8)\n        this.write((val + 256) % 256)\n    }\n\n    i16(val: number): void {\n        checkSignedInt(val, 16)\n        let base = 2 ** 16\n        val = (val + base) % base\n        this.uncheckedU16(val)\n    }\n\n    i32(val: number): void {\n        checkSignedInt(val, 32)\n        let base = 2 ** 32\n        val = (val + base) % base\n        this.uncheckedU32(val)\n    }\n\n    i64(val: bigint): void {\n        checkSignedBigInt(val, 64)\n        let base = 2n ** 64n\n        val = (val + base) % base\n        this.uncheckedU64(val)\n    }\n\n    i128(val: bigint): void {\n        checkSignedBigInt(val, 128)\n        let base = 2n ** 128n\n        val = (val + base) % base\n        this.uncheckedU128(val)\n    }\n\n    i256(val: bigint): void {\n        checkSignedBigInt(val, 256)\n        let base = 2n ** 256n\n        val = (val + base) % base\n        this.uncheckedU256(val)\n    }\n\n    str(val: string): void {\n        assert(typeof val == 'string')\n        let bytes = UTF8_ENCODER.encode(val)\n        this.compact(bytes.length)\n        this.bytes(bytes)\n    }\n\n    bool(val: boolean): void {\n        assert(typeof val == 'boolean')\n        this.write(Number(val))\n    }\n\n    compact(val: number | bigint): void {\n        assert((typeof val == 'number' || typeof val == 'bigint') && val >= 0, 'invalid compact')\n        if (val < 64) {\n            this.write(Number(val) * 4)\n        } else if (val < 2 ** 14) {\n            val = Number(val)\n            this.write((val & 63) * 4 + 1)\n            this.write(val >>> 6)\n        } else if (val < 2 ** 30) {\n            val = Number(val)\n            this.write((val & 63) * 4 + 2)\n            this.write((val >>> 6) & 0xff)\n            this.uncheckedU16(val >>> 14)\n        } else if (val < 2n ** 536n) {\n            val = BigInt(val)\n            this.write(unsignedIntByteLength(val) * 4 - 13)\n            while (val > 0) {\n                this.write(Number(val & 0xffn))\n                val = val >> 8n\n            }\n        } else {\n            throw new Error(`${val.toString(16)} is too large for a compact`)\n        }\n    }\n}\n\n\nexport class HexSink extends Sink {\n    private out = '0x'\n\n    protected write(byte: number): void {\n        this.out += (byte >>> 4).toString(16)\n        this.out += (byte & 15).toString(16)\n    }\n\n    bytes(b: Uint8Array): void {\n        if (Buffer.isBuffer(b)) {\n            this.out += b.toString('hex')\n        } else {\n            this.out += Buffer.from(b.buffer, b.byteOffset, b.byteLength).toString('hex')\n        }\n    }\n\n    toHex(): string {\n        return this.out\n    }\n}\n\n\nexport class ByteSink extends Sink {\n    private buf = Buffer.allocUnsafe(128)\n    private pos = 0\n\n    private alloc(size: number): void {\n        if (this.buf.length - this.pos < size) {\n            let buf = Buffer.allocUnsafe(Math.max(size, this.buf.length) * 2)\n            buf.set(this.buf)\n            this.buf = buf\n        }\n    }\n\n    protected write(byte: number): void {\n        this.alloc(1)\n        this.buf[this.pos] = byte\n        this.pos += 1\n    }\n\n    bytes(b: Uint8Array): void {\n        this.alloc(b.length)\n        this.buf.set(b, this.pos)\n        this.pos += b.length\n    }\n\n    toBytes(): Uint8Array {\n        return this.buf.subarray(0, this.pos)\n    }\n}\n", "import assert from 'assert'\nimport {\n    ArrayType,\n    BitSequenceType,\n    BooleanOption,\n    BytesArrayType,\n    BytesType,\n    DoNotConstructType,\n    HexBytesArrayType,\n    HexBytesType,\n    OptionType,\n    Primitive,\n    PrimitiveType,\n    SequenceType,\n    Ti,\n    TupleType,\n    Type,\n    TypeKind,\n    Variant\n} from './types'\nimport {assertNotNull} from './util'\n\n\nexport interface CodecStructType {\n    kind: TypeKind.Struct\n    fields: {name: string, type: Ti}[]\n}\n\n\nexport interface CodecStructVariant {\n    kind: 'struct'\n    name: string\n    index: number\n    def: CodecStructType\n}\n\n\nexport interface CodecTupleVariant {\n    kind: 'tuple'\n    name: string\n    index: number\n    def: TupleType\n}\n\n\nexport interface CodecValueVariant {\n    kind: 'value'\n    name: string\n    index: number\n    type: Ti\n}\n\n\nexport interface CodecEmptyVariant {\n    kind: 'empty'\n    name: string\n    index: number\n}\n\n\nexport type CodecVariant = CodecStructVariant | CodecTupleVariant | CodecValueVariant | CodecEmptyVariant\n\n\nexport interface CodecVariantType {\n    kind: TypeKind.Variant\n    variants: (CodecVariant | undefined)[]\n    variantsByName: Record<string, CodecVariant>\n}\n\n\nexport interface CodecCompactType {\n    kind: TypeKind.Compact\n    integer: Primitive\n}\n\n\nexport type CodecType =\n    PrimitiveType |\n    SequenceType |\n    BitSequenceType |\n    ArrayType |\n    BytesType |\n    BytesArrayType |\n    HexBytesType |\n    HexBytesArrayType |\n    TupleType |\n    OptionType |\n    BooleanOption |\n    DoNotConstructType |\n    CodecCompactType |\n    CodecStructType |\n    CodecVariantType\n\n\nexport function getCodecType(types: Type[], ti: Ti): CodecType {\n    let def = types[ti]\n    switch(def.kind) {\n        case TypeKind.Compact: {\n            let compact = types[def.type]\n            assert(compact.kind == TypeKind.Primitive)\n            assert(compact.primitive[0] == 'U')\n            return {kind: TypeKind.Compact, integer: compact.primitive}\n        }\n        case TypeKind.Composite:\n            if (def.fields.length == 0 || def.fields[0].name == null) {\n                return {\n                    kind: TypeKind.Tuple,\n                    tuple: def.fields.map(f => {\n                        assert(f.name == null)\n                        return f.type\n                    })\n                }\n            } else {\n                return {\n                    kind: TypeKind.Struct,\n                    fields: def.fields.map(f => {\n                        let name = assertNotNull(f.name)\n                        return {name, type: f.type}\n                    })\n                }\n            }\n        case TypeKind.Variant: {\n            let variants = def.variants.filter(v => v != null) as Variant[]\n            let variantsByName: Record<string, CodecVariant> = {}\n            let uniqueIndexes = new Set(variants.map(v => v.index))\n            if (uniqueIndexes.size != variants.length) {\n                throw new Error(`Variant type ${ti} has duplicate case indexes`)\n            }\n            let len = variants.reduce((len, v) => Math.max(len, v.index), 0) + 1\n            let placedVariants: (CodecVariant | undefined)[] = new Array(len)\n            variants.forEach(v => {\n                let cv: CodecVariant\n                if (v.fields[0]?.name == null) {\n                    switch(v.fields.length) {\n                        case 0:\n                            cv = {kind: 'empty', name: v.name, index: v.index}\n                            break\n                        case 1:\n                            cv = {kind: 'value', name: v.name, index: v.index, type: v.fields[0].type}\n                            break\n                        default:\n                            cv = {\n                                kind: 'tuple',\n                                name: v.name,\n                                index: v.index,\n                                def: {\n                                    kind: TypeKind.Tuple,\n                                    tuple: v.fields.map(f => {\n                                        assert(f.name == null)\n                                        return f.type\n                                    })\n                                }\n                            }\n                    }\n                } else {\n                    cv = {\n                        kind: 'struct',\n                        name: v.name,\n                        index: v.index,\n                        def: {\n                            kind: TypeKind.Struct,\n                            fields: v.fields.map(f => {\n                                let name = assertNotNull(f.name)\n                                return {name, type: f.type}\n                            })\n                        }\n                    }\n                }\n                placedVariants[v.index] = cv\n                variantsByName[cv.name] = cv\n            })\n            return {\n                kind: TypeKind.Variant,\n                variants: placedVariants,\n                variantsByName\n            }\n        }\n        default:\n            return def\n    }\n}\n\n\nexport function toCodecTypes(types: Type[]): CodecType[] {\n    let codecTypes: CodecType[] = new Array(types.length)\n    for (let i = 0; i < types.length; i++) {\n        codecTypes[i] = getCodecType(types, i)\n    }\n    return codecTypes\n}\n", "import {decodeHex, toHex} from '@subsquid/util-internal-hex'\nimport assert from 'assert'\nimport {ByteSink, HexSink, Sink} from './sink'\nimport {Src} from './src'\nimport {\n    ArrayType,\n    BitSequence,\n    Bytes,\n    OptionType,\n    Primitive,\n    SequenceType,\n    Ti,\n    TupleType,\n    Type,\n    TypeKind\n} from './types'\nimport {CodecCompactType, CodecStructType, CodecType, CodecVariantType, toCodecTypes} from './types-codec'\nimport {throwUnexpectedCase} from './util'\n\n\nexport class Codec {\n    private types: CodecType[]\n\n    constructor(types: Type[]) {\n        this.types = toCodecTypes(types)\n    }\n\n    decodeBinary(type: Ti, data: Bytes | Uint8Array): any {\n        let src = new Src(data)\n        let val = this.decode(type, src)\n        src.assertEOF()\n        return val\n    }\n\n    encodeToHex(type: Ti, val: unknown): Bytes {\n        let sink = new HexSink()\n        this.encode(type, val, sink)\n        return sink.toHex()\n    }\n\n    encodeToBinary(type: Ti, val: unknown): Uint8Array {\n        let sink = new ByteSink()\n        this.encode(type, val, sink)\n        return sink.toBytes()\n    }\n\n    decode(type: Ti, src: Src): any {\n        let def = this.types[type]\n        switch(def.kind) {\n            case TypeKind.Primitive:\n                return decodePrimitive(def.primitive, src)\n            case TypeKind.Compact:\n                return decodeCompact(def, src)\n            case TypeKind.BitSequence:\n                return decodeBitSequence(src)\n            case TypeKind.Array:\n                return this.decodeArray(def, src)\n            case TypeKind.Sequence:\n                return this.decodeSequence(def, src)\n            case TypeKind.Tuple:\n                return this.decodeTuple(def, src)\n            case TypeKind.Struct:\n                return this.decodeStruct(def, src)\n            case TypeKind.Variant:\n                return this.decodeVariant(def, src)\n            case TypeKind.Option:\n                return this.decodeOption(def, src)\n            case TypeKind.BooleanOption:\n                return decodeBooleanOption(src)\n            case TypeKind.Bytes:\n                return decodeBytes(src)\n            case TypeKind.BytesArray:\n                return src.bytes(def.len)\n            case TypeKind.HexBytes:\n                return toHex(decodeBytes(src))\n            case TypeKind.HexBytesArray:\n                return toHex(src.bytes(def.len))\n            case TypeKind.DoNotConstruct:\n                throwUnexpectedCase('DoNotConstruct type reached')\n            default:\n                throwUnexpectedCase((def as Type).kind)\n        }\n    }\n\n    private decodeArray(def: ArrayType, src: Src): any[] {\n        let {len, type} = def\n        let result: any[] = new Array(len)\n        for (let i = 0; i < len; i++) {\n            result[i] = this.decode(type, src)\n        }\n        return result\n    }\n\n    private decodeSequence(def: SequenceType, src: Src): any[] {\n        let len = src.compactLength()\n        let result: any[] = new Array(len)\n        for (let i = 0; i < len; i++) {\n            result[i] = this.decode(def.type, src)\n        }\n        return result\n    }\n\n    private decodeTuple(def: TupleType, src: Src): any[] | null {\n        if (def.tuple.length == 0) return null\n        let result: any[] = new Array(def.tuple.length)\n        for (let i = 0; i < def.tuple.length; i++) {\n            result[i] = this.decode(def.tuple[i], src)\n        }\n        return result\n    }\n\n    private decodeStruct(def: CodecStructType, src: Src): any {\n        let result: any = {}\n        for (let i = 0; i < def.fields.length; i++) {\n            let f = def.fields[i]\n            result[f.name] = this.decode(f.type, src)\n        }\n        return result\n    }\n\n    private decodeVariant(def: CodecVariantType, src: Src) {\n        let idx = src.u8()\n        let variant = def.variants[idx]\n        if (variant == null) throwUnexpectedCase(`unknown variant index: ${idx}`)\n        switch(variant.kind) {\n            case 'empty':\n                return {\n                    __kind: variant.name\n                }\n            case 'tuple':\n                return {\n                    __kind: variant.name,\n                    value: this.decodeTuple(variant.def, src)\n                }\n            case 'value':\n                return {\n                    __kind: variant.name,\n                    value: this.decode(variant.type, src)\n                }\n            case 'struct': {\n                let value = this.decodeStruct(variant.def, src)\n                value.__kind = variant.name\n                return value\n            }\n            default:\n                throwUnexpectedCase()\n        }\n    }\n\n    private decodeOption(def: OptionType, src: Src) {\n        let byte = src.u8()\n        switch(byte) {\n            case 0:\n                return undefined\n            case 1:\n                return this.decode(def.type, src)\n            default:\n                throwUnexpectedCase(byte.toString())\n        }\n    }\n\n    encode(type: Ti, val: any, sink: Sink): void {\n        let def = this.types[type]\n        switch(def.kind) {\n            case TypeKind.Primitive:\n                encodePrimitive(def.primitive, val, sink)\n                break\n            case TypeKind.Compact:\n                sink.compact(val)\n                break\n            case TypeKind.BitSequence:\n                encodeBitSequence(val, sink)\n                break\n            case TypeKind.Array:\n                this.encodeArray(def, val, sink)\n                break\n            case TypeKind.Sequence:\n                this.encodeSequence(def, val, sink)\n                break\n            case TypeKind.Tuple:\n                this.encodeTuple(def, val, sink)\n                break\n            case TypeKind.Struct:\n                this.encodeStruct(def, val, sink)\n                break\n            case TypeKind.Variant:\n                this.encodeVariant(def, val, sink)\n                break\n            case TypeKind.BytesArray:\n                encodeBytesArray(def, val, sink)\n                break\n            case TypeKind.HexBytesArray:\n                encodeBytesArray(def, decodeHex(val), sink)\n                break\n            case TypeKind.Bytes:\n                encodeBytes(val, sink)\n                break\n            case TypeKind.HexBytes:\n                encodeBytes(decodeHex(val), sink)\n                break\n            case TypeKind.BooleanOption:\n                encodeBooleanOption(val, sink)\n                break\n            case TypeKind.Option:\n                this.encodeOption(def, val, sink)\n                break\n            default:\n                throwUnexpectedCase(def.kind)\n        }\n    }\n\n    private encodeArray(def: ArrayType, val: unknown, sink: Sink): void {\n        assert(Array.isArray(val) && val.length == def.len)\n        for (let i = 0; i < val.length; i++) {\n            this.encode(def.type, val[i], sink)\n        }\n    }\n\n    private encodeSequence(def: SequenceType, val: unknown, sink: Sink): void {\n        assert(Array.isArray(val))\n        sink.compact(val.length)\n        for (let i = 0; i < val.length; i++) {\n            this.encode(def.type, val[i], sink)\n        }\n    }\n\n    private encodeTuple(def: TupleType, val: unknown, sink: Sink): void {\n        if (def.tuple.length == 0) {\n            assert(val == null)\n            return\n        }\n        assert(Array.isArray(val) && def.tuple.length == val.length)\n        for (let i = 0; i < val.length; i++) {\n            this.encode(def.tuple[i], val[i], sink)\n        }\n    }\n\n    private encodeStruct(def: CodecStructType, val: any, sink: Sink): void {\n        for (let i = 0; i < def.fields.length; i++) {\n            let f = def.fields[i]\n            this.encode(f.type, val[f.name], sink)\n        }\n    }\n\n    private encodeVariant(def: CodecVariantType, val: any, sink: Sink): void {\n        assert(typeof val?.__kind == 'string', 'not a variant type value')\n        let variant = def.variantsByName[val.__kind]\n        if (variant == null) throw new Error(`Unknown variant: ${val.__kind}`)\n        sink.u8(variant.index)\n        switch(variant.kind) {\n            case 'empty':\n                break\n            case 'value':\n                this.encode(variant.type, val.value, sink)\n                break\n            case 'tuple':\n                this.encodeTuple(variant.def, val.value, sink)\n                break\n            case 'struct':\n                this.encodeStruct(variant.def, val, sink)\n                break\n            default:\n                throwUnexpectedCase()\n        }\n    }\n\n    private encodeOption(def: OptionType, val: unknown, sink: Sink): void {\n        if (val === undefined) {\n            sink.u8(0)\n        } else {\n            sink.u8(1)\n            this.encode(def.type, val, sink)\n        }\n    }\n}\n\n\nfunction decodeBytes(src: Src): Uint8Array {\n    let len = src.compactLength()\n    return src.bytes(len)\n}\n\n\nfunction encodeBytes(val: unknown, sink: Sink): void {\n    assert(val instanceof Uint8Array)\n    sink.compact(val.length)\n    sink.bytes(val)\n}\n\n\nfunction encodeBytesArray(def: {len: number}, val: unknown, sink: Sink): void {\n    assert(val instanceof Uint8Array && val.length == def.len)\n    sink.bytes(val)\n}\n\n\nfunction decodeBitSequence(src: Src): BitSequence {\n    let bitLength = src.compactLength()\n    let byteLength = Math.ceil(bitLength / 8)\n    let bytes = src.bytes(byteLength)\n    return {\n        bytes,\n        bitLength\n    }\n}\n\n\nfunction encodeBitSequence(val: any, sink: Sink): void {\n    assert(\n        val &&\n        typeof val == 'object' &&\n        Number.isInteger(val.bitLength) &&\n        val.bytes instanceof Uint8Array\n    )\n    let bits = val as BitSequence\n    assert(Math.ceil(bits.bitLength / 8) == bits.bytes.length)\n    sink.compact(bits.bitLength)\n    sink.bytes(bits.bytes)\n}\n\n\nfunction decodeBooleanOption(src: Src): boolean | null {\n    let byte = src.u8()\n    switch(byte) {\n        case 0:\n            return null\n        case 1:\n            return true\n        case 2:\n            return false\n        default:\n            throwUnexpectedCase(byte.toString())\n    }\n}\n\n\nfunction encodeBooleanOption(val: unknown, sink: Sink): void {\n    if (val == null) {\n        sink.u8(0)\n    } else {\n        assert(typeof val == 'boolean')\n        sink.u8(val ? 1 : 2)\n    }\n}\n\n\nfunction decodeCompact(type: CodecCompactType, src: Src): number | bigint {\n    let n = src.compact()\n    switch(type.integer) {\n        case \"U8\":\n        case \"U16\":\n        case \"U32\":\n            return n\n        default:\n            return BigInt(n)\n    }\n}\n\n\nfunction decodePrimitive(type: Primitive, src: Src): any {\n    switch(type) {\n        case 'I8':\n            return src.i8()\n        case 'U8':\n            return src.u8()\n        case 'I16':\n            return src.i16()\n        case 'U16':\n            return src.u16()\n        case 'I32':\n            return src.i32()\n        case 'U32':\n            return src.u32()\n        case 'I64':\n            return src.i64()\n        case 'U64':\n            return src.u64()\n        case 'I128':\n            return src.i128()\n        case 'U128':\n            return src.u128()\n        case 'I256':\n            return src.i256()\n        case 'U256':\n            return src.u256()\n        case 'Bool':\n            return src.bool()\n        case 'Str':\n            return src.str()\n        default:\n            throwUnexpectedCase(type)\n    }\n}\n\n\nfunction encodePrimitive(type: Primitive, val: any, sink: Sink): void {\n    switch(type) {\n        case 'I8':\n            sink.i8(val)\n            break\n        case 'U8':\n            sink.u8(val)\n            break\n        case 'I16':\n            sink.i16(val)\n            break\n        case 'U16':\n            sink.u16(val)\n            break\n        case 'I32':\n            sink.i32(val)\n            break\n        case 'U32':\n            sink.u32(val)\n            break\n        case 'I64':\n            sink.i64(val)\n            break\n        case 'U64':\n            sink.u64(val)\n            break\n        case 'I128':\n            sink.i128(val)\n            break\n        case 'U128':\n            sink.u128(val)\n            break\n        case 'I256':\n            sink.i256(val)\n            break\n        case 'U256':\n            sink.u256(val)\n            break\n        case 'Bool':\n            sink.bool(val)\n            break\n        case 'Str':\n            sink.str(val)\n            break\n        default:\n            throwUnexpectedCase(type)\n    }\n}\n", "import {toHex} from \"@subsquid/util-internal-hex\"\n\n\nexport function toJSON(val: unknown): any {\n    let json: any\n    switch(typeof val) {\n        case 'bigint':\n            return val.toString()\n        case 'object':\n            if (val == null) return null\n            if (val instanceof Uint8Array) {\n                return toHex(val)\n            } else if (val instanceof Date) {\n                return val.toISOString()\n            } else if (typeof (val as any).toJSON == 'function' && (json = (val as any).toJSON()) !== val) {\n                return toJSON(json)\n            } else if (val instanceof Error) {\n                json = {}\n                if (val.stack) {\n                    json.stack = val.stack\n                } else {\n                    json.stack = val.toString()\n                }\n                json = toJsonObject(val, json)\n                return json\n            } else if (val instanceof Map) {\n                let entries: {k: unknown, v: unknown}[] = []\n                for (let [k, v] of val.entries()) {\n                    entries.push({k, v})\n                }\n                return toJSON({map: entries})\n            } else if (val instanceof Set) {\n                return toJSON({set: [...val]})\n            } else if (Array.isArray(val)) {\n                return toJsonArray(val)\n            }  else {\n                return toJsonObject(val)\n            }\n        default:\n            return val\n    }\n}\n\n\nfunction toJsonArray(val: unknown[]): any[] {\n    let arr = new Array(val.length)\n    for (let i = 0; i < val.length; i++) {\n        arr[i] = toJSON(val[i])\n    }\n    return arr\n}\n\n\nfunction toJsonObject(val: any, result?: any): any {\n    result = result || {}\n    for (let key in val) {\n        result[key] = toJSON(val[key])\n    }\n    return result\n}\n", "import {decodeHex, isHex} from '@subsquid/util-internal-hex'\nimport {toJSON} from '@subsquid/util-internal-json'\nimport assert from 'assert'\nimport {ArrayType, OptionType, Primitive, SequenceType, Ti, TupleType, Type, TypeKind} from './types'\nimport {CodecStructType, CodecType, CodecVariantType, toCodecTypes} from './types-codec'\nimport {checkSignedInt, checkUnsignedInt, isObject, throwUnexpectedCase, toSignedBigInt, toUnsignedBigInt} from './util'\n\n\nexport class JsonCodec {\n    static encode(val: unknown): any {\n        return toJSON(val)\n    }\n\n    private types: CodecType[]\n\n    constructor(types: Type[]) {\n        this.types = toCodecTypes(types)\n    }\n\n    decode(type: Ti, val: unknown): any {\n        let def = this.types[type]\n        switch(def.kind) {\n            case TypeKind.Primitive:\n                return decodePrimitive(def.primitive, val)\n            case TypeKind.Compact:\n                return decodePrimitive(def.integer, val)\n            case TypeKind.BitSequence:\n                return decodeHex(val as string)\n            case TypeKind.Array:\n                return this.decodeArray(def, val)\n            case TypeKind.Sequence:\n                return this.decodeSequence(def, val)\n            case TypeKind.Tuple:\n                return this.decodeTuple(def, val)\n            case TypeKind.Struct:\n                return this.decodeStruct(def, val)\n            case TypeKind.Variant:\n                return this.decodeVariant(def, val)\n            case TypeKind.Option:\n                return this.decodeOption(def, val)\n            case TypeKind.BooleanOption:\n                return decodeBooleanOption(val)\n            case TypeKind.Bytes:\n                return decodeHex(val as string)\n            case TypeKind.BytesArray:\n                return decodeBinaryArray(def.len, val)\n            case TypeKind.HexBytes:\n            case TypeKind.HexBytesArray:\n                assert(isHex(val))\n                return val\n            case TypeKind.DoNotConstruct:\n                throwUnexpectedCase('DoNotConstruct type reached')\n            default:\n                throwUnexpectedCase()\n        }\n    }\n\n    private decodeArray(def: ArrayType, val: unknown): any[] {\n        let {len, type} = def\n        assert(Array.isArray(val))\n        assert(val.length == len)\n        let result = new Array(len)\n        for (let i = 0; i < len; i++) {\n            result[i] = this.decode(type, val[i])\n        }\n        return result\n    }\n\n    private decodeSequence(def: SequenceType, val: unknown): any[] {\n        assert(Array.isArray(val))\n        let result = new Array(val.length)\n        for (let i = 0; i < val.length; i++) {\n            result[i] = this.decode(def.type, val[i])\n        }\n        return result\n    }\n\n    private decodeTuple(def: TupleType, value: unknown): any {\n        let items = def.tuple\n        if (items.length == 0) {\n            assert(value == null || Array.isArray(value) && value.length == 0)\n            return null\n        } else {\n            assert(Array.isArray(value))\n            assert(value.length == items.length)\n            let result: any[] = new Array(items.length)\n            for (let i = 0; i < items.length; i++) {\n                result[i] = this.decode(items[i], value[i])\n            }\n            return result\n        }\n    }\n\n    private decodeStruct(def: CodecStructType, value: any): any {\n        assert(isObject(value))\n        let result: any = {}\n        for (let i = 0; i < def.fields.length; i++) {\n            let f = def.fields[i]\n            result[f.name] = this.decode(f.type, value[f.name])\n        }\n        return result\n    }\n\n    private decodeVariant(def: CodecVariantType, val: any) {\n        assert(isObject(val))\n        assert(typeof val.__kind == 'string')\n        let variant = def.variantsByName[val.__kind]\n        if (variant == null) throw new Error(`Unknown variant ${val.__kind}`)\n        switch(variant.kind) {\n            case \"empty\":\n                return {\n                    __kind: val.__kind\n                }\n            case \"value\":\n                return {\n                    __kind: val.__kind,\n                    value: this.decode(variant.type, val.value)\n                }\n            case \"tuple\":\n                return {\n                    __kind: val.__kind,\n                    value: this.decodeTuple(variant.def, val.value)\n                }\n            case \"struct\": {\n                let s = this.decodeStruct(variant.def, val)\n                s.__kind = val.__kind\n                return s\n            }\n            default:\n                throwUnexpectedCase((variant as any).kind)\n        }\n    }\n\n    private decodeOption(def: OptionType, value: unknown): any {\n        return value == null ? undefined : this.decode(def.type, value)\n    }\n}\n\n\nfunction decodePrimitive(type: Primitive, value: unknown): string | boolean | number | bigint {\n    switch(type) {\n        case \"I8\":\n            checkSignedInt(value, 8)\n            return value\n        case \"I16\":\n            checkSignedInt(value, 16)\n            return value\n        case \"I32\":\n            checkSignedInt(value, 32)\n            return value\n        case \"I64\":\n            return toSignedBigInt(value, 64)\n        case \"I128\":\n            return toSignedBigInt(value, 128)\n        case \"I256\":\n            return toSignedBigInt(value, 256)\n        case \"U8\":\n            checkUnsignedInt(value, 8)\n            return value\n        case \"U16\":\n            checkUnsignedInt(value, 16)\n            return value\n        case \"U32\":\n            checkUnsignedInt(value, 32)\n            return value\n        case \"U64\":\n            return toUnsignedBigInt(value, 64)\n        case \"U128\":\n            return toUnsignedBigInt(value, 128)\n        case \"U256\":\n            return toUnsignedBigInt(value, 256)\n        case \"Bool\":\n            assert(typeof value == \"boolean\")\n            return value\n        case \"Str\":\n            assert(typeof value == \"string\")\n            return value\n        default:\n            throwUnexpectedCase(type)\n    }\n}\n\n\nfunction decodeBooleanOption(value: unknown): boolean | undefined {\n    if (value == null) return undefined\n    assert(typeof value == 'boolean')\n    return value\n}\n\n\nexport function decodeBinaryArray(len: number, value: unknown): Uint8Array {\n    let buf = decodeHex(value as string)\n    assert(buf.length == len)\n    return buf\n}\n", "export * from \"./types\"\nexport * from \"./src\"\nexport * from \"./sink\"\nexport * from \"./codec\"\nexport * from \"./codec-json\"\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "// This file is part of MIDNIGHT-WALLET-SDK.\n// Copyright (C) 2025 Midnight Foundation\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// You may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { EncryptionSecretKey } from '@midnight-ntwrk/ledger-v7';\nimport { bech32m } from '@scure/base';\nimport * as subsquidScale from '@subsquid/scale-codec';\nexport const mainnet = Symbol('Mainnet');\nconst NetworkId = {\n    toString: (networkId) => {\n        return networkId === mainnet ? 'mainnet' : networkId;\n    },\n};\nexport const BLSScalar = {\n    bytes: 32,\n    modulus: BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'),\n};\nexport const ScaleBigInt = {\n    encode: (data) => {\n        const sink = new subsquidScale.ByteSink();\n        sink.compact(data);\n        return Buffer.from(sink.toBytes());\n    },\n    decode: (repr) => {\n        const src = new subsquidScale.Src(repr);\n        const res = src.compact();\n        src.assertEOF();\n        return BigInt(res);\n    },\n};\nexport const Bech32mSymbol = Symbol('MidnightBech32m');\nexport class MidnightBech32m {\n    static prefix = 'mn';\n    static encode(networkId, item) {\n        return item[Bech32mSymbol].encode(networkId, item);\n    }\n    static validateSegment(segmentName, segment) {\n        const result = /^[A-Za-z1-9-]+$/.test(segment);\n        if (!result) {\n            throw new Error(`Segment ${segmentName}: ${segment} contains disallowed characters. Allowed characters are only numbers, latin letters and a hyphen`);\n        }\n    }\n    static parse(bech32string) {\n        const bech32parsed = bech32m.decodeToBytes(bech32string);\n        const [prefix, type, network = mainnet] = bech32parsed.prefix.split('_');\n        if (prefix != MidnightBech32m.prefix) {\n            throw new Error(`Expected prefix ${MidnightBech32m.prefix}`);\n        }\n        MidnightBech32m.validateSegment('type', type);\n        if (network != mainnet) {\n            MidnightBech32m.validateSegment('network', network);\n        }\n        return new MidnightBech32m(type, network, Buffer.from(bech32parsed.bytes));\n    }\n    type;\n    network;\n    data;\n    constructor(type, network, data) {\n        this.data = data;\n        this.network = network;\n        this.type = type;\n        MidnightBech32m.validateSegment('type', type);\n        if (network != mainnet) {\n            MidnightBech32m.validateSegment('network', network);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    decode(tclass, networkId) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return tclass[Bech32mSymbol].decode(networkId, this);\n    }\n    asString() {\n        const networkSegment = this.network == mainnet ? '' : `_${this.network}`;\n        return bech32m.encode(`${MidnightBech32m.prefix}_${this.type}${networkSegment}`, bech32m.toWords(this.data), false);\n    }\n    toString() {\n        return this.asString();\n    }\n}\nexport class Bech32mCodec {\n    type;\n    dataToBytes;\n    dataFromBytes;\n    constructor(type, dataToBytes, dataFromBytes) {\n        this.dataFromBytes = dataFromBytes;\n        this.dataToBytes = dataToBytes;\n        this.type = type;\n    }\n    encode(networkId, data) {\n        const context = Bech32mCodec.createContext(networkId);\n        return new MidnightBech32m(this.type, context.networkId, this.dataToBytes(data));\n    }\n    decode(networkId, repr) {\n        const context = Bech32mCodec.createContext(networkId);\n        if (repr.type != this.type) {\n            throw new Error(`Expected type ${this.type}, got ${repr.type}`);\n        }\n        if (context.networkId != repr.network) {\n            throw new Error(`Expected ${NetworkId.toString(context.networkId)} address, got ${NetworkId.toString(repr.network)} one`);\n        }\n        return this.dataFromBytes(repr.data);\n    }\n    static createContext(networkId) {\n        if (networkId === 'mainnet') {\n            return { networkId: mainnet };\n        }\n        else {\n            return { networkId };\n        }\n    }\n}\nexport class ShieldedAddress {\n    static codec = new Bech32mCodec('shield-addr', (addr) => Buffer.concat([addr.coinPublicKey.data, addr.encryptionPublicKey.data]), (bytes) => {\n        const coinPublicKey = new ShieldedCoinPublicKey(bytes.subarray(0, ShieldedCoinPublicKey.keyLength));\n        const encryptionPublicKey = new ShieldedEncryptionPublicKey(bytes.subarray(ShieldedCoinPublicKey.keyLength));\n        return new ShieldedAddress(coinPublicKey, encryptionPublicKey);\n    });\n    static [Bech32mSymbol] = ShieldedAddress.codec;\n    [Bech32mSymbol] = ShieldedAddress.codec;\n    coinPublicKey;\n    encryptionPublicKey;\n    constructor(coinPublicKey, encryptionPublicKey) {\n        this.encryptionPublicKey = encryptionPublicKey;\n        this.coinPublicKey = coinPublicKey;\n    }\n    coinPublicKeyString() {\n        return this.coinPublicKey.data.toString('hex');\n    }\n    encryptionPublicKeyString() {\n        return this.encryptionPublicKey.data.toString('hex');\n    }\n    equals(other) {\n        return this.coinPublicKey.equals(other.coinPublicKey) && this.encryptionPublicKey.equals(other.encryptionPublicKey);\n    }\n}\nexport class ShieldedEncryptionSecretKey {\n    static codec = new Bech32mCodec('shield-esk', (esk) => Buffer.from(esk.zswap.yesIKnowTheSecurityImplicationsOfThis_serialize()), (repr) => new ShieldedEncryptionSecretKey(EncryptionSecretKey.deserialize(repr)));\n    // There are some bits in serialization of field elements and elliptic curve points, that are hard to replicate\n    // Thus using zswap implementation directly for serialization purposes\n    zswap;\n    constructor(zswap) {\n        this.zswap = zswap;\n    }\n}\nexport class ShieldedCoinPublicKey {\n    static keyLength = 32;\n    static codec = new Bech32mCodec('shield-cpk', (cpk) => cpk.data, (repr) => new ShieldedCoinPublicKey(repr));\n    static fromHexString(hexString) {\n        return new ShieldedCoinPublicKey(Buffer.from(hexString, 'hex'));\n    }\n    data;\n    constructor(data) {\n        this.data = data;\n        if (data.length != ShieldedCoinPublicKey.keyLength) {\n            throw new Error('Coin public key needs to be 32 bytes long');\n        }\n    }\n    toHexString() {\n        return this.data.toString('hex');\n    }\n    equals(other) {\n        const otherKey = typeof other === 'string' ? ShieldedCoinPublicKey.fromHexString(other) : other;\n        return otherKey.data.equals(this.data);\n    }\n}\nexport class ShieldedEncryptionPublicKey {\n    static keyLength = 32;\n    static codec = new Bech32mCodec('shield-epk', (cpk) => cpk.data, (repr) => new ShieldedEncryptionPublicKey(repr));\n    static fromHexString(hexString) {\n        return new ShieldedEncryptionPublicKey(Buffer.from(hexString, 'hex'));\n    }\n    data;\n    constructor(data) {\n        this.data = data;\n    }\n    toHexString() {\n        return this.data.toString('hex');\n    }\n    equals(other) {\n        const otherKey = typeof other === 'string' ? ShieldedEncryptionPublicKey.fromHexString(other) : other;\n        return otherKey.data.equals(this.data);\n    }\n}\nexport class UnshieldedAddress {\n    data;\n    static keyLength = 32;\n    static codec = new Bech32mCodec('addr', (addr) => addr.data, (repr) => new UnshieldedAddress(repr));\n    static [Bech32mSymbol] = UnshieldedAddress.codec;\n    [Bech32mSymbol] = UnshieldedAddress.codec;\n    constructor(data) {\n        if (data.length != UnshieldedAddress.keyLength) {\n            throw new Error('Unshielded address needs to be 32 bytes long');\n        }\n        this.data = data;\n    }\n    get hexString() {\n        return this.data.toString('hex');\n    }\n    equals(other) {\n        const otherAddress = typeof other === 'string' ? new UnshieldedAddress(Buffer.from(other, 'hex')) : other;\n        return otherAddress.data.equals(this.data);\n    }\n}\nexport class DustAddress {\n    data;\n    static codec = new Bech32mCodec('dust', (daddr) => daddr.serialize(), (repr) => new DustAddress(ScaleBigInt.decode(repr)));\n    static [Bech32mSymbol] = DustAddress.codec;\n    [Bech32mSymbol] = DustAddress.codec;\n    static encodePublicKey = (networkId, publicKey) => {\n        return DustAddress.codec.encode(networkId, new DustAddress(publicKey)).asString();\n    };\n    constructor(data) {\n        if (data >= BLSScalar.modulus) {\n            throw new Error('Dust address is too large');\n        }\n        this.data = data;\n    }\n    serialize() {\n        return ScaleBigInt.encode(this.data);\n    }\n    equals(other) {\n        const otherAddress = typeof other === 'bigint' ? other : other.data;\n        return otherAddress === this.data;\n    }\n}\n"],
  "mappings": "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",
  "names": ["TypeKind", "Src", "ByteSink", "len", "padding", "alphabet"]
}
