import {
  require_buffer
} from "./chunk-7JNOLTLE.js";
import {
  MidnightBech32m,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey
} from "./chunk-KSWR4OFY.js";
import {
  Brand_exports,
  Cause_exports,
  ConfigProvider_exports,
  ConstrainedPlainHex,
  Contract_exports,
  Effect_exports,
  Exit_exports,
  Layer_exports,
  ManagedRuntime_exports,
  Option_exports,
  TypeIdError,
  ZKConfiguration_exports,
  hasProperty,
  layer
} from "./chunk-2HR7EAUP.js";
import {
  __export,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@midnight-ntwrk/platform-js/dist/esm/effect/ContractAddress.js
var ContractAddress_exports = {};
__export(ContractAddress_exports, {
  ContractAddress: () => ContractAddress,
  asBytes: () => asBytes
});
var ContractAddress = Brand_exports.all(Brand_exports.nominal(), ConstrainedPlainHex({ byteLength: "32..=32" }));
var asBytes = (self) => Buffer.from(self, "hex");

// node_modules/@midnight-ntwrk/compact-js/dist/esm/effect/ContractExecutableRuntime.js
var ContractExecutableRuntime_exports = {};
__export(ContractExecutableRuntime_exports, {
  make: () => make
});
var make = (layer2) => ManagedRuntime_exports.make(layer2);

// node_modules/@midnight-ntwrk/compact-js/dist/esm/effect/ZKConfigurationReadError.js
var ZKConfigurationReadError_exports = {};
__export(ZKConfigurationReadError_exports, {
  ZKConfigurationReadError: () => ZKConfigurationReadError,
  isReadError: () => isReadError,
  make: () => make2
});
var TypeId = Symbol.for("compact-js/effect/ZKConfigurationReadError");
var ZKConfigurationReadError = class extends TypeIdError(TypeId, "ZKConfigurationReadError") {
};
var isReadError = (u) => hasProperty(u, TypeId);
var make2 = (contractTag, impureCircuitId, assetType, cause) => new ZKConfigurationReadError({
  contractTag,
  impureCircuitId,
  assetType,
  message: `Failed to read ${assetType.replaceAll("-", " ")} for ${contractTag}#${impureCircuitId}`,
  cause
});

// node_modules/@midnight-ntwrk/platform-js/dist/esm/effect/DomainSeparator.js
var DomainSeparator = Brand_exports.all(Brand_exports.nominal(), ConstrainedPlainHex({ byteLength: "32..=32" }));

// node_modules/@midnight-ntwrk/midnight-js-types/dist/index.mjs
var makeAdaptedReader = (zkConfigProvider) => (compiledContract) => Effect_exports.gen(function* () {
  const getVerifierKey = (impureCircuitId) => Effect_exports.tryPromise({
    try: () => zkConfigProvider.getVerifierKey(impureCircuitId).then((verifierKey) => Option_exports.some(Contract_exports.VerifierKey(verifierKey))),
    catch: (err) => ZKConfigurationReadError_exports.make(compiledContract.tag, impureCircuitId, "verifier-key", err)
  });
  return {
    getVerifierKey,
    getVerifierKeys: (impureCircuitIds) => Effect_exports.forEach(impureCircuitIds, (impureCircuitId) => getVerifierKey(impureCircuitId).pipe(Effect_exports.map((verifierKey) => [impureCircuitId, verifierKey])), { concurrency: "unbounded", discard: false })
  };
});
var makeAdaptedRuntimeLayer = (zkConfigProvider, configMap) => Layer_exports.mergeAll(Layer_exports.succeed(ZKConfiguration_exports.ZKConfiguration, ZKConfiguration_exports.ZKConfiguration.of({
  createReader: makeAdaptedReader(zkConfigProvider)
})), layer).pipe(Layer_exports.provide(Layer_exports.setConfigProvider(ConfigProvider_exports.fromMap(configMap, { pathDelim: "_" }).pipe(ConfigProvider_exports.constantCase))));
var makeContractExecutableRuntime = (zkConfigProvider, options) => {
  let config = [["KEYS_COIN_PUBLIC", options.coinPublicKey]];
  if (options.signingKey) {
    config = config.concat([["KEYS_SIGNING", options.signingKey]]);
  }
  return ContractExecutableRuntime_exports.make(makeAdaptedRuntimeLayer(zkConfigProvider, new Map(config)));
};
var exitResultOrError = (exit) => Exit_exports.match(exit, {
  onSuccess: (a) => a,
  onFailure: (cause) => {
    if (Cause_exports.isFailType(cause))
      throw cause.error;
    throw new Error(`Unexpected error: ${Cause_exports.pretty(cause)}`);
  }
});
var asEffectOption = (obj) => {
  return Option_exports.some(obj);
};
var asContractAddress = (address) => ContractAddress_exports.ContractAddress(address);
var InvalidProtocolSchemeError = class extends Error {
  invalidScheme;
  allowableSchemes;
  /**
   * @param invalidScheme The invalid scheme.
   * @param allowableSchemes The valid schemes that are allowed.
   */
  constructor(invalidScheme, allowableSchemes) {
    super(`Invalid protocol scheme: '${invalidScheme}'. Allowable schemes are one of: ${allowableSchemes.join(",")}`);
    this.invalidScheme = invalidScheme;
    this.allowableSchemes = allowableSchemes;
  }
};
var LogLevel;
(function(LogLevel2) {
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  LogLevel2["FATAL"] = "fatal";
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["TRACE"] = "trace";
})(LogLevel || (LogLevel = {}));
var SegmentFail = "SegmentFail";
var SegmentSuccess = "SegmentSuccess";
var FailEntirely = "FailEntirely";
var FailFallible = "FailFallible";
var SucceedEntirely = "SucceedEntirely";

// node_modules/@midnight-ntwrk/midnight-js-utils/dist/index.mjs
var import_buffer = __toESM(require_buffer(), 1);
function assertDefined(value, message) {
  if (!value) {
    throw new Error(message ?? "Expected value to be defined");
  }
}
function assertUndefined(value, message) {
  if (value) {
    throw new Error(message ?? "Expected value to be null or undefined");
  }
}
var ttlOneHour = () => new Date(Date.now() + 60 * 60 * 1e3);
var HEX_STRING_REGEXP = /^(?<prefix>(0x)?)(?<byteChars>([0-9A-Fa-f]{2})*)(?<incompleteChars>.*)$/;
var parseHex = (source) => {
  const groups = HEX_STRING_REGEXP.exec(source)?.groups;
  return {
    hasPrefix: groups.prefix === "0x",
    byteChars: groups.byteChars,
    incompleteChars: groups.incompleteChars
  };
};
var toHex = (bytes) => import_buffer.Buffer.from(bytes).toString("hex");
var fromHex = (str) => import_buffer.Buffer.from(str, "hex");
var isHex = (source, byteLen) => {
  if (!source || byteLen !== void 0 && byteLen <= 0) {
    return false;
  }
  const parsedHex = parseHex(source);
  const validByteLen = byteLen ? parsedHex.byteChars.length / 2 === byteLen : parsedHex.byteChars.length > 0;
  return validByteLen && !parsedHex.incompleteChars;
};
function assertIsHex(source, byteLen) {
  if (!source) {
    throw new TypeError("Input string must have non-zero length.");
  }
  if (byteLen !== void 0 && byteLen <= 0) {
    throw new Error("Expected byte length must be greater than zero.");
  }
  const parsedHex = parseHex(source);
  if (parsedHex.incompleteChars) {
    if (parsedHex.incompleteChars.length % 2 > 0) {
      throw new TypeError(`The last byte of input string '${source}' is incomplete.`);
    }
    const invalidCharPos = parsedHex.byteChars.length + (parsedHex.hasPrefix ? 2 : 0);
    throw new TypeError(`Invalid hex-digit '${source[invalidCharPos]}' found in input string at index ${invalidCharPos}.`);
  }
  if (!parsedHex.byteChars) {
    throw new TypeError(`Input string '${source}' is not a valid hex-string.`);
  }
  if (byteLen) {
    const actualByteLen = parsedHex.byteChars.length / 2;
    if (byteLen !== actualByteLen) {
      throw new TypeError(`Expected an input string with byte length of ${byteLen}, got ${actualByteLen}.`);
    }
  }
}
var parseCoinPublicKeyToHex = (possibleBech32, zswapNetworkId) => {
  if (isHex(possibleBech32))
    return possibleBech32;
  const parsedBech32 = MidnightBech32m.parse(possibleBech32);
  const decoded = ShieldedCoinPublicKey.codec.decode(zswapNetworkId, parsedBech32);
  return import_buffer.Buffer.from(decoded.data).toString("hex");
};
var parseEncPublicKeyToHex = (possibleBech32, zswapNetworkId) => {
  if (isHex(possibleBech32))
    return possibleBech32;
  const parsedBech32 = MidnightBech32m.parse(possibleBech32);
  const decoded = ShieldedEncryptionPublicKey.codec.decode(zswapNetworkId, parsedBech32);
  return import_buffer.Buffer.from(decoded.data).toString("hex");
};
function assertIsContractAddress(contractAddress) {
  const CONTRACT_ADDRESS_BYTE_LENGTH = 32;
  assertIsHex(contractAddress, CONTRACT_ADDRESS_BYTE_LENGTH);
  const parsedHex = parseHex(contractAddress);
  if (parsedHex.hasPrefix) {
    throw new TypeError(`Unexpected '0x' prefix in contract address '${contractAddress}'`);
  }
}

export {
  ContractAddress,
  makeContractExecutableRuntime,
  exitResultOrError,
  asEffectOption,
  asContractAddress,
  InvalidProtocolSchemeError,
  SegmentFail,
  SegmentSuccess,
  FailEntirely,
  FailFallible,
  SucceedEntirely,
  assertDefined,
  assertUndefined,
  ttlOneHour,
  toHex,
  fromHex,
  parseCoinPublicKeyToHex,
  parseEncPublicKeyToHex,
  assertIsContractAddress
};
//# sourceMappingURL=chunk-XR5POV5A.js.map
