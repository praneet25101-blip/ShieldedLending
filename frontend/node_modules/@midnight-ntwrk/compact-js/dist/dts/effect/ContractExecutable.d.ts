import { type AlignedValue, type ContractState, type Op, type StateValue, type ZswapLocalState } from '@midnight-ntwrk/compact-runtime';
import { MaintenanceUpdate, type Transcript } from '@midnight-ntwrk/ledger-v7';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import type * as ContractAddress from '@midnight-ntwrk/platform-js/effect/ContractAddress';
import * as SigningKey from '@midnight-ntwrk/platform-js/effect/SigningKey';
import { Effect, type Layer, Option } from 'effect';
import { type Pipeable } from 'effect/Pipeable';
import { type CompiledContract } from './CompiledContract.js';
import * as Contract from './Contract.js';
import * as ContractConfigurationError from './ContractConfigurationError.js';
import * as ContractRuntimeError from './ContractRuntimeError.js';
import { ZKConfiguration } from './ZKConfiguration.js';
import { type ZKConfigurationReadError } from './ZKConfigurationReadError.js';
/**
 * An executable form of a Compact compiled contract.
 */
export interface ContractExecutable<in out C extends Contract.Contract<PS>, PS, out E = never, out R = never> extends Pipeable {
    readonly compiledContract: CompiledContract<C, PS>;
    /**
     * Creates and initializes a new instance of the contract.
     *
     * @param initialPrivateState The initial private state to apply when initializing the new contract instance.
     * @param args The arguments to supply the contract constructor.
     * @returns A {@link ContractExecutable.DeployResult} describing the result of initializing a new contract
     * instance.
     */
    initialize(initialPrivateState: PS, ...args: Contract.Contract.InitializeParameters<C>): Effect.Effect<ContractExecutable.DeployResult<PS>, E, R>;
    /**
     * Invokes a circuit on deployed instance of the contract.
     *
     * @param impureCircuitId The circuit to be invoked.
     * @param circuitContext Execution context for `impureCircuitId` including its current onchain and private
     * states.
     * @param args The arguments to supply the circuit.
     * @returns A {@link ContractExecutable.CallResult} describing the result of invoking `impureCircuitId`.
     */
    circuit<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(impureCircuitId: K, circuitContext: ContractExecutable.CircuitContext<PS>, ...args: Contract.Contract.CircuitParameters<C, K>): Effect.Effect<ContractExecutable.CallResult<C, PS, K>, E, R>;
    /**
     * Retrieves the impure circuits available as part of the underlying contract.
     *
     * @returns An array of {@link Contract.ImpureCircuitId} describing the available impure circuits.
     */
    getImpureCircuitIds(): Contract.ImpureCircuitId<C>[];
    /**
     * Applies a new Contract Maintenance Authority (CMA) to a deployed instance of the contract.
     *
     * @param newSigningKey The signing key that will replace the current that is associated with the
     * deployed contract. If `Option.none` then a new singing key is sampled and used instead.
     * @param contractContext Execution context for the maintenance operation.
     * @returns A {@link ContractExecutable.MaintenanceResult} describing the result of the maintenance update.
     *
     * @remarks
     * The current signing key will be taken from the {@link Configuration.Keys} that is part of the executable
     * context, and used to sign the maintenance operation.
     */
    replaceContractMaintenanceAuthority(newSigningKey: Option.Option<SigningKey.SigningKey>, contractContext: ContractExecutable.ContractContext): Effect.Effect<ContractExecutable.MaintenanceResult, E, R>;
    /**
     * Removes the current verifier key for an operation on a deployed instance of the contract.
     *
     * @param impureCircuitId The circuit to be removed from the deployed contract.
     * @param contractContext Execution context for the maintenance operation.
     * @returns A {@link ContractExecutable.MaintenanceResult} describing the result of the maintenance update.
     */
    removeContractOperation<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(impureCircuitId: K, contractContext: ContractExecutable.ContractContext): Effect.Effect<ContractExecutable.MaintenanceResult, E, R>;
    /**
     * Adds or replaces a verifier key associated with a circuit on a deployed contract.
     *
     * @param impureCircuitId The circuit to add or replace on the deployed contract.
     * @param verifierKey The verifier key to apply to `impureCircuitId`.
     * @param contractContext Execution context for the maintenance operation.
     * @returns A {@link ContractExecutable.MaintenanceResult} describing the result of the maintenance update.
     */
    addOrReplaceContractOperation<K extends Contract.ImpureCircuitId<C> = Contract.ImpureCircuitId<C>>(impureCircuitId: K, verifierKey: Contract.VerifierKey, contractContext: ContractExecutable.ContractContext): Effect.Effect<ContractExecutable.MaintenanceResult, E, R>;
}
export declare namespace ContractExecutable {
    /**
     * The services required as context for executing contracts.
     */
    type Context = ZKConfiguration | Configuration.Keys | Configuration.Network;
    type ContractContext = {
        readonly address: ContractAddress.ContractAddress;
        readonly contractState: ContractState;
    };
    type CircuitContext<PS> = ContractContext & {
        readonly privateState: PS;
        readonly zswapLocalState?: ZswapLocalState;
    };
    type DeployResultPublic = {
        readonly contractState: ContractState;
    };
    type DeployResultPrivate<PS> = {
        readonly signingKey: SigningKey.SigningKey;
        readonly privateState: PS;
        readonly zswapLocalState: ZswapLocalState;
    };
    type DeployResult<PS> = {
        readonly public: DeployResultPublic;
        readonly private: DeployResultPrivate<PS>;
    };
    type PartitionedTranscript = [Transcript<AlignedValue> | undefined, Transcript<AlignedValue> | undefined];
    type CallResultPublic = {
        readonly contractState: StateValue;
        readonly publicTranscript: Op<AlignedValue>[];
        readonly partitionedTranscript: PartitionedTranscript;
    };
    type CallResultPrivate<C extends Contract.Contract<PS>, PS, K extends Contract.ImpureCircuitId<C>> = {
        readonly input: AlignedValue;
        readonly output: AlignedValue;
        readonly privateTranscriptOutputs: AlignedValue[];
        readonly result: Contract.Contract.CircuitReturnType<C, K>;
        readonly privateState: PS;
        readonly zswapLocalState: ZswapLocalState;
    };
    type CallResult<C extends Contract.Contract<PS>, PS, K extends Contract.ImpureCircuitId<C>> = {
        readonly public: CallResultPublic;
        readonly private: CallResultPrivate<C, PS, K>;
    };
    type MaintenanceResultPublic = {
        readonly maintenanceUpdate: MaintenanceUpdate;
    };
    type MaintenanceResultPrivate = {
        readonly signingKey: SigningKey.SigningKey;
    };
    type MaintenanceResult = {
        readonly public: MaintenanceResultPublic;
        readonly private: MaintenanceResultPrivate;
    };
}
/**
 * An error occurred while executing a constructor, or a circuit, of an executable contract.
 *`
 * @category errors
 */
export type ContractExecutionError = ContractRuntimeError.ContractRuntimeError | ContractConfigurationError.ContractConfigurationError | ZKConfigurationReadError;
/**
 * Takes a Compact compiled contract, and makes it executable.
 *
 * @param compiledContract A {@link CompiledContract}
 * @returns A {@link ContractExecutable} for `compiledContract`.
 *
 * @category constructors
 */
export declare const make: <C extends Contract.Contract<PS>, PS>(compiledContract: CompiledContract<C, PS, never>) => ContractExecutable<C, PS, ContractExecutionError, ContractExecutable.Context>;
/**
 * Provides a layer to the executable contract.
 *
 * @category combinators
 */
export declare const provide: {
    /**
     * @param layer The layer to provide.
     * @returns A function that receives the {@link ContractExecutable} that `layer` should be provided to.
     */
    <LA, LE, LR>(layer: Layer.Layer<LA, LE, LR>): <C extends Contract.Contract<PS>, PS, E, R>(self: ContractExecutable<C, PS, E, R>) => ContractExecutable<C, PS, E | LE, LR | Exclude<R, LA>>;
    /**
     * @param self The {@link ContractExecutable} that `layer` should be provided with.
     * @param layer The layer to provide.
     */
    <C extends Contract.Contract<PS>, PS, E, R, LA, LE, LR>(self: ContractExecutable<C, PS, E, R>, layer: Layer.Layer<LA, LE, LR>): ContractExecutable<C, PS, E | LE, LR | Exclude<R, LA>>;
};
//# sourceMappingURL=ContractExecutable.d.ts.map