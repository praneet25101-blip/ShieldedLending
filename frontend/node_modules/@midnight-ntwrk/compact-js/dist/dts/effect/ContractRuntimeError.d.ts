declare const TypeId: unique symbol;
type TypeId = typeof TypeId;
declare const ContractRuntimeError_base: new <A extends Record<string, any>>(args: import("effect/Types").Simplify<A>) => import("effect/Cause").YieldableError & Record<typeof TypeId, typeof TypeId> & {
    readonly _tag: "ContractRuntimeError";
} & Readonly<A>;
/**
 * A runtime error occurred while executing a constructor, or a circuit, of an executable contract.
 *
 * @category errors
 */
export declare class ContractRuntimeError extends ContractRuntimeError_base<{
    /** A displayable message. */
    readonly message: string;
    /** Indicates a more specific cause of the error. */
    readonly cause?: unknown;
}> {
}
/**
 * Determines if a value is a contract runtime error.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link ContractRuntimeError}; `false` otherwise.
 *
 * @category guards
 */
export declare const isRuntimeError: (u: unknown) => u is ContractRuntimeError;
/**
 * Creates a new {@link ContractRuntimeError}.
 *
 * @category constructors
 */
export declare const make: (message: string, cause?: unknown) => ContractRuntimeError;
export {};
//# sourceMappingURL=ContractRuntimeError.d.ts.map