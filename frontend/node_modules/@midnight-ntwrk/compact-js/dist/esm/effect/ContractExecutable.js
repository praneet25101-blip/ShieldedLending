/*
 * This file is part of midnight-sdk.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CompactError, ContractMaintenanceAuthority, createCircuitContext, createConstructorContext, decodeZswapLocalState, emptyZswapLocalState, encodeZswapLocalState, sampleSigningKey, signatureVerifyingKey } from '@midnight-ntwrk/compact-runtime';
import { ChargedState as LedgerChargedState, ContractMaintenanceAuthority as LedgerContractMaintenanceAuthority, ContractOperationVersion, ContractOperationVersionedVerifierKey, LedgerParameters, MaintenanceUpdate, partitionTranscripts, PreTranscript, QueryContext as LedgerQueryContext, ReplaceAuthority, signData, StateValue as LedgerStateValue, VerifierKeyInsert, VerifierKeyRemove } from '@midnight-ntwrk/ledger-v7';
import * as CoinPublicKey from '@midnight-ntwrk/platform-js/effect/CoinPublicKey';
import * as Configuration from '@midnight-ntwrk/platform-js/effect/Configuration';
import * as SigningKey from '@midnight-ntwrk/platform-js/effect/SigningKey';
import { Effect, Either, Option } from 'effect';
import { dual, identity } from 'effect/Function';
import { pipeArguments } from 'effect/Pipeable';
import * as Contract from './Contract.js';
import * as ContractConfigurationError from './ContractConfigurationError.js';
import * as ContractRuntimeError from './ContractRuntimeError.js';
import * as CompactContextInternal from './internal/compactContext.js';
import { ZKConfiguration } from './ZKConfiguration.js';
const DEFAULT_CMA_THRESHOLD = 1;
const DEFAULT_SIGNATURE_INDEX = 0n;
const asLedgerQueryContext = (queryContext) => {
    const stateValue = LedgerStateValue.decode(queryContext.state.state.encode());
    const ledgerQueryContext = new LedgerQueryContext(new LedgerChargedState(stateValue), queryContext.address);
    // The above method of converting to ledger query context only retains the state. So, we have to set the settable properties manually
    ledgerQueryContext.block = queryContext.block;
    ledgerQueryContext.effects = queryContext.effects;
    return ledgerQueryContext;
};
const partitionTranscript = (txContext, finalTxContext, publicTranscript) => {
    const partitionedTranscripts = partitionTranscripts([
        new PreTranscript(Array.from(finalTxContext.comIndices).reduce((queryContext, entry) => queryContext.insertCommitment(...entry), asLedgerQueryContext(txContext)), publicTranscript)
    ], LedgerParameters.initialParameters());
    return partitionedTranscripts.length === 1
        ? Either.right(partitionedTranscripts[0])
        : Either.left(new Error(`Expected one transcript partition pair, received: ${partitionedTranscripts.length}`));
};
class ContractExecutableImpl {
    compiledContract;
    transform;
    constructor(compiledContract, transform = identity) {
        this.compiledContract = compiledContract;
        this.transform = transform;
    }
    pipe() {
        return pipeArguments(this, arguments); // eslint-disable-line prefer-rest-params
    }
    initialize(initialPrivateState, ...args) {
        return Effect.all({
            zkConfigReader: ZKConfiguration.pipe(Effect.andThen((zkConfig) => zkConfig.createReader(this.compiledContract))),
            keyConfig: Configuration.Keys,
            contract: this.createContract()
        }).pipe(Effect.flatMap(({ zkConfigReader, keyConfig, contract }) => Effect.try({
            try: () => {
                const { currentContractState, currentPrivateState, currentZswapLocalState } = contract.initialState(createConstructorContext(initialPrivateState, CoinPublicKey.asHex(keyConfig.coinPublicKey)), ...args);
                return {
                    contractState: currentContractState,
                    privateState: currentPrivateState,
                    zswapLocalState: decodeZswapLocalState(currentZswapLocalState)
                };
            },
            catch: (err) => err instanceof CompactError
                ? ContractRuntimeError.make('Failed to initialize contract', err)
                : ContractConfigurationError.make('Failed to configure constructor context with coin public key', undefined, err)
        }).pipe(Effect.flatMap(({ contractState, privateState, zswapLocalState }) => Effect.gen(this, function* () {
            // Add the verifier keys.
            const verifierKeys = yield* zkConfigReader.getVerifierKeys(Contract.getImpureCircuitIds(contract));
            for (const [impureCircuitId, verifierKey] of verifierKeys) {
                // If there is no verifier key for this circuit, skip it. It's an impure circuit that likely
                // interacts only with witnesses.
                if (Option.isNone(verifierKey)) {
                    continue;
                }
                const operation = contractState.operation(impureCircuitId);
                if (!operation) {
                    return yield* ContractConfigurationError.make(`Circuit '${impureCircuitId}' is undefined for the given contract state`, contractState);
                }
                try {
                    operation.verifierKey = verifierKey.value;
                    contractState.setOperation(impureCircuitId, operation);
                }
                catch (err) {
                    return yield* ContractConfigurationError.make(`Failed to configure verifier key for circuit '${impureCircuitId}' for the given contract state`, contractState, err);
                }
            }
            const [cma, signingKey] = yield* this.createMaintenanceAuthority(keyConfig.getSigningKey());
            contractState.maintenanceAuthority = cma;
            return {
                public: {
                    contractState
                },
                private: {
                    signingKey,
                    privateState,
                    zswapLocalState
                }
            };
        })))), this.transform);
    }
    circuit(impureCircuitId, circuitContext, ...args) {
        return Effect.all({
            keyConfig: Configuration.Keys,
            contract: this.createContract()
        }).pipe(Effect.flatMap(({ keyConfig, contract }) => Effect.try({
            try: () => {
                const circuit = contract.impureCircuits[impureCircuitId];
                if (!circuit) {
                    throw new Error(`Circuit ${this.compiledContract.tag}#${impureCircuitId} could not be found.`);
                }
                const zswapLocalState = circuitContext.zswapLocalState
                    ? encodeZswapLocalState(circuitContext.zswapLocalState)
                    : emptyZswapLocalState(CoinPublicKey.asHex(keyConfig.coinPublicKey));
                const runtimeContext = createCircuitContext(circuitContext.address, zswapLocalState, circuitContext.contractState, circuitContext.privateState);
                const initialTxContext = runtimeContext.currentQueryContext;
                return {
                    ...circuit(runtimeContext, ...args),
                    initialTxContext
                };
            },
            catch: identity
        }).pipe(Effect.flatMap(({ initialTxContext, result, context, proofData }) => Effect.gen(function* () {
            return {
                public: {
                    contractState: context.currentQueryContext.state.state,
                    publicTranscript: proofData.publicTranscript,
                    partitionedTranscript: yield* partitionTranscript(initialTxContext, context.currentQueryContext, proofData.publicTranscript)
                },
                private: {
                    result,
                    input: proofData.input,
                    output: proofData.output,
                    privateTranscriptOutputs: proofData.privateTranscriptOutputs,
                    privateState: context.currentPrivateState,
                    zswapLocalState: decodeZswapLocalState(context.currentZswapLocalState)
                }
            };
        })), Effect.mapError((err) => ContractRuntimeError.make(`Error executing circuit '${impureCircuitId}'`, err)))), this.transform);
    }
    getImpureCircuitIds() {
        return Contract.getImpureCircuitIds(Effect.runSync(this.createContract()));
    }
    replaceContractMaintenanceAuthority(newSigningKey, contractContext) {
        return Effect.all({
            keyConfig: Configuration.Keys
        }).pipe(Effect.flatMap(({ keyConfig }) => Effect.gen(this, function* () {
            const { contractState } = contractContext;
            const [cma, signingKey] = yield* this.createMaintenanceAuthority(newSigningKey, contractState);
            const ledger_cma = LedgerContractMaintenanceAuthority.deserialize(cma.serialize());
            const update = yield* this.createSignedMaintenanceUpdate(() => {
                return Either.right([
                    new ReplaceAuthority(ledger_cma)
                ]);
            }, keyConfig, contractContext);
            return {
                ...update,
                private: {
                    ...update.private,
                    signingKey // We need to include the new signing key in the result (rather than the current).
                }
            };
        })), this.transform);
    }
    removeContractOperation(impureCircuitId, contractContext) {
        return Effect.all({
            keyConfig: Configuration.Keys
        }).pipe(Effect.flatMap(({ keyConfig }) => Effect.gen(this, function* () {
            return yield* this.createSignedMaintenanceUpdate(() => {
                return Either.right([
                    new VerifierKeyRemove(impureCircuitId, new ContractOperationVersion('v3'))
                ]);
            }, keyConfig, contractContext);
        })), this.transform);
    }
    addOrReplaceContractOperation(impureCircuitId, verifierKey, contractContext) {
        return Effect.all({
            keyConfig: Configuration.Keys
        }).pipe(Effect.flatMap(({ keyConfig }) => Effect.gen(this, function* () {
            return yield* this.createSignedMaintenanceUpdate(() => {
                return Either.right([
                    new VerifierKeyInsert(impureCircuitId, new ContractOperationVersionedVerifierKey('v3', verifierKey))
                ]);
            }, keyConfig, contractContext);
        })), this.transform);
    }
    createSignedMaintenanceUpdate(createUpdateFn, keyConfig, contractContext) {
        const { address, contractState } = contractContext;
        const currentSigningKey = keyConfig.getSigningKey();
        if (Option.isNone(currentSigningKey)) {
            return Either.left(ContractConfigurationError.make('Signing key required to authorize contract maintenance update', contractState));
        }
        const update = createUpdateFn();
        if (Either.isLeft(update))
            return Either.left(update.left);
        const maintenanceUpdate = new MaintenanceUpdate(address, Either.getOrThrow(update), contractState.maintenanceAuthority.counter);
        return Either.right({
            public: {
                maintenanceUpdate: maintenanceUpdate.addSignature(DEFAULT_SIGNATURE_INDEX, signData(Option.getOrThrow(currentSigningKey), maintenanceUpdate.dataToSign))
            },
            private: {
                signingKey: Option.getOrThrow(currentSigningKey)
            }
        });
    }
    createMaintenanceAuthority(key, contractState) {
        const signingKey = Option.match(key, {
            onSome: identity,
            onNone: () => SigningKey.SigningKey(sampleSigningKey())
        });
        try {
            return Either.right([
                new ContractMaintenanceAuthority([signatureVerifyingKey(signingKey)], DEFAULT_CMA_THRESHOLD, contractState ? contractState.maintenanceAuthority.counter + 1n : 0n),
                signingKey
            ]);
        }
        catch (err) {
            return Either.left(ContractConfigurationError.make(`Failed to create a signature verifying key for signing key '${signingKey}'`, contractState, err));
        }
    }
    createContract() {
        return (this.contract ??= CompactContextInternal.createContract(this.compiledContract).pipe(Effect.mapError((err) => ContractRuntimeError.make(String(err), err)), Effect.cached, Effect.runSync));
    }
    contract; // Backing property for `createContract`.
}
/**
 * Takes a Compact compiled contract, and makes it executable.
 *
 * @param compiledContract A {@link CompiledContract}
 * @returns A {@link ContractExecutable} for `compiledContract`.
 *
 * @category constructors
 */
export const make = (compiledContract) => new ContractExecutableImpl(compiledContract);
/**
 * Provides a layer to the executable contract.
 *
 * @category combinators
 */
export const provide = dual(2, (self, layer) => new ContractExecutableImpl(self.compiledContract, (e) => Effect.provide(e, layer)));
//# sourceMappingURL=ContractExecutable.js.map