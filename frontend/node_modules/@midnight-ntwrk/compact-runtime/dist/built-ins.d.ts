import * as ocrt from '@midnight-ntwrk/onchain-runtime-v2';
import { CompactType, NativePoint } from './compact-types.js';
/**
 * Field addition
 * returns the result of adding x and y, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
export declare function addField(x: bigint, y: bigint): bigint;
/**
 * Field subtraction
 * returns the result of subtracting y from x, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
export declare function subField(x: bigint, y: bigint): bigint;
/**
 * Field multiplication
 * returns the result of multipying x and y, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
export declare function mulField(x: bigint, y: bigint): bigint;
/**
 * The Compact builtin `transient_hash` function
 *
 * This function is a circuit-efficient compression function from arbitrary
 * data to field elements, which is not guaranteed to persist between upgrades.
 * It should not be used to derive state data, but can be used for consistency
 * checks.
 */
export declare function transientHash<A>(rtType: CompactType<A>, value: A): bigint;
/**
 * The Compact builtin `transient_commit` function
 *
 * This function is a circuit-efficient commitment function from arbitrary
 * values representable in Compact, and a field element commitment opening, to
 * field elements, which is not guaranteed to persist between
 * upgrades. It should not be used to derive state data, but can be used for
 * consistency checks.
 *
 * @throws If `opening` is out of range for field elements
 */
export declare function transientCommit<A>(rtType: CompactType<A>, value: A, opening: bigint): bigint;
/**
 * The Compact builtin `persistent_hash` function
 *
 * This function is a non-circuit-optimised hash function for mostly arbitrary
 * data. It is guaranteed to persist between upgrades, with the exception of
 * devnet. It *should* be used to derive state data, and not for consistency
 * checks where avoidable.
 *
 * Note that data containing `Opaque` elements *may* throw runtime errors, and
 * cannot be relied upon as a consistent representation.
 *
 * @throws If `rtType` encodes a type containing Compact 'Opaque' types
 */
export declare function persistentHash<A>(rtType: CompactType<A>, value: A): Uint8Array;
/**
 * The Compact builtin `persistent_commit` function
 *
 * This function is a non-circuit-optimised commitment function from arbitrary
 * values representable in Compact, and a 256-bit bytestring opening, to a
 * 256-bit bytestring. It is guaranteed to persist between upgrades. It
 * *should* be used to derive state data, and not for consistency checks where
 * avoidable.
 *
 * Note that data containing `Opaque` elements *may* throw runtime errors, and
 * cannot be relied upon as a consistent representation.
 *
 * @throws If `rtType` encodes a type containing Compact 'Opaque' types, or
 * `opening` is not 32 bytes long
 */
export declare function persistentCommit<A>(rtType: CompactType<A>, value: A, opening: Uint8Array): Uint8Array;
/**
 * The Compact builtin `degrade_to_transient` function
 *
 * This function "degrades" the output of a {@link persistentHash} or
 * {@link persistentCommit} to a field element, which can then be used in
 * {@link transientHash} or {@link transientCommit}.
 *
 * @throws If `x` is not 32 bytes long
 */
export declare function degradeToTransient(x: Uint8Array): bigint;
/**
 * The Compact builtin `upgrade_from_transient` function
 *
 * This function "upgrades" the output of a {@link transientHash} or
 * {@link transientCommit} to 256-bit byte string, which can then be used in
 * {@link persistentHash} or {@link persistentCommit}.
 *
 * @throws If `x` is not a valid field element
 */
export declare function upgradeFromTransient(x: bigint): Uint8Array;
/**
 * The Compact builtin `hash_to_curve` function
 *
 * This function maps arbitrary values representable in Compact to elliptic
 * curve points in the proof system's embedded curve.
 *
 * Outputs are guaranteed to have unknown discrete logarithm with respect to
 * the group base, and any other output, but are not guaranteed to be unique (a
 * given input can be proven correct for multiple outputs).
 *
 * Inputs of different types may have the same output, if they have the same
 * field-aligned binary representation.
 */
export declare function hashToCurve<A>(rtType: CompactType<A>, x: A): NativePoint;
/**
 * The Compact builtin `ec_add` function
 *
 * This function add two elliptic curve points (in multiplicative notation)
 */
export declare function ecAdd(a: NativePoint, b: NativePoint): NativePoint;
/**
 * The Compact builtin `ec_mul` function
 *
 * This function multiplies an elliptic curve point by a scalar (in
 * multiplicative notation)
 */
export declare function ecMul(a: NativePoint, b: bigint): NativePoint;
/**
 * The Compact builtin `ec_mul_generator` function
 *
 * This function multiplies the primary group generator of the embedded curve
 * by a scalar (in multiplicative notation)
 */
export declare function ecMulGenerator(b: bigint): NativePoint;
/**
 * Concatenates multiple {@link AlignedValue}s
 * @internal
 */
export declare function alignedConcat(...values: ocrt.AlignedValue[]): ocrt.AlignedValue;
