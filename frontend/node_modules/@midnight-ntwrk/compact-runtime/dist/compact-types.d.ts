import * as ocrt from '@midnight-ntwrk/onchain-runtime-v2';
/**
 * A runtime representation of a type in Compact
 */
export interface CompactType<A> {
    /**
     * The field-aligned binary alignment of this type.
     */
    alignment(): ocrt.Alignment;
    /**
     * Converts this type's TypeScript representation to its field-aligned binary
     * representation
     */
    toValue(value: A): ocrt.Value;
    /**
     * Converts this type's field-aligned binary representation to its TypeScript
     * representation destructively; (partially) consuming the input, and
     * ignoring superflous data for chaining.
     */
    fromValue(value: ocrt.Value): A;
}
/**
 * A point in the embedded elliptic curve. TypeScript representation of the
 * Compact type of the same name
 */
export interface NativePoint {
    readonly x: bigint;
    readonly y: bigint;
}
/**
 * The hash value of a Merkle tree. TypeScript representation of the Compact
 * type of the same name
 */
export interface MerkleTreeDigest {
    readonly field: bigint;
}
/**
 * An entry in a Merkle path. TypeScript representation of the Compact type of
 * the same name.
 */
export interface MerkleTreePathEntry {
    readonly sibling: MerkleTreeDigest;
    readonly goes_left: boolean;
}
/**
 * A path demonstrating inclusion in a Merkle tree. TypeScript representation
 * of the Compact type of the same name.
 */
export interface MerkleTreePath<A> {
    readonly leaf: A;
    readonly path: MerkleTreePathEntry[];
}
/**
 * The recipient of a coin produced by a circuit.
 */
export interface Recipient {
    /**
     * Whether the recipient is a user or a contract.
     */
    readonly is_left: boolean;
    /**
     * The recipient's public key, if the recipient is a user.
     */
    readonly left: ocrt.CoinPublicKey;
    /**
     * The recipient's contract address, if the recipient is a contract.
     */
    readonly right: ocrt.ContractAddress;
}
/**
 * Runtime type of {@link NativePoint}
 */
export declare const CompactTypeNativePoint: CompactType<NativePoint>;
/**
 * Runtime type of {@link MerkleTreeDigest}
 */
export declare const CompactTypeMerkleTreeDigest: CompactType<MerkleTreeDigest>;
/**
 * Runtime type of {@link MerkleTreePathEntry}
 */
export declare const CompactTypeMerkleTreePathEntry: CompactType<MerkleTreePathEntry>;
/**
 * Runtime type of {@link MerkleTreePath}
 */
export declare class CompactTypeMerkleTreePath<A> implements CompactType<MerkleTreePath<A>> {
    readonly leaf: CompactType<A>;
    readonly path: CompactTypeVector<MerkleTreePathEntry>;
    constructor(n: number, leaf: CompactType<A>);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): MerkleTreePath<A>;
    toValue(value: MerkleTreePath<A>): ocrt.Value;
}
/**
 * Runtime type of the builtin `Field` type
 */
export declare const CompactTypeField: CompactType<bigint>;
/**
 * Runtime type of an enum with a given number of entries
 */
export declare class CompactTypeEnum implements CompactType<number> {
    readonly maxValue: number;
    readonly length: number;
    constructor(maxValue: number, length: number);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): number;
    toValue(value: number): ocrt.Value;
}
/**
 * Runtime type of the builtin `Unsigned Integer` types
 */
export declare class CompactTypeUnsignedInteger implements CompactType<bigint> {
    readonly maxValue: bigint;
    readonly length: number;
    constructor(maxValue: bigint, length: number);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): bigint;
    toValue(value: bigint): ocrt.Value;
}
/**
 * Runtime type of the builtin `Vector` types
 */
export declare class CompactTypeVector<A> implements CompactType<A[]> {
    readonly length: number;
    readonly type: CompactType<A>;
    constructor(length: number, type: CompactType<A>);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): A[];
    toValue(value: A[]): ocrt.Value;
}
/**
 * Runtime type of the builtin `Boolean` type
 */
export declare const CompactTypeBoolean: CompactType<boolean>;
/**
 * Runtime type of the builtin `Bytes` types
 */
export declare class CompactTypeBytes implements CompactType<Uint8Array> {
    readonly length: number;
    constructor(length: number);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): Uint8Array;
    toValue(value: Uint8Array): ocrt.Value;
}
/**
 * Runtime type of `Opaque["Uint8Array"]`
 */
export declare const CompactTypeOpaqueUint8Array: CompactType<Uint8Array>;
/**
 * Runtime type of `Opaque["string"]`
 */
export declare const CompactTypeOpaqueString: CompactType<string>;
/**
 * The following are type descriptors used to implement {@link createCoinCommitment}. They are not intended for direct
 * consumption.
 */
export declare const Bytes32Descriptor: CompactTypeBytes;
export declare const MaxUint8Descriptor: CompactTypeUnsignedInteger;
export declare const ShieldedCoinInfoDescriptor: {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): {
        nonce: Uint8Array;
        color: Uint8Array;
        value: bigint;
    };
    toValue(value: {
        nonce: Uint8Array;
        color: Uint8Array;
        value: bigint;
    }): ocrt.Value;
};
export declare const ZswapCoinPublicKeyDescriptor: {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): {
        bytes: Uint8Array;
    };
    toValue(value: {
        bytes: Uint8Array;
    }): ocrt.Value;
};
export declare const ContractAddressDescriptor: {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): {
        bytes: Uint8Array;
    };
    toValue(value: {
        bytes: Uint8Array;
    }): ocrt.Value;
};
export declare const ShieldedCoinRecipientDescriptor: {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): {
        is_left: boolean;
        left: {
            bytes: Uint8Array;
        };
        right: {
            bytes: Uint8Array;
        };
    };
    toValue(value: {
        is_left: boolean;
        left: {
            bytes: Uint8Array;
        };
        right: {
            bytes: Uint8Array;
        };
    }): ocrt.Value;
};
