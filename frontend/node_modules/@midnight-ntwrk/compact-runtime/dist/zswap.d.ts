import * as ocrt from '@midnight-ntwrk/onchain-runtime-v2';
import { CircuitContext } from './circuit-context.js';
import { Recipient } from './compact-types.js';
/**
 * Tracks the coins consumed and produced throughout circuit execution.
 */
export interface ZswapLocalState {
    /**
     * The Zswap coin public key of the user executing the circuit.
     */
    coinPublicKey: ocrt.CoinPublicKey;
    /**
     * The Merkle tree index of the next coin produced.
     */
    currentIndex: bigint;
    /**
     * The coins consumed as inputs to the circuit.
     */
    inputs: ocrt.QualifiedShieldedCoinInfo[];
    /**
     * The coins produced as outputs from the circuit.
     */
    outputs: {
        coinInfo: ocrt.ShieldedCoinInfo;
        recipient: Recipient;
    }[];
}
/**
 * A {@link CoinPublicKey} encoded as a byte string. This representation is used internally by the contract executable.
 */
export interface EncodedCoinPublicKey {
    /**
     * The coin public key's bytes.
     */
    readonly bytes: Uint8Array;
}
/**
 * A {@link ContractAddress} encoded as a byte string. This representation is used internally by the contract executable.
 */
export interface EncodedContractAddress {
    /**
     * The contract address's bytes.
     */
    readonly bytes: Uint8Array;
}
/**
 * A {@link ShieldedCoinInfo} with its fields encoded as byte strings. This representation is used internally by
 * the contract executable.
 */
export interface EncodedShieldedCoinInfo {
    /**
     * The coin's randomness, preventing it from colliding with other coins.
     */
    readonly nonce: Uint8Array;
    /**
     * The coin's type, identifying the currency it represents.
     */
    readonly color: Uint8Array;
    /**
     * The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer.
     */
    readonly value: bigint;
}
/**
 * A {@link QualifiedCoinInfo} with its fields encoded as byte strings. This representation is used internally by
 * the contract executable.
 */
export interface EncodedQualifiedShieldedCoinInfo extends EncodedShieldedCoinInfo {
    /**
     * The coin's location in the chain's Merkle tree of coin commitments. Bounded to be a non-negative 64-bit integer.
     */
    readonly mt_index: bigint;
}
/**
 * A {@link Recipient} with its fields encoded as byte strings. This representation is used internally by the contract executable.
 */
export interface EncodedRecipient {
    /**
     * Whether the recipient is a user or a contract.
     */
    readonly is_left: boolean;
    /**
     * The recipient's public key, if the recipient is a user.
     */
    readonly left: EncodedCoinPublicKey;
    /**
     * The recipient's contract address, if the recipient is a contract.
     */
    readonly right: EncodedContractAddress;
}
/**
 * Tracks the coins consumed and produced throughout circuit execution.
 */
export interface EncodedZswapLocalState {
    /**
     * The Zswap coin public key of the user executing the circuit.
     */
    coinPublicKey: EncodedCoinPublicKey;
    /**
     * The Merkle tree index of the next coin produced.
     */
    currentIndex: bigint;
    /**
     * The coins consumed as inputs to the circuit.
     */
    inputs: EncodedQualifiedShieldedCoinInfo[];
    /**
     * The coins produced as outputs from the circuit.
     */
    outputs: {
        coinInfo: EncodedShieldedCoinInfo;
        recipient: EncodedRecipient;
    }[];
}
/**
 * Constructs a new {@link EncodedZswapLocalState} with the given coin public key. The result can be used to create a
 * {@link ConstructorContext}.
 *
 * @param coinPublicKey The Zswap coin public key of the user executing the circuit.
 */
export declare const emptyZswapLocalState: (coinPublicKey: ocrt.CoinPublicKey | EncodedCoinPublicKey) => EncodedZswapLocalState;
/**
 * Converts an {@link Recipient} to an {@link EncodedRecipient}. Useful for testing.
 */
export declare const encodeRecipient: ({ is_left, left, right }: Recipient) => EncodedRecipient;
/**
 * Converts an {@link EncodedRecipient} to a {@link Recipient}.
 */
export declare const decodeRecipient: ({ is_left, left, right }: EncodedRecipient) => Recipient;
/**
 * Converts a {@link ZswapLocalState} to an {@link EncodedZswapLocalState}. Useful for testing.
 *
 * @param state The decoded Zswap local state.
 */
export declare const encodeZswapLocalState: (state: ZswapLocalState) => EncodedZswapLocalState;
/**
 * Converts an {@link EncodedZswapLocalState} to a {@link ZswapLocalState}. Used when we need to use data from contract
 * execution to construct transactions.
 *
 * @param state The encoded Zswap local state.
 */
export declare const decodeZswapLocalState: (state: EncodedZswapLocalState) => ZswapLocalState;
/**
 * Adds a coin to the list of inputs consumed by the circuit.
 *
 * @param circuitContext The current circuit context.
 * @param qualifiedShieldedCoinInfo The input to consume.
 */
export declare function createZswapInput(circuitContext: CircuitContext, qualifiedShieldedCoinInfo: EncodedQualifiedShieldedCoinInfo): [];
/**
 * Adds a coin to the list of outputs produced by the circuit.
 *
 * @param circuitContext The current circuit context.
 * @param coinInfo The coin to produce.
 * @param recipient The coin recipient - either a coin public key representing an end user or a contract address
 *                  representing a contract.
 */
export declare function createZswapOutput(circuitContext: CircuitContext<unknown>, coinInfo: EncodedShieldedCoinInfo, recipient: EncodedRecipient): [];
/**
 * Retrieves the Zswap coin public key of the user executing the circuit.
 *
 * @param circuitContext The current circuit context.
 */
export declare function ownPublicKey(circuitContext: CircuitContext<unknown>): EncodedCoinPublicKey;
/**
 * Checks whether a coin commitment has already been added to the current query context.
 *
 * @param context The current circuit context.
 * @param coinInfo The coin information to check.
 * @param recipient The coin recipient to check.
 */
export declare const hasCoinCommitment: (context: CircuitContext, coinInfo: EncodedShieldedCoinInfo, recipient: EncodedRecipient) => boolean;
