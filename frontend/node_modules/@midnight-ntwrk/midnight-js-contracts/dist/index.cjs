'use strict';

var compactRuntime = require('@midnight-ntwrk/compact-runtime');
var midnightJsTypes = require('@midnight-ntwrk/midnight-js-types');
require('fs');
require('path');
var compactJs = require('@midnight-ntwrk/compact-js');
var midnightJsNetworkId = require('@midnight-ntwrk/midnight-js-network-id');
var midnightJsUtils = require('@midnight-ntwrk/midnight-js-utils');
var Contract = require('@midnight-ntwrk/compact-js/effect/Contract');
var ledgerV7 = require('@midnight-ntwrk/ledger-v7');
var onchainRuntimeV2 = require('@midnight-ntwrk/onchain-runtime-v2');
var ContractAddress = require('@midnight-ntwrk/platform-js/effect/ContractAddress');

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
class TxFailedError extends Error {
    finalizedTxData;
    circuitId;
    /**
     * @param finalizedTxData The finalization data of the transaction that failed.
     * @param circuitId The name of the circuit that was called to create the call
     *                  transaction that failed. Only defined if a call transaction
     *                  failed.
     */
    constructor(finalizedTxData, circuitId) {
        super('Transaction failed');
        this.finalizedTxData = finalizedTxData;
        this.circuitId = circuitId;
        this.message = JSON.stringify({
            ...(circuitId && { circuitId }),
            ...finalizedTxData
        }, null, '\t');
    }
}
/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
class DeployTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the deployment transaction that failed.
     */
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'DeployTxFailedError';
    }
}
/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
class CallTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the call transaction that failed.
     * @param circuitId The name of the circuit that was called to build the transaction.
     */
    constructor(finalizedTxData, circuitId) {
        super(finalizedTxData, circuitId);
        this.name = 'CallTxFailedError';
    }
}
/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
class ContractTypeError extends TypeError {
    contractState;
    circuitIds;
    /**
     * Initializes a new {@link ContractTypeError}.
     *
     * @param contractState The initial deployed contract state.
     * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
     *                   key present in `contractState`.
     */
    constructor(contractState, circuitIds) {
        super(`Following operations: ${circuitIds.join(', ')}, are undefined or have mismatched verifier keys for contract state ${contractState.toString(false)}`);
        this.contractState = contractState;
        this.circuitIds = circuitIds;
    }
}
/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'ReplaceMaintenanceAuthorityTxFailedError';
    }
}
/**
 * An error indicating that a verifier key removal transaction failed.
 */
class RemoveVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'RemoveVerifierKeyTxFailedError';
    }
}
/**
 * An error indicating that a verifier key insertion transaction failed.
 */
class InsertVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData) {
        super(finalizedTxData);
        this.name = 'InsertVerifierKeyTxFailedError';
    }
}
/**
 * An error indicating that a private state ID was specified for a call transaction while a private
 * state provider was not. We want to let the user know so that they aren't under the impression the
 * private state of a contract was updated when it wasn't.
 */
class IncompleteCallTxPrivateStateConfig extends Error {
    constructor() {
        super('Incorrect call transaction configuration');
        this.message = "'privateStateId' was defined for call transaction while 'privateStateProvider' was undefined";
    }
}
/**
 * An error indicating that an initial private state was specified for a contract find while a
 * private state ID was not. We can't store the initial private state if we don't have a private state ID,
 * and we need to let the user know that.
 */
class IncompleteFindContractPrivateStateConfig extends Error {
    constructor() {
        super('Incorrect find contract configuration');
        this.message = "'initialPrivateState' was defined for contract find while 'privateStateId' was undefined";
    }
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function submitTxCore(providers, options) {
    const provenTx = await providers.proofProvider.proveTx(options.unprovenTx);
    const toSubmit = await providers.walletProvider.balanceTx(provenTx);
    return providers.midnightProvider.submitTx(toSubmit);
}
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * ## Blocking Behavior
 *
 * This method **waits indefinitely** for the transaction to appear on the blockchain via
 * `providers.publicDataProvider.watchForTxData(txId)`. It will not return until:
 * - The transaction is successfully included in the blockchain, OR
 * - An error occurs during proving, balancing, or submission
 *
 * ## Conditions When Transaction May Not Appear
 *
 * A submitted transaction may fail to appear on-chain if:
 * - Transaction is invalid in ways not detected during local validation
 * - Network issues prevent propagation to validators
 * - Transaction is rejected by validator consensus
 * - Insufficient fees or resources
 * - Contract state has changed making the transaction invalid
 *
 * ## Implications of Aborting This Method
 *
 * If the application terminates this method before it returns:
 * - Transaction may still be pending/processing on-chain
 * - **Private state updates are NOT stored** (even if transaction later succeeds on-chain)
 * - **Signing keys are NOT updated** (for deploy/replace authority transactions)
 * - Application state will be out of sync with blockchain state
 * - Manual recovery may be required to reconcile state
 *
 * **Recommendation**: Use {@link submitTxAsync} for non-blocking submission with manual
 * finalization handling and timeout control.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
const submitTx = async (providers, options) => {
    const txId = await submitTxCore(providers, options);
    return providers.publicDataProvider.watchForTxData(txId);
};
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options. Unlike {@link submitTx},
 * this function returns immediately after submission without waiting for finalization.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the transaction ID immediately after submission,
 *          or rejects if an error occurs during preparation or submission.
 *          To watch for finalization, use providers.publicDataProvider.watchForTxData(txId).
 */
const submitTxAsync = async (providers, options) => {
    return submitTxCore(providers, options);
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// A default segment number to use when creating inputs and outputs. The Ledger has exposed this parameter
// now but we don't know what the value should be, and assume that everything first in segment '0'. This
// will change with work on Unshielded Tokens and I believe the Ledger will come with utility that will inform
// the segment numbers.
const DEFAULT_SEGMENT_NUMBER = 0;
const checkKeys = (coinInfo) => Object.keys(coinInfo).forEach((key) => {
    if (key !== 'value' && key !== 'type' && key !== 'nonce') {
        throw new TypeError(`Key '${key}' should not be present in output data ${coinInfo}`);
    }
});
const serializeCoinInfo = (coinInfo) => {
    checkKeys(coinInfo);
    return JSON.stringify({
        ...coinInfo,
        value: { __big_int_val__: coinInfo.value.toString() }
    });
};
const serializeQualifiedShieldedCoinInfo = (coinInfo) => {
    const { mt_index: _, ...rest } = coinInfo;
    return serializeCoinInfo(rest);
};
const deserializeCoinInfo = (coinInfo) => {
    const res = JSON.parse(coinInfo, (key, value) => {
        if (key === 'value' &&
            value != null &&
            typeof value === 'object' &&
            '__big_int_val__' in value &&
            typeof value.__big_int_val__ === 'string') {
            return BigInt(value.__big_int_val__);
        }
        if ((key === 'color' || key === 'nonce') &&
            value != null &&
            typeof value === 'object' &&
            '__uint8Array_val__' in value &&
            typeof value.__uint8Array_val__ === 'string') {
            return midnightJsUtils.fromHex(value.__uint8Array_val__);
        }
        return value;
    });
    checkKeys(res);
    return res;
};
const createZswapOutput = ({ coinInfo, recipient }, encryptionPublicKey, segmentNumber = 0) => 
// TBD need to confirm segment number and wallet encryptionPublicKey usage.
recipient.is_left
    ? ledgerV7.ZswapOutput.new(coinInfo, segmentNumber, recipient.left, encryptionPublicKey)
    : ledgerV7.ZswapOutput.newContractOwned(coinInfo, segmentNumber, recipient.right);
const unprovenOfferFromCoinInfo = ([coinInfo, unproven], f) => {
    const { type, value } = deserializeCoinInfo(coinInfo);
    return f(unproven, type, value);
};
const unprovenOfferFromMap = (map, f) => {
    if (map.size === 0) {
        return undefined;
    }
    const offers = Array.from(map, (entry) => unprovenOfferFromCoinInfo(entry, f)).filter((offer) => offer != null);
    if (offers.length === 0) {
        return undefined;
    }
    return offers.reduce((acc, curr) => acc.merge(curr));
};
const zswapStateToOffer = (zswapLocalState, encryptionPublicKey, addressAndChainStateTuple) => {
    const unprovenOutputs = new Map(zswapLocalState.outputs.map((output) => [
        serializeCoinInfo(output.coinInfo),
        createZswapOutput(output, encryptionPublicKey, DEFAULT_SEGMENT_NUMBER)
    ]));
    const unprovenInputs = new Map();
    const unprovenTransients = new Map();
    zswapLocalState.inputs.forEach((qualifiedCoinInfo) => {
        const serializedCoinInfo = serializeQualifiedShieldedCoinInfo(qualifiedCoinInfo);
        const unprovenOutput = unprovenOutputs.get(serializedCoinInfo);
        if (unprovenOutput) {
            unprovenTransients.set(serializedCoinInfo, ledgerV7.ZswapTransient.newFromContractOwnedOutput(qualifiedCoinInfo, DEFAULT_SEGMENT_NUMBER, unprovenOutput));
            unprovenOutputs.delete(serializedCoinInfo);
        }
        else {
            midnightJsUtils.assertDefined(addressAndChainStateTuple, `Only outputs or transients are expected when no chain state is provided`);
            midnightJsUtils.assertIsContractAddress(addressAndChainStateTuple.contractAddress);
            unprovenInputs.set(serializedCoinInfo, ledgerV7.ZswapInput.newContractOwned(qualifiedCoinInfo, DEFAULT_SEGMENT_NUMBER, addressAndChainStateTuple.contractAddress, addressAndChainStateTuple.zswapChainState));
        }
    });
    const inputsOffer = unprovenOfferFromMap(unprovenInputs, ledgerV7.ZswapOffer.fromInput);
    const outputsOffer = unprovenOfferFromMap(unprovenOutputs, ledgerV7.ZswapOffer.fromOutput);
    const transientsOffer = unprovenOfferFromMap(unprovenTransients, ledgerV7.ZswapOffer.fromTransient);
    const offers = [inputsOffer, outputsOffer, transientsOffer].filter(offer => offer != null);
    if (offers.length === 0) {
        return undefined;
    }
    if (offers.length === 1) {
        return offers[0];
    }
    return offers.reduce((acc, curr) => acc.merge(curr));
};
const zswapStateToNewCoins = (receiverCoinPublicKey, zswapState) => zswapState.outputs
    .filter((output) => output.recipient.left === receiverCoinPublicKey)
    .map(({ coinInfo }) => coinInfo);
const encryptionPublicKeyForZswapState = (zswapState, walletCoinPublicKey, walletEncryptionPublicKey) => {
    const networkId = midnightJsNetworkId.getNetworkId();
    const walletCoinPublicKeyLocal = midnightJsUtils.parseCoinPublicKeyToHex(walletCoinPublicKey, networkId);
    const localCoinPublicKey = midnightJsUtils.parseCoinPublicKeyToHex(zswapState.coinPublicKey, networkId);
    if (localCoinPublicKey !== walletCoinPublicKeyLocal) {
        throw new Error('Unable to lookup encryption public key (Unsupported coin)');
    }
    return midnightJsUtils.parseEncPublicKeyToHex(walletEncryptionPublicKey, networkId);
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const toLedgerContractState = (contractState) => ledgerV7.ContractState.deserialize(contractState.serialize());
const fromLedgerContractState = (contractState) => compactRuntime.ContractState.deserialize(contractState.serialize());
const createUnprovenLedgerDeployTx = (contractState, zswapLocalState, encryptionPublicKey) => {
    const contractDeploy = new ledgerV7.ContractDeploy(toLedgerContractState(contractState));
    return [
        contractDeploy.address,
        fromLedgerContractState(contractDeploy.initialState),
        midnightJsTypes.Transaction.fromParts(midnightJsNetworkId.getNetworkId(), zswapStateToOffer(zswapLocalState, encryptionPublicKey), undefined, ledgerV7.Intent.new(midnightJsUtils.ttlOneHour()).addDeploy(contractDeploy))
    ];
};
const createUnprovenLedgerCallTx = (circuitId, contractAddress, initialContractState, zswapChainState, partitionedTranscript, privateTranscriptOutputs, input, output, nextZswapLocalState, encryptionPublicKey) => {
    const op = toLedgerContractState(initialContractState).operation(circuitId);
    midnightJsUtils.assertDefined(op, `Operation '${circuitId}' is undefined for contract state ${initialContractState.toString(false)}`);
    return midnightJsTypes.Transaction.fromPartsRandomized(midnightJsNetworkId.getNetworkId(), zswapStateToOffer(nextZswapLocalState, encryptionPublicKey, {
        contractAddress,
        zswapChainState
    }), undefined, ledgerV7.Intent.new(midnightJsUtils.ttlOneHour()).addCall(new ledgerV7.ContractCallPrototype(contractAddress, circuitId, op, partitionedTranscript[0], partitionedTranscript[1], privateTranscriptOutputs, input, output, ledgerV7.communicationCommitmentRandomness(), circuitId)));
};
// Utilities for unproven transactions for the single contract updates above.
const unprovenTxFromContractUpdates = async (updateAndSignFn) => {
    return midnightJsTypes.Transaction.fromParts(midnightJsNetworkId.getNetworkId(), undefined, undefined, ledgerV7.Intent.new(midnightJsUtils.ttlOneHour()).addMaintenanceUpdate(await updateAndSignFn()));
};
const createUnprovenReplaceAuthorityTx = (zkConfigProvider, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress, newAuthority, contractState, currentAuthority, coinPublicKey) => {
    const contractExec = compactJs.ContractExecutable.make(compiledContract);
    const contractRuntime = midnightJsTypes.makeContractExecutableRuntime(zkConfigProvider, {
        coinPublicKey,
        signingKey: currentAuthority
    });
    return unprovenTxFromContractUpdates(async () => {
        return (await contractRuntime.runPromise(contractExec.replaceContractMaintenanceAuthority(midnightJsTypes.asEffectOption(newAuthority), {
            address: midnightJsTypes.asContractAddress(contractAddress),
            contractState
        }))).public.maintenanceUpdate;
    });
};
const createUnprovenRemoveVerifierKeyTx = (zkConfigProvider, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress, operation, contractState, currentAuthority, coinPublicKey) => {
    const contractExec = compactJs.ContractExecutable.make(compiledContract);
    const contractRuntime = midnightJsTypes.makeContractExecutableRuntime(zkConfigProvider, {
        coinPublicKey,
        signingKey: currentAuthority
    });
    return unprovenTxFromContractUpdates(async () => {
        return (await contractRuntime.runPromise(contractExec.removeContractOperation(Contract.ImpureCircuitId(operation), {
            address: midnightJsTypes.asContractAddress(contractAddress),
            contractState
        }))).public.maintenanceUpdate;
    });
};
const createUnprovenInsertVerifierKeyTx = (zkConfigProvider, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress, operation, newVk, contractState, currentAuthority, coinPublicKey) => {
    const contractExec = compactJs.ContractExecutable.make(compiledContract);
    const contractRuntime = midnightJsTypes.makeContractExecutableRuntime(zkConfigProvider, {
        coinPublicKey,
        signingKey: currentAuthority
    });
    return unprovenTxFromContractUpdates(async () => {
        return (await contractRuntime.runPromise(contractExec.addOrReplaceContractOperation(Contract.ImpureCircuitId(operation), Contract.VerifierKey(newVk), {
            address: midnightJsTypes.asContractAddress(contractAddress),
            contractState
        }))).public.maintenanceUpdate;
    });
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param verifierKeys The verifier keys for the contract being deployed.
 * @param coinPublicKey The Zswap coin public key of the current user.
 * @param options Configuration.
 * @param encryptionPublicKey
 * @returns Data produced by the contract constructor call and an unproven deployment transaction
 *          assembled from the contract constructor result.
 */
async function createUnprovenDeployTxFromVerifierKeys(zkConfigProvider, coinPublicKey, options, encryptionPublicKey) {
    const contractExec = compactJs.ContractExecutable.make(options.compiledContract);
    const contractRuntime = midnightJsTypes.makeContractExecutableRuntime(zkConfigProvider, {
        coinPublicKey: coinPublicKey,
        signingKey: options.signingKey
    });
    const initialPrivateState = 'initialPrivateState' in options ? options.initialPrivateState : undefined;
    const args = ('args' in options ? options.args : []);
    const exitResult = await contractRuntime.runPromiseExit(contractExec.initialize(initialPrivateState, ...args));
    try {
        const { public: { contractState }, private: { privateState, signingKey, zswapLocalState } } = midnightJsTypes.exitResultOrError(exitResult);
        const [contractAddress, initialContractState, unprovenTx] = createUnprovenLedgerDeployTx(contractState, zswapLocalState, encryptionPublicKey);
        return {
            public: {
                contractAddress,
                initialContractState
            },
            private: {
                signingKey,
                initialPrivateState: privateState,
                initialZswapState: zswapLocalState,
                unprovenTx,
                newCoins: zswapStateToNewCoins(coinPublicKey, zswapLocalState)
            }
        };
    }
    catch (error) {
        // Report CompactError messages as they are, otherwise re-throw the error.
        if (error?.['_tag'] !== 'ContractRuntimeError')
            throw error; // eslint-disable-line @typescript-eslint/no-explicit-any
        if (error?.cause.name !== 'CompactError')
            throw error; // eslint-disable-line @typescript-eslint/no-explicit-any
        throw new Error(error?.cause.message); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
}
/**
 * Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
 * from the constructor results.
 *
 * @param providers The providers to use to create the deploy transaction.
 * @param options Configuration.
 *
 * @returns A promise that contains all data produced by the constructor call and an unproven
 *          transaction assembled from the constructor result.
 */
async function createUnprovenDeployTx(providers, options) {
    return createUnprovenDeployTxFromVerifierKeys(providers.zkConfigProvider, midnightJsUtils.parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), midnightJsNetworkId.getNetworkId()), options, providers.walletProvider.getEncryptionPublicKey());
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates and submits a deploy transaction for the given contract.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `DeployTxFailedError` is thrown with transaction data
 * - Private state (if `privateStateId` provided) is NOT stored
 * - Contract signing key is NOT stored in private state provider
 * - Contract is NOT deployed
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `DeployTxFailedError` is thrown with transaction data
 * - Private state (if `privateStateId` provided) is NOT stored
 * - Contract signing key is NOT stored in private state provider
 * - Transaction appears in blockchain history as partial success
 * - Contract may be partially deployed but not functional
 *
 * @param providers The providers used to manage the deploy lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the finalized deployment transaction data;
 *          or rejects with an error if the deployment fails.
 *
 * @throws {DeployTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 */
async function submitDeployTx(providers, options) {
    const unprovenDeployTxData = await createUnprovenDeployTx(providers, options);
    const finalizedTxData = await submitTx(providers, {
        unprovenTx: unprovenDeployTxData.private.unprovenTx
    });
    if (finalizedTxData.status !== midnightJsTypes.SucceedEntirely) {
        throw new DeployTxFailedError(finalizedTxData);
    }
    if ('privateStateId' in options) {
        await providers.privateStateProvider.set(options.privateStateId, unprovenDeployTxData.private.initialPrivateState);
    }
    await providers.privateStateProvider.setSigningKey(unprovenDeployTxData.public.contractAddress, unprovenDeployTxData.private.signingKey);
    return {
        private: unprovenDeployTxData.private,
        public: {
            ...finalizedTxData,
            ...unprovenDeployTxData.public
        }
    };
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @internal */
const TypeId = Symbol.for('@midnight-ntwrk/midnight-js#Transaction');
/** @internal */
const Submit = Symbol.for('@midnight-ntwrk/midnight-js#Transaction/Submit');
/** @internal */
const MergeUnsubmittedCallTxData = Symbol.for('@midnight-ntwrk/midnight-js#Transaction/MergeUnsubmittedCallTxData');
/** @internal */
const CacheStates = Symbol.for('@midnight-ntwrk/midnight-js#Transaction/CacheStates');
const mergeSubmitTxOptions = (current, next) => {
    if (!current) {
        return next;
    }
    const circuitIds = new Set([
        ...(Array.isArray(current.circuitId) ? current.circuitId : [current.circuitId]),
        ...(Array.isArray(next.circuitId) ? next.circuitId : [next.circuitId])
    ]);
    return {
        unprovenTx: current.unprovenTx.merge(next.unprovenTx),
        circuitId: Array.from(circuitIds)
    };
};
/** @internal */
class TransactionContextImpl {
    [TypeId] = TypeId;
    providers; // eslint-disable-line @typescript-eslint/no-explicit-any
    options;
    currentStates = undefined;
    currentUnsubmittedCall;
    submitTxOptions = undefined;
    constructor(providers, options) {
        this.providers = providers;
        this.options = options;
    }
    getCurrentStates() {
        return this.currentStates;
    }
    getLastUnsubmittedCallTxDataToTransact() {
        return this.currentUnsubmittedCall;
    }
    async [Submit]() {
        const [unprovenCallTxData, privateStateId] = this.getLastUnsubmittedCallTxDataToTransact() ?? [];
        if (!unprovenCallTxData) {
            throw new Error('No calls were submitted.');
        }
        const finalizedTxData = await submitTx(this.providers, this.submitTxOptions);
        if (finalizedTxData.status !== midnightJsTypes.SucceedEntirely) {
            throw new CallTxFailedError(finalizedTxData, this.submitTxOptions.circuitId);
        }
        if (privateStateId) {
            await this.providers.privateStateProvider.set(privateStateId, unprovenCallTxData.private.nextPrivateState);
        }
        return {
            private: unprovenCallTxData.private,
            public: {
                ...unprovenCallTxData.public,
                ...finalizedTxData
            }
        };
    }
    [CacheStates](states) {
        this.currentStates = states;
    }
    [MergeUnsubmittedCallTxData](circuitId, callData, privateStateId) {
        this.currentUnsubmittedCall = [callData, privateStateId];
        this.submitTxOptions = mergeSubmitTxOptions(this.submitTxOptions, {
            unprovenTx: callData.private.unprovenTx,
            circuitId
        });
        // If there is no currently active state, then return...
        if (!this.currentStates)
            return;
        // ...otherwise apply the changes in `callData` to the cached state.
        const privateState = callData.private.nextPrivateState;
        const contractState = this.currentStates.contractState;
        contractState.data = new onchainRuntimeV2.ChargedState(callData.public.nextContractState);
        const [zswapChainState] = callData.private.unprovenTx.guaranteedOffer
            ? this.currentStates.zswapChainState.tryApply(ledgerV7.ZswapOffer.deserialize('pre-proof', callData.private.unprovenTx.guaranteedOffer.serialize()))
            : [this.currentStates.zswapChainState];
        this[CacheStates]({ contractState, zswapChainState, privateState });
    }
}
/** @internal */
const mergeUnsubmittedCallTxData = (txCtx, circuitId, callData, privateStateId) => {
    txCtx[MergeUnsubmittedCallTxData](circuitId, callData, privateStateId);
};
/** @internal */
const isTransactionContext$1 = (u) => typeof u === "object" && u != null && TypeId in u;
/** @internal */
const scoped = async (providers, fn, txCtxOrOptions, options) => {
    const outerTxCtx = isTransactionContext$1(txCtxOrOptions) ? txCtxOrOptions : undefined;
    const txOptions = isTransactionContext$1(txCtxOrOptions)
        ? options
        : txCtxOrOptions;
    const innerTxCtx = outerTxCtx ?? new TransactionContextImpl(providers, txOptions);
    try {
        await fn(innerTxCtx);
    }
    catch (err) {
        if (outerTxCtx) {
            throw err;
        }
        const execErr = new Error(`Unexpected error executing scoped transaction '${'<unnamed>'}': ${String(err)}`, { cause: err });
        providers?.loggerProvider?.error?.call(providers.loggerProvider, execErr.message);
        throw execErr;
    }
    try {
        // Only submit when there is no outer transaction context (i.e., no parent transaction context, meaning
        // that this is the root transaction context).
        if (!outerTxCtx) {
            return await innerTxCtx[Submit]();
        }
        // ...otherwise, return the `CallResult` from the last submitted call within the scope of the transaction context.
        const [unprovenCallTxData] = innerTxCtx.getLastUnsubmittedCallTxDataToTransact() ?? [];
        if (!unprovenCallTxData) {
            throw new Error('No calls were submitted.');
        }
        return {
            public: {
                nextContractState: unprovenCallTxData.public.nextContractState,
                partitionedTranscript: unprovenCallTxData.public.partitionedTranscript,
                publicTranscript: unprovenCallTxData.public.publicTranscript
            },
            private: {
                input: unprovenCallTxData.private.input,
                output: unprovenCallTxData.private.output,
                privateTranscriptOutputs: unprovenCallTxData.private.privateTranscriptOutputs,
                result: unprovenCallTxData.private.result,
                nextPrivateState: unprovenCallTxData.private.nextPrivateState,
                nextZswapLocalState: unprovenCallTxData.private.nextZswapLocalState
            }
        };
    }
    catch (err) {
        // Rethrow known call transaction failures and errors occurring within an outer transaction context...
        if (err instanceof CallTxFailedError || outerTxCtx) {
            throw err;
        }
        // ...otherwise, wrap and rethrow errors occurring during submission at the root transaction context.
        const submitErr = new Error(`Unexpected error submitting scoped transaction '${'<unnamed>'}': ${String(err)}`, { cause: err });
        providers?.loggerProvider?.error?.call(providers.loggerProvider, submitErr.message);
        throw submitErr;
    }
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Fetches only the public visible (Zswap and ledger) states of a contract.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
const getPublicStates = async (publicDataProvider, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const zswapAndContractState = await publicDataProvider.queryZSwapAndContractState(contractAddress);
    midnightJsUtils.assertDefined(zswapAndContractState, `No public state found at contract address '${contractAddress}'`);
    const [zswapChainState, contractState] = zswapAndContractState;
    return { contractState, zswapChainState };
};
/**
 * Retrieves the Zswap, ledger, and private states of the contract corresponding
 * to the given identifier using the given providers.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param privateStateProvider The provider to use to fetch the private state.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier for the private state of the contract.
 */
const getStates = async (publicDataProvider, privateStateProvider, contractAddress, privateStateId) => {
    const publicContractStates = await getPublicStates(publicDataProvider, contractAddress);
    const privateState = await privateStateProvider.get(privateStateId);
    midnightJsUtils.assertDefined(privateState, `No private state found at private state ID '${privateStateId}'`);
    return { ...publicContractStates, privateState };
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Calls a circuit using the provided initial `states` and creates an unbalanced,
 * unproven, unsubmitted, call transaction.
 *
 * @param options Configuration.
 *
 * @param walletCoinPublicKey
 * @param walletEncryptionPublicKey
 * @returns Data produced by the circuit call and an unproven transaction assembled from the call result.
 */
async function createUnprovenCallTxFromInitialStates(zkConfigProvider, options, walletEncryptionPublicKey) {
    const { compiledContract, contractAddress, coinPublicKey, initialContractState, initialZswapChainState } = options;
    midnightJsUtils.assertIsContractAddress(contractAddress);
    midnightJsUtils.assertDefined(compactJs.ContractExecutable.make(options.compiledContract)
        .getImpureCircuitIds()
        .find((circuitId) => circuitId === options.circuitId), `Circuit '${options.circuitId}' is undefined`);
    const contractExec = compactJs.ContractExecutable.make(compiledContract);
    const contractRuntime = midnightJsTypes.makeContractExecutableRuntime(zkConfigProvider, {
        coinPublicKey: options.coinPublicKey
    });
    const initialPrivateState = 'initialPrivateState' in options ? options.initialPrivateState : undefined;
    const args = ('args' in options ? options.args : []);
    const exitResult = await contractRuntime.runPromiseExit(contractExec.circuit(Contract.ImpureCircuitId(options.circuitId), {
        address: ContractAddress.ContractAddress(contractAddress),
        contractState: initialContractState,
        privateState: initialPrivateState
    }, ...args // eslint-disable-line @typescript-eslint/no-explicit-any
    ));
    try {
        const { public: { contractState, partitionedTranscript, publicTranscript }, private: { input, output, privateState, privateTranscriptOutputs, result, zswapLocalState } } = midnightJsTypes.exitResultOrError(exitResult);
        return {
            public: {
                nextContractState: contractState,
                partitionedTranscript,
                publicTranscript
            },
            private: {
                input,
                output,
                result: result,
                nextPrivateState: privateState,
                nextZswapLocalState: zswapLocalState,
                privateTranscriptOutputs,
                unprovenTx: createUnprovenLedgerCallTx(options.circuitId, contractAddress, initialContractState, initialZswapChainState, partitionedTranscript, privateTranscriptOutputs, input, output, zswapLocalState, encryptionPublicKeyForZswapState(zswapLocalState, options.coinPublicKey, walletEncryptionPublicKey)),
                newCoins: zswapStateToNewCoins(midnightJsUtils.parseCoinPublicKeyToHex(coinPublicKey, midnightJsNetworkId.getNetworkId()), zswapLocalState)
            }
        };
    }
    catch (error) {
        // Report CompactError messages as they are, otherwise re-throw the error.
        if (error?.['_tag'] !== 'ContractRuntimeError')
            throw error; // eslint-disable-line @typescript-eslint/no-explicit-any
        if (error?.cause.name !== 'CompactError')
            throw error; // eslint-disable-line @typescript-eslint/no-explicit-any
        throw new Error(error?.cause.message); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
}
const createCallOptions = (callTxOptions, coinPublicKey, initialContractState, initialZswapChainState, initialPrivateState) => {
    const callOptionsBase = {
        compiledContract: callTxOptions.compiledContract,
        contractAddress: callTxOptions.contractAddress,
        circuitId: callTxOptions.circuitId
    };
    const callOptionsWithArguments = 'args' in callTxOptions
        ? {
            ...callOptionsBase,
            args: callTxOptions.args
        }
        : callOptionsBase;
    const callOptionsBaseWithProviderDataDependencies = {
        ...callOptionsWithArguments,
        coinPublicKey: midnightJsUtils.parseCoinPublicKeyToHex(coinPublicKey, midnightJsNetworkId.getNetworkId()),
        initialContractState,
        initialZswapChainState
    };
    const callOptions = initialPrivateState
        ? { ...callOptionsBaseWithProviderDataDependencies, initialPrivateState }
        : callOptionsBaseWithProviderDataDependencies;
    return callOptions;
};
const getContractStates = async (providers, options, transactionContext) => {
    const txCtxStates = transactionContext?.getCurrentStates();
    if (txCtxStates) {
        return txCtxStates;
    }
    const states = await getStates(providers.publicDataProvider, providers.privateStateProvider, options.contractAddress, options.privateStateId);
    if (transactionContext) {
        transactionContext[CacheStates](states);
    }
    return states;
};
const getContractPublicStates = async (providers, options, transactionContext) => {
    const txCtxStates = transactionContext?.getCurrentStates();
    if (txCtxStates) {
        return txCtxStates;
    }
    const states = await getPublicStates(providers.publicDataProvider, options.contractAddress);
    if (transactionContext) {
        transactionContext[CacheStates]({ ...states, privateState: undefined });
    }
    return states;
};
/**
 * Calls a circuit using states fetched from the public data provider and private state
 * provider, then creates an unbalanced, unproven, unsubmitted, call transaction.
 *
 * @param providers The providers to use to create the call transaction.
 * @param options Configuration.
 * @param transactionContext Optional scoped transaction context to participate in an
 *        existing transaction scope.
 *
 * @returns A promise that contains all data produced by the circuit call and an unproven
 *          transaction assembled from the call result.
 *
 * @throws IncompleteCallTxPrivateStateConfig If a `privateStateId` was given but a `privateStateProvider`
 *                                           was not. We assume that when a user gives a `privateStateId`,
 *                                           they want to update the private state store.
 */
async function createUnprovenCallTx(providers, options, transactionContext) {
    midnightJsUtils.assertIsContractAddress(options.contractAddress);
    midnightJsUtils.assertDefined(compactJs.ContractExecutable.make(options.compiledContract)
        .getImpureCircuitIds()
        .find((a) => a === options.circuitId), `Circuit '${options.circuitId}' is undefined`);
    const hasPrivateStateProvider = 'privateStateProvider' in providers;
    const hasPrivateStateId = 'privateStateId' in options;
    if (hasPrivateStateId && !hasPrivateStateProvider) {
        throw new IncompleteCallTxPrivateStateConfig();
    }
    if (hasPrivateStateId && hasPrivateStateProvider) {
        const { zswapChainState, contractState, privateState } = await getContractStates(providers, options, transactionContext);
        return createUnprovenCallTxFromInitialStates(providers.zkConfigProvider, createCallOptions(options, midnightJsUtils.parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), midnightJsNetworkId.getNetworkId()), contractState, zswapChainState, privateState), providers.walletProvider.getEncryptionPublicKey());
    }
    const { zswapChainState, contractState } = await getContractPublicStates(providers, options, transactionContext);
    return createUnprovenCallTxFromInitialStates(providers.zkConfigProvider, createCallOptions(options, midnightJsUtils.parseCoinPublicKeyToHex(providers.walletProvider.getCoinPublicKey(), midnightJsNetworkId.getNetworkId()), contractState, zswapChainState), providers.walletProvider.getEncryptionPublicKey());
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* Creates and submits a transaction for the invocation of a circuit on a given contract.
*
* ## Transaction Execution Phases
*
* Midnight transactions execute in two phases:
* 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
* 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
*
* ## Failure Behavior
*
* **Guaranteed Phase Failure:**
* - Transaction is rejected and not included in the blockchain
* - `CallTxFailedError` is thrown with transaction data and circuit ID
* - Private state updates are NOT stored (state remains unchanged)
* - No on-chain record of the failed transaction
*
* **Fallible Phase Failure:**
* - Transaction is recorded on-chain with non-`SucceedEntirely` status
* - `CallTxFailedError` is thrown with transaction data and circuit ID
* - Private state updates are NOT stored (state remains unchanged)
* - Transaction appears in blockchain history as partial success
*
* @param providers The providers used to manage the invocation lifecycle.
* @param options Configuration.
* @param transactionContext Optional scoped transaction context to participate in an
*        existing transaction scope.
*
* @returns A `Promise` that resolves with the finalized transaction data for the invocation of
*         `circuitId` on `contract` with the given `args`; or rejects with an error if the invocation fails.
*
* @throws {CallTxFailedError} When transaction fails in either guaranteed or fallible phase.
*         The error contains the finalized transaction data and circuit ID for debugging.
*/
async function submitCallTx(providers, options, transactionContext) {
    midnightJsUtils.assertIsContractAddress(options.contractAddress);
    midnightJsUtils.assertDefined(compactJs.ContractExecutable.make(options.compiledContract)
        .getImpureCircuitIds()
        .find((circuitId) => circuitId === options.circuitId), `Circuit '${options.circuitId}' is undefined`);
    const hasPrivateStateProvider = 'privateStateProvider' in providers;
    const hasPrivateStateId = 'privateStateId' in options;
    if (hasPrivateStateId && !hasPrivateStateProvider) {
        throw new IncompleteCallTxPrivateStateConfig();
    }
    const callTxFn = async (txCtx) => {
        mergeUnsubmittedCallTxData(txCtx, options.circuitId, await createUnprovenCallTx(providers, options, txCtx), hasPrivateStateId ? options.privateStateId : undefined);
    };
    return transactionContext
        ? scoped(providers, callTxFn, transactionContext)
        : scoped(providers, callTxFn);
}
/**
 * Creates and submits a transaction for the invocation of a circuit on a given contract,
 * returning immediately after submission without waiting for finalization.
 *
 * Unlike {@link submitCallTx}, this function does not wait for transaction finalization,
 * check transaction status, or update private state. The caller must handle these steps manually.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Manual Post-Submission Steps
 *
 * After calling this function, you must manually:
 * 1. Watch for transaction finalization using `providers.publicDataProvider.watchForTxData(txId)`
 * 2. Check transaction status (compare against `SucceedEntirely`)
 * 3. Handle failures appropriately (throw errors, log, etc.)
 * 4. Update private state if transaction succeeded and `privateStateId` was provided
 *
 * ## Failure Behavior (Manual Handling Required)
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `watchForTxData` may reject or return error status
 * - You must NOT store private state updates
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `watchForTxData` returns transaction data with failed status
 * - You must NOT store private state updates
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers used to manage the invocation lifecycle.
 * @param options Configuration.
 *
 * @returns A `Promise` that resolves with the transaction ID and call transaction data immediately after submission;
 *         or rejects with an error if the submission fails.
 *
 * @example
 * ```typescript
 * // 1. Submit
 * const { txId, callTxData } = await submitCallTxAsync(providers, options);
 *
 * // 2. Watch (when ready)
 * const finalizedData = await providers.publicDataProvider.watchForTxData(txId);
 *
 * // 3. Check status
 * if (finalizedData.status !== SucceedEntirely) {
 *   throw new CallTxFailedError(finalizedData, options.circuitId);
 * }
 *
 * // 4. Update private state manually if needed
 * if (options.privateStateId) {
 *   await providers.privateStateProvider.set(
 *     privateStateId,
 *     callTxData.private.nextPrivateState
 *   );
 * }
 * ```
 */
async function submitCallTxAsync(providers, options) {
    midnightJsUtils.assertIsContractAddress(options.contractAddress);
    midnightJsUtils.assertDefined(compactJs.ContractExecutable.make(options.compiledContract)
        .getImpureCircuitIds()
        .find((circuitId) => circuitId === options.circuitId), `Circuit '${options.circuitId}' is undefined`);
    const hasPrivateStateProvider = 'privateStateProvider' in providers;
    const hasPrivateStateId = 'privateStateId' in options;
    if (hasPrivateStateId && !hasPrivateStateProvider) {
        throw new IncompleteCallTxPrivateStateConfig();
    }
    const unprovenCallTxData = await createUnprovenCallTx(providers, options);
    const txId = await submitTxAsync(providers, {
        unprovenTx: unprovenCallTxData.private.unprovenTx,
        circuitId: options.circuitId
    });
    return {
        txId,
        callTxData: unprovenCallTxData
    };
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Constructs and submits a transaction that adds a new verifier key to the
 * blockchain for the given circuit ID at the given contract address.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `InsertVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key is NOT added to the contract
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `InsertVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key may be partially added but not usable
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param compiledContract The compiled contract for which the maintenance authority
 *                         should be updated.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be inserted.
 * @param circuitId The circuit for which the verifier key should be inserted.
 * @param newVk The new verifier key for the circuit.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {InsertVerifierKeyTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
const submitInsertVerifierKeyTx = async (providers, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress, circuitId, newVk) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    midnightJsUtils.assertUndefined(contractState.operation(circuitId), `Circuit '${circuitId}' is already defined for contract at address '${contractAddress}'`);
    const signingKey = await providers.privateStateProvider.getSigningKey(contractAddress);
    midnightJsUtils.assertDefined(signingKey, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = await createUnprovenInsertVerifierKeyTx(providers.zkConfigProvider, compiledContract, contractAddress, circuitId, newVk, contractState, signingKey, providers.walletProvider.getCoinPublicKey());
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new InsertVerifierKeyTxFailedError(submitTxResult);
    }
    return submitTxResult;
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Constructs and submits a transaction that removes the current verifier key stored
 * on the blockchain for the given circuit ID at the given contract address.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `RemoveVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key remains on the contract (unchanged)
 * - No on-chain record of the failed transaction
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `RemoveVerifierKeyTxFailedError` is thrown with transaction data
 * - Verifier key may be partially removed but contract state is inconsistent
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param compiledContract The compiled contract for which the maintenance authority
 *                         should be updated.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be removed.
 * @param circuitId The circuit for which the verifier key should be removed.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {RemoveVerifierKeyTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
const submitRemoveVerifierKeyTx = async (providers, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress, circuitId) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    midnightJsUtils.assertDefined(contractState.operation(circuitId), `Circuit '${circuitId}' not found for contract at address '${contractAddress}'`);
    const signingKey = await providers.privateStateProvider.getSigningKey(contractAddress);
    midnightJsUtils.assertDefined(signingKey, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = await createUnprovenRemoveVerifierKeyTx(providers.zkConfigProvider, compiledContract, contractAddress, circuitId, contractState, signingKey, providers.walletProvider.getCoinPublicKey());
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new RemoveVerifierKeyTxFailedError(submitTxResult);
    }
    return submitTxResult;
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Constructs and submits a transaction that replaces the maintenance
 * authority stored on the blockchain for this contract. After the transaction is
 * finalized, the current signing key stored in the given private state provider
 * is overwritten with the given new authority key.
 *
 * ## Transaction Execution Phases
 *
 * Midnight transactions execute in two phases:
 * 1. **Guaranteed phase**: If failure occurs, the transaction is NOT included in the blockchain
 * 2. **Fallible phase**: If failure occurs, the transaction IS recorded on-chain as a partial success
 *
 * ## Failure Behavior
 *
 * **Guaranteed Phase Failure:**
 * - Transaction is rejected and not included in the blockchain
 * - `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
 * - Signing key in private state provider is NOT updated (remains as current authority)
 * - Contract authority on-chain remains unchanged
 *
 * **Fallible Phase Failure:**
 * - Transaction is recorded on-chain with non-`SucceedEntirely` status
 * - `ReplaceMaintenanceAuthorityTxFailedError` is thrown with transaction data
 * - Signing key in private state provider is NOT updated (remains as current authority)
 * - Contract authority on-chain may be partially updated but inconsistent
 * - Transaction appears in blockchain history as partial success
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param compiledContract The compiled contract for which the maintenance authority
 *                         should be updated.
 * @param contractAddress The address of the contract for which the maintenance
 *                        authority should be updated.
 *
 * TODO: There are at least three options we should support in the future:
 *       1. Replace authority and maintain key (current).
 *       2. Replace authority and do not maintain key.
 *       3. Add additional authorities and maintain original key.
 */
const submitReplaceAuthorityTx = (providers, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress) => 
/**
 * @param newAuthority The signing key of the new contract maintenance authority.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * @throws {ReplaceMaintenanceAuthorityTxFailedError} When transaction fails in either guaranteed or fallible phase.
 *         The error contains the finalized transaction data for debugging.
 */
async (newAuthority) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const contractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(contractState, `No contract state found on chain for contract address '${contractAddress}'`);
    const currentAuthority = await providers.privateStateProvider.getSigningKey(contractAddress);
    midnightJsUtils.assertDefined(currentAuthority, `Signing key for contract address '${contractAddress}' not found`);
    const unprovenTx = await createUnprovenReplaceAuthorityTx(providers.zkConfigProvider, compiledContract, contractAddress, newAuthority, contractState, currentAuthority, providers.walletProvider.getCoinPublicKey());
    const submitTxResult = await submitTx(providers, { unprovenTx });
    if (submitTxResult.status !== midnightJsTypes.SucceedEntirely) {
        throw new ReplaceMaintenanceAuthorityTxFailedError(submitTxResult);
    }
    // TODO: What if machine crashes right before the following set executes? How to recover?
    //       Likely will need a history of pending transactions.
    await providers.privateStateProvider.setSigningKey(contractAddress, newAuthority);
    return submitTxResult;
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Type guard to determine if a value is a TransactionContext.
 *
 * @param u The value to check.
 * @returns `true` if `u` is a {@link TransactionContext}, otherwise `false`.
 */
const isTransactionContext = isTransactionContext$1;
/**
 * Executes a function within the context of a contract-scoped transaction.
 *
 * @param providers The contract providers to use within the transaction.
 * @param fn The function to execute within the transaction context.
 * @param options Optional transaction scope options.
 * @returns A `Promise` that resolves with the finalized transaction data of the single transaction
 * created for all circuit calls made within `fn`.
 *
 * @remarks
 * Where `fn` make circuit calls, these are batched together and submitted as a single transaction when
 * the function completes successfully. If `fn` throws an error, any unsubmitted circuit calls are discarded.
 */
const withContractScopedTransaction = async (providers, fn, options) => scoped(providers, fn, options);

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a {@link CallTxOptions} object from various data.
 */
const createCallTxOptions = (compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
circuitId, contractAddress, privateStateId, args) => {
    const callOptionsBase = {
        compiledContract,
        circuitId,
        contractAddress
    };
    const callTxOptionsBase = args.length !== 0 ? { ...callOptionsBase, args } : callOptionsBase;
    const callTxOptions = privateStateId ? { ...callTxOptionsBase, privateStateId } : callTxOptionsBase;
    return callTxOptions;
};
/**
 * Creates a circuit call transaction interface for a contract.
 *
 * @param providers The providers to use to build transactions.
 * @param compiledContract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier of the state of the witnesses of the contract.
 */
const createCircuitCallTxInterface = (providers, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress, privateStateId) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return compactJs.ContractExecutable.make(compiledContract).getImpureCircuitIds().reduce((acc, circuitId) => ({
        ...acc,
        [circuitId]: (...args) => {
            const txCtx = args.length > 0 && isTransactionContext(args[0]) ? args[0] : undefined;
            const callArgs = !txCtx ? args : args;
            const callOptions = createCallTxOptions(compiledContract, circuitId, contractAddress, privateStateId, callArgs);
            return txCtx
                ? submitCallTx(providers, callOptions, txCtx)
                : submitCallTx(providers, callOptions);
        }
    }), {});
};
/**
 * Creates a {@link CircuitMaintenanceTxInterface}.
 *
 * @param providers The providers to use to create and submit transactions.
 * @param circuitId The circuit ID the interface is for.
 * @param contractAddress The address of the deployed contract for which this
 *                        interface is being created.
 */
const createCircuitMaintenanceTxInterface = (providers, circuitId, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return {
        removeVerifierKey() {
            return submitRemoveVerifierKeyTx(providers, compiledContract, contractAddress, circuitId);
        },
        insertVerifierKey(newVk) {
            return submitInsertVerifierKeyTx(providers, compiledContract, contractAddress, circuitId, newVk);
        }
    };
};
/**
 * Creates a {@link CircuitMaintenanceTxInterfaces}.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 */
const createCircuitMaintenanceTxInterfaces = (providers, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return compactJs.ContractExecutable.make(compiledContract).getImpureCircuitIds().reduce((acc, circuitId) => ({
        ...acc,
        [circuitId]: createCircuitMaintenanceTxInterface(providers, circuitId, compiledContract, contractAddress)
    }), {});
};
/**
 * Creates a {@link ContractMaintenanceTxInterface}.
 *
 * @param providers The providers to use to build transactions.
 * @param contractAddress The ledger address of the contract.
 */
const createContractMaintenanceTxInterface = (providers, compiledContract, // eslint-disable-line @typescript-eslint/no-explicit-any
contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    return {
        replaceAuthority: submitReplaceAuthorityTx(providers, compiledContract, contractAddress)
    };
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const createDeployTxOptions = (deployContractOptions) => {
    const deployTxOptionsBase = {
        ...deployContractOptions,
        signingKey: deployContractOptions.signingKey ?? compactRuntime.sampleSigningKey()
    };
    return 'privateStateId' in deployContractOptions
        ? {
            ...deployTxOptionsBase,
            privateStateId: deployContractOptions.privateStateId,
            initialPrivateState: deployContractOptions.initialPrivateState
        }
        : deployTxOptionsBase;
};
/**
 * Creates and submits a contract deployment transaction. This function is the entry point for the transaction
 * construction workflow and is used to create a {@link DeployedContract} instance.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @throws DeployTxFailedError If the transaction is submitted successfully but produces an error
 *                             when executed by the node.
 */
async function deployContract(providers, options) {
    const deployTxData = await submitDeployTx(providers, createDeployTxOptions(options));
    return {
        deployTxData,
        callTx: createCircuitCallTxInterface(providers, options.compiledContract, deployTxData.public.contractAddress, 'privateStateId' in options ? options.privateStateId : undefined),
        circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, options.compiledContract, deployTxData.public.contractAddress),
        contractMaintenanceTx: createContractMaintenanceTxInterface(providers, options.compiledContract, deployTxData.public.contractAddress)
    };
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const setOrGetInitialSigningKey = async (privateStateProvider, options) => {
    if (options.signingKey) {
        await privateStateProvider.setSigningKey(options.contractAddress, options.signingKey);
        return options.signingKey;
    }
    const existingSigningKey = await privateStateProvider.getSigningKey(options.contractAddress);
    if (existingSigningKey) {
        return existingSigningKey;
    }
    const freshSigningKey = compactRuntime.sampleSigningKey();
    await privateStateProvider.setSigningKey(options.contractAddress, freshSigningKey);
    return freshSigningKey;
};
const setOrGetInitialPrivateState = async (privateStateProvider, options) => {
    /**
     * If both 'privateStateId' and 'initialPrivateState' are defined,
     * then 'initialPrivateState' is stored in private state provider at 'privateStateId'.
     *
     * If 'privateStateId' is defined and 'initialPrivateState' is undefined,
     * and the private state provider has an entry at 'privateStateId',
     * then the find reports the stored private state as the initialPrivateState.
     *
     * If 'privateStateId' is defined and 'initialPrivateState' is undefined,
     * and the private state provider does not have an entry at 'privateStateId',
     * then an error is returned.
     *
     * If 'privateStateId' is undefined and 'initialPrivateState' is defined,
     * then an error is returned.
     *
     * If 'privateStateId' is undefined and 'initialPrivateState' is undefined,
     * then no private state is stored.
     */
    const hasPrivateStateId = 'privateStateId' in options;
    const hasInitialPrivateState = 'initialPrivateState' in options;
    if (hasPrivateStateId) {
        if (hasInitialPrivateState) {
            await privateStateProvider.set(options.privateStateId, options.initialPrivateState);
            return options.initialPrivateState;
        }
        const currentPrivateState = await privateStateProvider.get(options.privateStateId);
        midnightJsUtils.assertDefined(currentPrivateState, `No private state found at private state ID '${options.privateStateId}'`);
        return currentPrivateState;
    }
    if (hasInitialPrivateState) {
        throw new IncompleteFindContractPrivateStateConfig();
    }
    // Cast to 'PrivateState<C>' because if we've reached this point, the private state of
    // the contract should be 'undefined'.
    return undefined;
};
/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
const verifierKeysEqual = (a, b) => a.length === b.length && midnightJsUtils.toHex(a) === midnightJsUtils.toHex(b);
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
const verifyContractState = (verifierKeys, contractState) => {
    const mismatchedCircuitIds = verifierKeys.reduce((acc, [circuitId, localVk]) => !contractState.operation(circuitId) ||
        !verifierKeysEqual(localVk, contractState.operation(circuitId).verifierKey)
        ? [...acc, circuitId]
        : acc, []);
    if (mismatchedCircuitIds.length > 0) {
        throw new ContractTypeError(contractState, mismatchedCircuitIds);
    }
};
/**
 * Creates an instance of {@link FoundContract} given the address of a deployed contract and an
 * optional private state ID at which an existing private state is stored. When given, the current value
 * at the private state ID is used as the `initialPrivateState` value in the `finalizedDeployTxData`
 * property of the returned `FoundContract`.
 *
 * @param providers The providers used to manage transaction lifecycles.
 * @param options Configuration.
 *
 * @throws Error Improper `privateStateId` and `initialPrivateState` configuration.
 * @throws Error No contract state could be found at `contractAddress`.
 * @throws TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.
 * @throws ContractTypeError One or more circuits defined on `contract` are undefined on the contract
 *                           state found at `contractAddress`, or have mis-matched verifier keys.
 * @throws IncompleteFindContractPrivateStateConfig If an `initialPrivateState` is given but no
 *                                                  `privateStateId` is given to store it under.
 */
async function findDeployedContract(providers, options) {
    const { compiledContract, contractAddress } = options;
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const finalizedTxData = await providers.publicDataProvider.watchForDeployTxData(contractAddress);
    const initialContractState = await providers.publicDataProvider.queryDeployContractState(contractAddress);
    midnightJsUtils.assertDefined(initialContractState, `No contract deployed at contract address '${contractAddress}'`);
    const currentContractState = await providers.publicDataProvider.queryContractState(contractAddress);
    midnightJsUtils.assertDefined(currentContractState, `No contract deployed at contract address '${contractAddress}'`);
    const verifierKeys = await providers.zkConfigProvider.getVerifierKeys(compactJs.ContractExecutable.make(compiledContract).getImpureCircuitIds());
    verifyContractState(verifierKeys, currentContractState);
    const signingKey = await setOrGetInitialSigningKey(providers.privateStateProvider, options);
    const initialPrivateState = await setOrGetInitialPrivateState(providers.privateStateProvider, options);
    return {
        deployTxData: {
            private: {
                signingKey,
                initialPrivateState
            },
            public: {
                ...finalizedTxData,
                contractAddress,
                initialContractState
            }
        },
        callTx: createCircuitCallTxInterface(providers, compiledContract, contractAddress, 'privateStateId' in options ? options.privateStateId : undefined),
        circuitMaintenanceTx: createCircuitMaintenanceTxInterfaces(providers, compiledContract, contractAddress),
        contractMaintenanceTx: createContractMaintenanceTxInterface(providers, compiledContract, contractAddress)
    };
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Fetches the unshielded balances associated with a specific contract address.
 *
 * @param publicDataProvider The provider to use to fetch the unshielded balances from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
const getUnshieldedBalances = async (publicDataProvider, contractAddress) => {
    midnightJsUtils.assertIsContractAddress(contractAddress);
    const unshieldedBalances = await publicDataProvider.queryUnshieldedBalances(contractAddress);
    midnightJsUtils.assertDefined(unshieldedBalances, `No unshielded balances found at contract address '${contractAddress}'`);
    return unshieldedBalances;
};

exports.CallTxFailedError = CallTxFailedError;
exports.ContractTypeError = ContractTypeError;
exports.DeployTxFailedError = DeployTxFailedError;
exports.IncompleteCallTxPrivateStateConfig = IncompleteCallTxPrivateStateConfig;
exports.IncompleteFindContractPrivateStateConfig = IncompleteFindContractPrivateStateConfig;
exports.InsertVerifierKeyTxFailedError = InsertVerifierKeyTxFailedError;
exports.RemoveVerifierKeyTxFailedError = RemoveVerifierKeyTxFailedError;
exports.ReplaceMaintenanceAuthorityTxFailedError = ReplaceMaintenanceAuthorityTxFailedError;
exports.TxFailedError = TxFailedError;
exports.createCallTxOptions = createCallTxOptions;
exports.createCircuitCallTxInterface = createCircuitCallTxInterface;
exports.createCircuitMaintenanceTxInterface = createCircuitMaintenanceTxInterface;
exports.createCircuitMaintenanceTxInterfaces = createCircuitMaintenanceTxInterfaces;
exports.createContractMaintenanceTxInterface = createContractMaintenanceTxInterface;
exports.createUnprovenCallTx = createUnprovenCallTx;
exports.createUnprovenCallTxFromInitialStates = createUnprovenCallTxFromInitialStates;
exports.createUnprovenDeployTx = createUnprovenDeployTx;
exports.createUnprovenDeployTxFromVerifierKeys = createUnprovenDeployTxFromVerifierKeys;
exports.deployContract = deployContract;
exports.findDeployedContract = findDeployedContract;
exports.getPublicStates = getPublicStates;
exports.getStates = getStates;
exports.getUnshieldedBalances = getUnshieldedBalances;
exports.submitCallTx = submitCallTx;
exports.submitCallTxAsync = submitCallTxAsync;
exports.submitDeployTx = submitDeployTx;
exports.submitInsertVerifierKeyTx = submitInsertVerifierKeyTx;
exports.submitRemoveVerifierKeyTx = submitRemoveVerifierKeyTx;
exports.submitReplaceAuthorityTx = submitReplaceAuthorityTx;
exports.submitTx = submitTx;
exports.submitTxAsync = submitTxAsync;
exports.verifierKeysEqual = verifierKeysEqual;
exports.verifyContractState = verifyContractState;
exports.withContractScopedTransaction = withContractScopedTransaction;
//# sourceMappingURL=index.cjs.map
