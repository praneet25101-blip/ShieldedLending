import { Buffer } from 'buffer';
import { Level } from 'level';
import _ from 'lodash';
import * as superjson from 'superjson';
import { randomBytes, pbkdf2Sync, createCipheriv, createDecipheriv } from 'crypto';

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ALGORITHM = 'aes-256-gcm';
const KEY_LENGTH = 32;
const IV_LENGTH = 12;
const AUTH_TAG_LENGTH = 16;
const SALT_LENGTH = 32;
const PBKDF2_ITERATIONS = 100000;
const ENCRYPTION_VERSION = 1;
const VERSION_PREFIX_LENGTH = 1;
const HEADER_LENGTH = VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH + AUTH_TAG_LENGTH;
class StorageEncryption {
    encryptionKey;
    salt;
    constructor(password, existingSalt) {
        this.salt = existingSalt ?? randomBytes(SALT_LENGTH);
        this.encryptionKey = this.deriveKey(password, this.salt);
    }
    deriveKey(password, salt) {
        return pbkdf2Sync(password, salt, PBKDF2_ITERATIONS, KEY_LENGTH, 'sha256');
    }
    encrypt(data) {
        const plaintext = Buffer.from(data, 'utf-8');
        const iv = randomBytes(IV_LENGTH);
        const cipher = createCipheriv(ALGORITHM, this.encryptionKey, iv);
        const encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);
        const authTag = cipher.getAuthTag();
        const version = Buffer.from([ENCRYPTION_VERSION]);
        const result = Buffer.concat([version, this.salt, iv, authTag, encrypted]);
        return result.toString('base64');
    }
    decrypt(encryptedData) {
        const data = Buffer.from(encryptedData, 'base64');
        if (data.length < HEADER_LENGTH) {
            throw new Error('Invalid encrypted data: too short');
        }
        const version = data[0];
        if (version !== ENCRYPTION_VERSION) {
            throw new Error(`Unsupported encryption version: ${version}`);
        }
        const salt = data.subarray(VERSION_PREFIX_LENGTH, VERSION_PREFIX_LENGTH + SALT_LENGTH);
        const iv = data.subarray(VERSION_PREFIX_LENGTH + SALT_LENGTH, VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH);
        const authTag = data.subarray(VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH, VERSION_PREFIX_LENGTH + SALT_LENGTH + IV_LENGTH + AUTH_TAG_LENGTH);
        const encrypted = data.subarray(HEADER_LENGTH);
        if (!this.salt.equals(salt)) {
            throw new Error('Salt mismatch: data was encrypted with a different password');
        }
        const decipher = createDecipheriv(ALGORITHM, this.encryptionKey, iv);
        decipher.setAuthTag(authTag);
        const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
        return decrypted.toString('utf-8');
    }
    static isEncrypted(data) {
        try {
            const buffer = Buffer.from(data, 'base64');
            return buffer.length >= HEADER_LENGTH && buffer[0] === ENCRYPTION_VERSION;
        }
        catch {
            return false;
        }
    }
    getSalt() {
        return this.salt;
    }
}
const validatePassword = (password) => {
    if (!password) {
        throw new Error('Password is required for private state encryption.\n' +
            'Please provide a password via privateStoragePasswordProvider in the configuration.');
    }
    if (password.length < 16) {
        throw new Error('Password must be at least 16 characters long.\n' +
            'Use a strong, randomly generated password for production.');
    }
};
const getPasswordFromProvider = async (provider) => {
    const password = await provider();
    validatePassword(password);
    return password;
};

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default name of the indexedDB database for Midnight.
 */
const MN_LDB_DEFAULT_DB_NAME = 'midnight-level-db';
/**
 * The default name of the private state store.
 */
const MN_LDB_DEFAULT_PRIS_STORE_NAME = 'private-states';
/**
 * The default name of the signing key store.
 */
const MN_LDB_DEFAULT_KEY_STORE_NAME = 'signing-keys';
/**
 * The default configuration for the level database.
 */
const DEFAULT_CONFIG = {
    /**
     * The name of the database.
     */
    midnightDbName: MN_LDB_DEFAULT_DB_NAME,
    /**
     * The name of the "level" on which to store private state.
     */
    privateStateStoreName: MN_LDB_DEFAULT_PRIS_STORE_NAME,
    /**
     * The name of the "level" on which to store signing keys.
     */
    signingKeyStoreName: MN_LDB_DEFAULT_KEY_STORE_NAME
};
superjson.registerCustom({
    isApplicable: (v) => v instanceof Buffer,
    serialize: (v) => v.toString('hex'),
    deserialize: (v) => Buffer.from(v, 'hex')
}, 'buffer');
const withSubLevel = async (dbName, levelName, thunk) => {
    const level = new Level(dbName, {
        createIfMissing: true
    });
    const subLevel = level.sublevel(levelName, {
        valueEncoding: 'utf-8'
    });
    try {
        await level.open();
        await subLevel.open();
        return await thunk(subLevel);
    }
    finally {
        await subLevel.close();
        await level.close();
    }
};
const METADATA_KEY = '__midnight_encryption_metadata__';
const getOrCreateEncryption = async (dbName, levelName, passwordProvider) => {
    const password = await getPasswordFromProvider(passwordProvider);
    return withSubLevel(dbName, levelName, async (subLevel) => {
        try {
            const metadataJson = await subLevel.get(METADATA_KEY);
            if (!metadataJson) {
                throw new Error('Metadata not found');
            }
            const metadata = JSON.parse(metadataJson);
            const salt = Buffer.from(metadata.salt, 'hex');
            return new StorageEncryption(password, salt);
        }
        catch {
            const encryption = new StorageEncryption(password);
            const metadata = {
                salt: encryption.getSalt().toString('hex'),
                version: 1
            };
            await subLevel.put(METADATA_KEY, JSON.stringify(metadata));
            return encryption;
        }
    });
};
const subLevelMaybeGet = async (dbName, levelName, key, passwordProvider) => {
    const encryption = await getOrCreateEncryption(dbName, levelName, passwordProvider);
    return withSubLevel(dbName, levelName, async (subLevel) => {
        try {
            const encryptedValue = await subLevel.get(key);
            if (encryptedValue === undefined) {
                return null;
            }
            let decryptedValue;
            if (StorageEncryption.isEncrypted(encryptedValue)) {
                decryptedValue = encryption.decrypt(encryptedValue);
            }
            else {
                decryptedValue = encryptedValue;
                const reEncrypted = encryption.encrypt(encryptedValue);
                await subLevel.put(key, reEncrypted);
            }
            const value = superjson.parse(decryptedValue);
            if (value === undefined) {
                return null;
            }
            return value;
        }
        catch (error) {
            if (error && typeof error === 'object' && 'code' in error && error.code === 'LEVEL_NOT_FOUND') {
                return null;
            }
            throw error;
        }
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Constructs an instance of {@link PrivateStateProvider} based on {@link Level} database.
 *
 * @param config Database configuration options.
 */
const levelPrivateStateProvider = (config) => {
    const fullConfig = _.defaults(config, DEFAULT_CONFIG);
    if (config.privateStoragePasswordProvider && config.walletProvider) {
        throw new Error('Cannot provide both privateStoragePasswordProvider and walletProvider.\n' +
            'Provide only one: walletProvider for default behavior, or privateStoragePasswordProvider for custom password.');
    }
    if (!config.privateStoragePasswordProvider && !config.walletProvider) {
        throw new Error('Either privateStoragePasswordProvider or walletProvider must be provided.\n' +
            'Provide walletProvider to use wallet encryption key, or privateStoragePasswordProvider for custom password.');
    }
    const passwordProvider = config.privateStoragePasswordProvider ||
        (() => config.walletProvider.getEncryptionPublicKey());
    return {
        get(privateStateId) {
            return subLevelMaybeGet(fullConfig.midnightDbName, fullConfig.privateStateStoreName, privateStateId, passwordProvider);
        },
        remove(privateStateId) {
            return withSubLevel(fullConfig.midnightDbName, fullConfig.privateStateStoreName, (subLevel) => subLevel.del(privateStateId));
        },
        async set(privateStateId, state) {
            const encryption = await getOrCreateEncryption(fullConfig.midnightDbName, fullConfig.privateStateStoreName, passwordProvider);
            const serialized = superjson.stringify(state);
            const encrypted = encryption.encrypt(serialized);
            return withSubLevel(fullConfig.midnightDbName, fullConfig.privateStateStoreName, (subLevel) => subLevel.put(privateStateId, encrypted));
        },
        clear() {
            return withSubLevel(fullConfig.midnightDbName, fullConfig.privateStateStoreName, (subLevel) => subLevel.clear());
        },
        getSigningKey(address) {
            return subLevelMaybeGet(fullConfig.midnightDbName, fullConfig.signingKeyStoreName, address, passwordProvider);
        },
        removeSigningKey(address) {
            return withSubLevel(fullConfig.midnightDbName, fullConfig.signingKeyStoreName, (subLevel) => subLevel.del(address));
        },
        async setSigningKey(address, signingKey) {
            const encryption = await getOrCreateEncryption(fullConfig.midnightDbName, fullConfig.signingKeyStoreName, passwordProvider);
            const serialized = superjson.stringify(signingKey);
            const encrypted = encryption.encrypt(serialized);
            return withSubLevel(fullConfig.midnightDbName, fullConfig.signingKeyStoreName, (subLevel) => subLevel.put(address, encrypted));
        },
        clearSigningKeys() {
            return withSubLevel(fullConfig.midnightDbName, fullConfig.signingKeyStoreName, (subLevel) => subLevel.clear());
        }
    };
};

export { DEFAULT_CONFIG, StorageEncryption, levelPrivateStateProvider };
//# sourceMappingURL=index.mjs.map
