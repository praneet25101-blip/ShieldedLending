'use strict';

var effect$1 = require('@midnight-ntwrk/compact-js/effect');
var platformJs = require('@midnight-ntwrk/platform-js');
var Configuration = require('@midnight-ntwrk/platform-js/effect/Configuration');
var effect = require('effect');
var ledgerV7 = require('@midnight-ntwrk/ledger-v7');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var Configuration__namespace = /*#__PURE__*/_interopNamespaceDefault(Configuration);

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a ZK configuration reader by adapting a given {@link ZKConfigProvider}.
 *
 * @param zkConfigProvider The {@link ZKConfigProvider} that is to be adapted.
 * @returns A {@link ZKConfiguration.ZKConfiguration.Reader | ZKConfiguration.Reader} that reads from
 * `zkConfigProvider`.
 *
 * @internal
 */
const makeAdaptedReader = (zkConfigProvider) => (compiledContract) => effect.Effect.gen(function* () {
    // TODO: Consider implementing the logic used in Compact.js (look at the contract manifest to determine
    // if the circuit is verifiable). See PM-21376.
    const getVerifierKey = (impureCircuitId) => effect.Effect.tryPromise({
        try: () => zkConfigProvider.getVerifierKey(impureCircuitId).then((verifierKey) => effect.Option.some(effect$1.Contract.VerifierKey(verifierKey))),
        catch: (err) => effect$1.ZKConfigurationReadError.make(compiledContract.tag, impureCircuitId, 'verifier-key', err)
    });
    return {
        getVerifierKey,
        getVerifierKeys: (impureCircuitIds) => effect.Effect.forEach(impureCircuitIds, (impureCircuitId) => getVerifierKey(impureCircuitId).pipe(effect.Effect.map((verifierKey) => [impureCircuitId, verifierKey])), { concurrency: 'unbounded', discard: false })
    };
});
const makeAdaptedRuntimeLayer = (zkConfigProvider, configMap) => effect.Layer.mergeAll(effect.Layer.succeed(effect$1.ZKConfiguration.ZKConfiguration, effect$1.ZKConfiguration.ZKConfiguration.of({
    createReader: makeAdaptedReader(zkConfigProvider)
})), Configuration__namespace.layer).pipe(effect.Layer.provide(effect.Layer.setConfigProvider(effect.ConfigProvider.fromMap(configMap, { pathDelim: '_' }).pipe(effect.ConfigProvider.constantCase))));
/**
 * Constructs an Effect managed runtime configured to execute contract executables.
 *
 * @param zkConfigProvider The {@link ZKConfigProvider} that is to be adapted.
 * @param options Values that will be mapped into and made available within the constructed runtime.
 * @returns An Effect {@link ManagedRuntime} that can be used to execute {@link ContractExecutable} instances.
 */
const makeContractExecutableRuntime = (zkConfigProvider, options) => {
    let config = [['KEYS_COIN_PUBLIC', options.coinPublicKey]];
    if (options.signingKey) {
        config = config.concat([['KEYS_SIGNING', options.signingKey]]);
    }
    return effect$1.ContractExecutableRuntime.make(makeAdaptedRuntimeLayer(zkConfigProvider, new Map(config)));
};
/**
 * Unwraps an Effect `Exit` instance, returning its value if it is successful, or throwing the error contained
 * within it.
 *
 * @param exit The source Effect `Exit` instance.
 * @returns The value from `exit` if it is successful, otherwise throws the error contained within it.
 */
const exitResultOrError = (exit) => effect.Exit.match(exit, {
    onSuccess: (a) => a,
    onFailure: (cause) => {
        if (effect.Cause.isFailType(cause))
            throw cause.error;
        throw new Error(`Unexpected error: ${effect.Cause.pretty(cause)}`);
    }
});
/**
 * Wraps an object into an `Option.some`.
 *
 * @param obj The value that should be wrapped into an `Option`.
 * @returns An `Option.some` for `obj`.
 */
const asEffectOption = (obj) => {
    return effect.Option.some(obj);
};
/**
 * Constructs a branded contract address from a given string value.
 *
 * @param address A string value representing a contract address.
 * @returns A {@link ContractAddress.ContractAddress | ContractAddress} constructed from `address`.
 */
const asContractAddress = (address) => platformJs.ContractAddress.ContractAddress(address);

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An error describing an invalid protocol scheme.
 */
class InvalidProtocolSchemeError extends Error {
    invalidScheme;
    allowableSchemes;
    /**
     * @param invalidScheme The invalid scheme.
     * @param allowableSchemes The valid schemes that are allowed.
     */
    constructor(invalidScheme, allowableSchemes) {
        super(`Invalid protocol scheme: '${invalidScheme}'. Allowable schemes are one of: ${allowableSchemes.join(',')}`);
        this.invalidScheme = invalidScheme;
        this.allowableSchemes = allowableSchemes;
    }
}

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A valid named log level.
 */
exports.LogLevel = void 0;
(function (LogLevel) {
    /**
     * Log levels typically used by DAapp developers.
     */
    LogLevel["INFO"] = "info";
    LogLevel["WARN"] = "warn";
    LogLevel["ERROR"] = "error";
    LogLevel["FATAL"] = "fatal";
    /**
     * Log levels used by Midnight.JS to report internal state.
     */
    LogLevel["DEBUG"] = "debug";
    LogLevel["TRACE"] = "trace";
})(exports.LogLevel || (exports.LogLevel = {}));

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**

 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
const createProverKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
const createVerifierKey = (uint8Array) => {
    return uint8Array;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
const createZKIR = (uint8Array) => {
    return uint8Array;
};
/**
 * Converts a ZKConfig object to ProvingKeyMaterial format.
 * @param zkConfig
 */
const zkConfigToProvingKeyMaterial = (zkConfig) => {
    return {
        proverKey: zkConfig.proverKey,
        verifierKey: zkConfig.verifierKey,
        ir: zkConfig.zkir,
    };
};
/**
 * Indicates that the segment update is invalid.
 */
const SegmentFail = 'SegmentFail';
/**
 * Indicates that the segment is valid.
 */
const SegmentSuccess = 'SegmentSuccess';
/**
 * Indicates that the transaction is invalid.
 */
const FailEntirely = 'FailEntirely';
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
const FailFallible = 'FailFallible';
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
const SucceedEntirely = 'SucceedEntirely';

/*
 * This file is part of midnight-js.
 * Copyright (C) 2025 Midnight Foundation
 * SPDX-License-Identifier: Apache-2.0
 * Licensed under the Apache License, Version 2.0 (the "License");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
 * three are used by the {@link ProofProvider} to create a proof for a call transaction. The implementation
 * of this provider depends on the runtime environment, since each environment has different conventions
 * for accessing static artifacts.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
class ZKConfigProvider {
    /**
     * Retrieves the verifier keys produced by `compact` compiler for the given circuits.
     * @param circuitIds The circuit IDs of the verifier keys to retrieve.
     */
    async getVerifierKeys(circuitIds) {
        return Promise.all(circuitIds.map(async (id) => {
            const key = await this.getVerifierKey(id);
            return [id, key];
        }));
    }
    /**
     * Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.
     * @param circuitId The circuit ID of the artifacts to retrieve.
     */
    async get(circuitId) {
        return {
            circuitId,
            proverKey: await this.getProverKey(circuitId),
            verifierKey: await this.getVerifierKey(circuitId),
            zkir: await this.getZKIR(circuitId)
        };
    }
    asKeyMaterialProvider() {
        return this;
    }
}

Object.defineProperty(exports, "Transaction", {
    enumerable: true,
    get: function () { return ledgerV7.Transaction; }
});
exports.FailEntirely = FailEntirely;
exports.FailFallible = FailFallible;
exports.InvalidProtocolSchemeError = InvalidProtocolSchemeError;
exports.SegmentFail = SegmentFail;
exports.SegmentSuccess = SegmentSuccess;
exports.SucceedEntirely = SucceedEntirely;
exports.ZKConfigProvider = ZKConfigProvider;
exports.asContractAddress = asContractAddress;
exports.asEffectOption = asEffectOption;
exports.createProverKey = createProverKey;
exports.createVerifierKey = createVerifierKey;
exports.createZKIR = createZKIR;
exports.exitResultOrError = exitResultOrError;
exports.makeContractExecutableRuntime = makeContractExecutableRuntime;
exports.zkConfigToProvingKeyMaterial = zkConfigToProvingKeyMaterial;
//# sourceMappingURL=index.cjs.map
