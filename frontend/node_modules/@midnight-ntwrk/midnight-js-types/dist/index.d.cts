import { ContractExecutable } from '@midnight-ntwrk/compact-js/effect';
import { ContractAddress as ContractAddress$1 } from '@midnight-ntwrk/platform-js';
import { ConfigError, Exit, Option } from 'effect';
import { ManagedRuntime } from 'effect/ManagedRuntime';
import { ContractAddress, IntentHash, RawTokenType, Transaction, SignatureEnabled, Proof, Binding, TransactionId, TransactionHash, FinalizedTransaction, PreBinding, UnprovenTransaction, ZswapChainState, CoinPublicKey, EncPublicKey } from '@midnight-ntwrk/ledger-v7';
export { Transaction } from '@midnight-ntwrk/ledger-v7';
import { LogFn } from 'pino';
import { ContractAddress as ContractAddress$2, SigningKey, ContractState } from '@midnight-ntwrk/compact-runtime';
import { Contract } from '@midnight-ntwrk/compact-js';
import { Observable } from 'rxjs';

/**
 * A type representing a prover key derived from a contract circuit.
 */
type ProverKey = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly ProverKey: unique symbol;
};
/**

 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
declare const createProverKey: (uint8Array: Uint8Array) => ProverKey;
/**
 * A type representing a verifier key derived from a contract circuit.
 */
type VerifierKey = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly VerifierKey: unique symbol;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
declare const createVerifierKey: (uint8Array: Uint8Array) => VerifierKey;
/**
 * A type representing a zero-knowledge circuit intermediate representation derived from a contract circuit.
 */
type ZKIR = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly ZKIR: unique symbol;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
declare const createZKIR: (uint8Array: Uint8Array) => ZKIR;
/**
 * Contains all information required by the {@link ProofProvider}
 * @typeParam K - The type of the circuit ID.
 */
interface ZKConfig<K extends string> {
    /**
     * A circuit identifier.
     */
    readonly circuitId: K;
    /**
     * The prover key corresponding to {@link ZKConfig.circuitId}.
     */
    readonly proverKey: ProverKey;
    /**
     * The verifier key corresponding to {@link ZKConfig.circuitId}.
     */
    readonly verifierKey: VerifierKey;
    /**
     * The zero-knowledge intermediate representation corresponding to {@link ZKConfig.circuitId}.
     */
    readonly zkir: ZKIR;
}
/**
 * Converts a ZKConfig object to ProvingKeyMaterial format.
 * @param zkConfig
 */
declare const zkConfigToProvingKeyMaterial: <K extends string>(zkConfig: ZKConfig<K>) => {
    proverKey: ProverKey;
    verifierKey: VerifierKey;
    ir: ZKIR;
};
/**
 * Indicates that the segment update is invalid.
 */
declare const SegmentFail: "SegmentFail";
/**
 * Indicates that the segment is valid.
 */
declare const SegmentSuccess: "SegmentSuccess";
/**
 * Represents the result of a segment operation, which can either be a successful operation
 * (`SegmentSuccess`) or a failed operation (`SegmentFail`).
 */
type SegmentStatus = typeof SegmentSuccess | typeof SegmentFail;
/**
 * Indicates that the transaction is invalid.
 */
declare const FailEntirely: "FailEntirely";
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
declare const FailFallible: "FailFallible";
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
declare const SucceedEntirely: "SucceedEntirely";
/**
 * The status of a transaction.
 */
type TxStatus = typeof FailEntirely | typeof FailFallible | typeof SucceedEntirely;
/**
 * Represents an unshielded UTXO (Unspent Transaction Output).
 * Unshielded UTXOs are outputs that have not been shielded or encrypted, making them visible on the public ledger.
 */
type UnshieldedUtxo = {
    /**
     * The unique identifier of the unshielded UTXO.
     */
    readonly owner: ContractAddress;
    /**
     * The identifier of the intent associated with the unshielded UTXO.
     * This is used to track the intent behind the creation or use of the UTXO.
     */
    readonly intentHash: IntentHash;
    /**
     * The type of token associated with the unshielded UTXO.
     * This indicates the kind of asset or currency represented by the UTXO.
     */
    readonly tokenType: RawTokenType;
    /**
     * The value of the unshielded UTXO, represented as a bigint.
     */
    readonly value: bigint;
};
/**
 * Represents a collection of unshielded UTXOs, which are unspent transaction outputs that are not shielded.
 * This type is used to manage and track the state of unshielded UTXOs.
 */
type UnshieldedUtxos = {
    /**
     * Represents the unshielded UTXOs that have been created but not yet spent.
     */
    readonly created: readonly UnshieldedUtxo[];
    /**
     * Represents the unshielded UTXOs that have been spent.
     */
    readonly spent: readonly UnshieldedUtxo[];
};
/**
 * Represents the fees associated with a particular entity or operation.
 *
 * This type includes both the paid fees and the estimated fees. The paid fees represent
 * the amount that has already been settled, while the estimated fees provide a calculation
 * or projection of expected fees.
 */
type Fees = {
    /**
     * The fees that have already been paid.
     */
    readonly paidFees: string;
    /**
     * The estimated fees that are expected to be incurred.
     */
    readonly estimatedFees: string;
};
/**
 * Block identifier
 */
type BlockHash = string;
/**
 * Data for any finalized transaction.
 */
interface FinalizedTxData {
    /**
     * The transaction that was finalized.
     */
    readonly tx: Transaction<SignatureEnabled, Proof, Binding>;
    /**
     * The status of a submitted transaction.
     */
    readonly status: TxStatus;
    /**
     * One of the transaction ID of the submitted transaction.
     */
    readonly txId: TransactionId;
    /**
     * All transaction IDs of the submitted transaction.
     */
    readonly identifiers: readonly TransactionId[];
    /**
     * The transaction hash of the transaction in which the original transaction was included.
     */
    readonly txHash: TransactionHash;
    /**
     * The block hash of the block in which the transaction was included.
     */
    readonly blockHash: BlockHash;
    /**
     * The block height of the block in which the transaction was included.
     */
    readonly blockHeight: number;
    /**
     * The timestamp of the block in which the transaction was included.
     */
    readonly blockTimestamp: number;
    /**
     * The author of the block in which the transaction was included.
     */
    readonly blockAuthor: string | null;
    /**
     * The indexer internal db ID.
     */
    readonly indexerId: number;
    /**
     * The protocol version of the transaction.
     */
    readonly protocolVersion: number;
    /**
     * The fees associated with the transaction, including both paid and estimated fees.
     */
    readonly fees: Fees;
    /**
     * The map that associates segment identifiers (numbers) with their corresponding status {@link SegmentStatus}.
     * The segment identifier is represented as a number (key in the map), and the status indicates the success or failure of the transaction update.
     */
    readonly segmentStatusMap: Map<number, SegmentStatus> | undefined;
    /**
     * Represents the unshielded outputs, typically used for transactions or operations
     * involving data or values that are not encrypted or concealed.
     */
    readonly unshielded: UnshieldedUtxos;
}
/**
 * Represents an unshielded balance, which is a balance that is not shielded or encrypted.
 * This type is used to track the available funds in an account that are visible on the public ledger.
 */
type UnshieldedBalance = {
    /**
     * Represents the current number of funds available or held in an account.
     */
    readonly balance: bigint;
    /**
     * Represents the type of token in the system.
     */
    readonly tokenType: RawTokenType;
};
/**
 * Represents a collection of unshielded balances, which are balances that are not shielded or encrypted.
 */
type UnshieldedBalances = UnshieldedBalance[];

/**
 * DApp connector API type for key material retrieval
 **/
type KeyMaterialProvider = {
    getZKIR(circuitKeyLocation: string): Promise<Uint8Array>;
    getProverKey(circuitKeyLocation: string): Promise<Uint8Array>;
    getVerifierKey(circuitKeyLocation: string): Promise<Uint8Array>;
};
/**
 * A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
 * three are used by the {@link ProofProvider} to create a proof for a call transaction. The implementation
 * of this provider depends on the runtime environment, since each environment has different conventions
 * for accessing static artifacts.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
declare abstract class ZKConfigProvider<K extends string> {
    /**
     * Retrieves the zero-knowledge intermediate representation produced by `compact` compiler for the given circuit.
     * @param circuitId The circuit ID of the ZKIR to retrieve.
     */
    abstract getZKIR(circuitId: K): Promise<ZKIR>;
    /**
     * Retrieves the prover key produced by `compact` compiler for the given circuit.
     * @param circuitId The circuit ID of the prover key to retrieve.
     */
    abstract getProverKey(circuitId: K): Promise<ProverKey>;
    /**
     * Retrieves the verifier key produced by `compact` compiler for the given circuit.
     * @param circuitId The circuit ID of the verifier key to retrieve.
     */
    abstract getVerifierKey(circuitId: K): Promise<VerifierKey>;
    /**
     * Retrieves the verifier keys produced by `compact` compiler for the given circuits.
     * @param circuitIds The circuit IDs of the verifier keys to retrieve.
     */
    getVerifierKeys(circuitIds: K[]): Promise<[K, VerifierKey][]>;
    /**
     * Retrieves all zero-knowledge artifacts produced by `compact` compiler for the given circuit.
     * @param circuitId The circuit ID of the artifacts to retrieve.
     */
    get(circuitId: K): Promise<ZKConfig<K>>;
    asKeyMaterialProvider(): KeyMaterialProvider;
}

/**
 * Options for use when constructing a Compact.js contract executable runtime.
 */
type ContractExecutableRuntimeOptions = {
    /** The current user's ZSwap public key. */
    readonly coinPublicKey: string;
    /** The signing key to add as the to-be-deployed contract's maintenance authority. */
    readonly signingKey?: string;
};
/**
 * Constructs an Effect managed runtime configured to execute contract executables.
 *
 * @param zkConfigProvider The {@link ZKConfigProvider} that is to be adapted.
 * @param options Values that will be mapped into and made available within the constructed runtime.
 * @returns An Effect {@link ManagedRuntime} that can be used to execute {@link ContractExecutable} instances.
 */
declare const makeContractExecutableRuntime: (zkConfigProvider: ZKConfigProvider<string>, options: ContractExecutableRuntimeOptions) => ManagedRuntime<ContractExecutable.ContractExecutable.Context, ConfigError.ConfigError>;
/**
 * Unwraps an Effect `Exit` instance, returning its value if it is successful, or throwing the error contained
 * within it.
 *
 * @param exit The source Effect `Exit` instance.
 * @returns The value from `exit` if it is successful, otherwise throws the error contained within it.
 */
declare const exitResultOrError: <A, E>(exit: Exit.Exit<A, E>) => A;
/**
 * Wraps an object into an `Option.some`.
 *
 * @param obj The value that should be wrapped into an `Option`.
 * @returns An `Option.some` for `obj`.
 */
declare const asEffectOption: <T>(obj: unknown) => Option.Option<T>;
/**
 * Constructs a branded contract address from a given string value.
 *
 * @param address A string value representing a contract address.
 * @returns A {@link ContractAddress.ContractAddress | ContractAddress} constructed from `address`.
 */
declare const asContractAddress: (address: string) => ContractAddress$1.ContractAddress;

/**
 * An error describing an invalid protocol scheme.
 */
declare class InvalidProtocolSchemeError extends Error {
    readonly invalidScheme: string;
    readonly allowableSchemes: string[];
    /**
     * @param invalidScheme The invalid scheme.
     * @param allowableSchemes The valid schemes that are allowed.
     */
    constructor(invalidScheme: string, allowableSchemes: string[]);
}

/**
 * A valid named log level.
 */
declare enum LogLevel {
    /**
     * Log levels typically used by DAapp developers.
     */
    INFO = "info",
    WARN = "warn",
    ERROR = "error",
    FATAL = "fatal",
    /**
     * Log levels used by Midnight.JS to report internal state.
     */
    DEBUG = "debug",
    TRACE = "trace"
}
/**
 * A provider for logging functions.
 */
interface LoggerProvider {
    info?: LogFn;
    warn?: LogFn;
    error?: LogFn;
    debug?: LogFn;
    fatal?: LogFn;
    isLevelEnabled(level: LogLevel): boolean;
}

/**
 * Interface for Midnight transaction submission logic. It could be implemented, e.g., by a wallet,
 * a third-party service, or a node itself.
 */
interface MidnightProvider {
    /**
     * Submit a transaction to the network to be consensed upon.
     * @param tx The finalized transaction to submit.
     * @returns The transaction identifier of the submitted transaction.
     */
    submitTx(tx: FinalizedTransaction): Promise<TransactionId>;
}

/**
 * A type representing an ID used to store a contract's private state.
 */
type PrivateStateId = string;
/**
 * Interface for a typed key-valued store containing contract private states.
 *
 * @typeParam PSI - Parameter indicating the private state ID, sometimes a union of string literals.
 * @typeParam PS - Parameter indicating the private state type stored, sometimes a union of private state types.
 */
interface PrivateStateProvider<PSI extends PrivateStateId = PrivateStateId, PS = any> {
    /**
     * Store the given private state at the given private state ID.
     *
     * @param privateStateId The private state identifier.
     * @param state The private state to store.
     */
    set(privateStateId: PSI, state: PS): Promise<void>;
    /**
     * Retrieve the private state at the given private state ID.
     *
     * @param privateStateId The private state identifier.
     */
    get(privateStateId: PSI): Promise<PS | null>;
    /**
     * Remove the value at the given private state ID.
     *
     * @param privateStateId The private state identifier.
     */
    remove(privateStateId: PSI): Promise<void>;
    /**
     * Remove all contract private states.
     */
    clear(): Promise<void>;
    /**
     * Store the given signing key at the given address.
     *
     * @param address The address of the contract having the given signing key.
     * @param signingKey The signing key to store.
     */
    setSigningKey(address: ContractAddress$2, signingKey: SigningKey): Promise<void>;
    /**
     * Retrieve the signing key for a contract.
     *
     * @param address The address of the contract for which to get the signing key.
     */
    getSigningKey(address: ContractAddress$2): Promise<SigningKey | null>;
    /**
     * Remove the signing key for a contract.
     *
     * @param address The address of the contract for which to delete the signing key.
     */
    removeSigningKey(address: ContractAddress$2): Promise<void>;
    /**
     * Remove all contract signing keys.
     */
    clearSigningKeys(): Promise<void>;
}

type UnboundTransaction = Transaction<SignatureEnabled, Proof, PreBinding>;
/**
 * The configuration for the proof request to the proof provider.
 */
interface ProveTxConfig {
    /**
     * The timeout for the request.
     */
    readonly timeout?: number;
}
/**
 * Interface for a proof server running in a trusted environment.
 * @typeParam K - The type of the circuit ID used by the provider.
 */
interface ProofProvider {
    /**
     * Creates call proofs for an unproven transaction. The resulting transaction is unbalanced and
     * must be balanced using the {@link WalletProvider} interface.
     *           contain a single contract call.
     * @param unprovenTx
     * @param proveTxConfig The configuration for the proof request to the proof provider. Empty in case
     *                      a deploy transaction is being proved with no user-defined timeout.
     */
    proveTx(unprovenTx: UnprovenTransaction, proveTxConfig?: ProveTxConfig): Promise<UnboundTransaction>;
}

/**
 * Streams all previous states of a contract.
 */
type All = {
    readonly type: 'all';
};
/**
 * Streams all states of a contract starting with the most recent.
 */
type Latest = {
    readonly type: 'latest';
};
/**
 * Starts a contract state stream at the given transaction identifier.
 */
type TxIdConfig = {
    readonly type: 'txId';
    /**
     * The transaction identifier indicating where to begin the state stream.
     */
    readonly txId: TransactionId;
};
/**
 * Starts a contract state stream at the given block height.
 * @type
 */
type BlockHeightConfig = {
    readonly type: 'blockHeight';
    /**
     * The block height indicating where to begin the state stream.
     */
    readonly blockHeight: number;
};
/**
 * Starts a contract state stream at the given block hash.
 */
type BlockHashConfig = {
    readonly type: 'blockHash';
    /**
     * The block height indicating where to begin the state stream.
     */
    readonly blockHash: string;
};
/**
 * The configuration for a contract state observable. The corresponding observables may begin at different
 * places (e.g. after a specific transaction identifier / block height) depending on the configuration, but
 * all state updates after the beginning are always included.
 */
type ContractStateObservableConfig = ((TxIdConfig | BlockHashConfig | BlockHeightConfig) & {
    /**
     * If `true`, the state of the contract after the last block or transaction specified by the configuration
     * is the first value emitted. If `false`, the state of the contract after the next state update is the
     * first value emitted. If `undefined`, defaults to `true`.
     */
    readonly inclusive?: boolean;
}) | Latest | All;
/**
 * Interface for a public data service. This service retrieves public data from the blockchain.
 * TODO: Add timeouts or retry limits to 'watchFor' queries.
 */
interface PublicDataProvider {
    /**
     * Retrieves the on-chain state of a contract. If no block hash or block height are provided, the
     * contract state at the address in the latest block is returned.
     * Immediately returns null if no matching data is found.
     * @param contractAddress The address of the contract of interest.
     * @param config The configuration of the query.
     *               If `undefined` returns the latest states.
     */
    queryContractState(contractAddress: ContractAddress, config?: BlockHeightConfig | BlockHashConfig): Promise<ContractState | null>;
    /**
     * Retrieves the zswap chain state (token balances) and the contract state of the contract at the
     * given address. Both states are retrieved in a single query to ensure consistency between the two.
     * Immediately returns null if no matching data is found.
     * @param contractAddress The address of the contract of interest.
     * @param config The configuration of the query.
     *               If `undefined` returns the latest states.
     */
    queryZSwapAndContractState(contractAddress: ContractAddress, config?: BlockHeightConfig | BlockHashConfig): Promise<[ZswapChainState, ContractState] | null>;
    /**
     * Retrieves the contract state included in the deployment of the contract at the given contract address.
     * Immediately returns null if no matching data is found.
     * @param contractAddress The address of the contract of interest.
     */
    queryDeployContractState(contractAddress: ContractAddress): Promise<ContractState | null>;
    /**
     * Retrieves the unshielded balances associated with a specific contract address.
     * @param contractAddress The address of the contract of interest.
     * @param config The configuration of the query.
     *               If `undefined` returns the latest states.
     */
    queryUnshieldedBalances(contractAddress: ContractAddress, config?: BlockHeightConfig | BlockHashConfig): Promise<UnshieldedBalances | null>;
    /**
     * Retrieves the contract state of the contract with the given address.
     * Waits indefinitely for matching data to appear.
     * @param contractAddress The address of the contract of interest.
     */
    watchForContractState(contractAddress: ContractAddress): Promise<ContractState>;
    /**
     * Monitors for any unshielded balances associated with a specific contract address.
     *
     * @param {ContractAddress} contractAddress - The address of the contract to monitor for unshielded balances.
     * @return {Promise<UnshieldedBalances>} A promise that resolves to the detected unshielded balances.
     */
    watchForUnshieldedBalances(contractAddress: ContractAddress): Promise<UnshieldedBalances>;
    /**
     * Retrieves data of the deployment transaction for the contract at the given contract address.
     *
     * **IMPORTANT: This method waits indefinitely** until the deployment transaction appears on the
     * blockchain. It will never timeout or reject unless an error occurs.
     *
     * Custom implementations MUST maintain this indefinite waiting behavior to ensure consistency
     * across all PublicDataProvider implementations. Do not implement timeouts in this method.
     *
     * @param contractAddress The address of the contract of interest.
     *
     * @returns A promise that resolves with finalized transaction data when the deployment appears on-chain.
     *          The promise never rejects due to timeout.
     */
    watchForDeployTxData(contractAddress: ContractAddress): Promise<FinalizedTxData>;
    /**
     * Retrieves data of the transaction containing the call or deployment with the given identifier.
     *
     * **IMPORTANT: This method waits indefinitely** until the transaction appears on the blockchain.
     * It will never timeout or reject unless an error occurs.
     *
     * Custom implementations MUST maintain this indefinite waiting behavior to ensure consistency
     * across all PublicDataProvider implementations. Do not implement timeouts in this method.
     *
     * Applications using this method should be aware that:
     * - The promise will not resolve until the transaction appears on-chain
     * - If a transaction is invalid and never appears, this will never return
     * - Consider using application-level timeouts or cancellation mechanisms if needed
     *
     * @param txId The identifier of the call or deployment of interest.
     *
     * @returns A promise that resolves with finalized transaction data when the transaction appears on-chain.
     *          The promise never rejects due to timeout.
     */
    watchForTxData(txId: TransactionId): Promise<FinalizedTxData>;
    /**
     * Creates a stream of contract states. The observable emits a value every time a state is either
     * created or updated at the given address.
     * Waits indefinitely for matching data to appear.
     * @param address The address of the contract of interest.
     * @param config The configuration for the observable.
     */
    contractStateObservable(address: ContractAddress, config: ContractStateObservableConfig): Observable<ContractState>;
    /**
     * Retrieves an observable that tracks the unshielded balances for a specific contract address.
     *
     * @param {ContractAddress} address - The contract address for which unshielded balances are being observed.
     * @param {ContractStateObservableConfig} config - The configuration object for observing contract state changes.
     * @return {Observable<UnshieldedBalances>} An observable that emits the unshielded balances for the provided address.
     */
    unshieldedBalancesObservable(address: ContractAddress, config: ContractStateObservableConfig): Observable<UnshieldedBalances>;
}

/**
 * Interface representing a WalletProvider that handles operations such as
 * transaction balancing and finalization, and provides access to cryptographic secret keys.
 */
interface WalletProvider {
    /**
     * Balances a transaction
     * @param tx The transaction to balance.
     * @param ttl
     */
    balanceTx(tx: UnboundTransaction, ttl?: Date): Promise<FinalizedTransaction>;
    getCoinPublicKey(): CoinPublicKey;
    getEncryptionPublicKey(): EncPublicKey;
}

/**
 * Set of providers needed for transaction construction and submission.
 *
 * @typeParam ICK - A union of string literal types representing the callable circuits.
 * @typeParam PSI - Parameter indicating the private state ID, sometimes a union of string literals.
 * @typeParam PS - Parameter indicating the private state type stored, sometimes a union of private state types.
 */
interface MidnightProviders<ICK extends Contract.ImpureCircuitId<Contract.Any> = Contract.ImpureCircuitId<Contract.Any>, PSI extends PrivateStateId = PrivateStateId, PS = any> {
    /**
     * Manages the private state of a contract.
     */
    readonly privateStateProvider: PrivateStateProvider<PSI, PS>;
    /**
     * Retrieves public data from the blockchain.
     */
    readonly publicDataProvider: PublicDataProvider;
    /**
     * Retrieves the ZK artifacts of a contract needed to create proofs.
     */
    readonly zkConfigProvider: ZKConfigProvider<ICK>;
    /**
     * Creates proven, unbalanced transactions.
     */
    readonly proofProvider: ProofProvider;
    /**
     * Creates proven, balanced transactions.
     */
    readonly walletProvider: WalletProvider;
    /**
     * Submits proven, balanced transactions to the network.
     */
    readonly midnightProvider: MidnightProvider;
    /**
     * An optional logger that provides utilities for logging at given levels.
     */
    readonly loggerProvider?: LoggerProvider;
}

export { FailEntirely, FailFallible, InvalidProtocolSchemeError, LogLevel, SegmentFail, SegmentSuccess, SucceedEntirely, ZKConfigProvider, asContractAddress, asEffectOption, createProverKey, createVerifierKey, createZKIR, exitResultOrError, makeContractExecutableRuntime, zkConfigToProvingKeyMaterial };
export type { All, BlockHash, BlockHashConfig, BlockHeightConfig, ContractExecutableRuntimeOptions, ContractStateObservableConfig, Fees, FinalizedTxData, KeyMaterialProvider, Latest, LoggerProvider, MidnightProvider, MidnightProviders, PrivateStateId, PrivateStateProvider, ProofProvider, ProveTxConfig, ProverKey, PublicDataProvider, SegmentStatus, TxIdConfig, TxStatus, UnboundTransaction, UnshieldedBalance, UnshieldedBalances, UnshieldedUtxo, UnshieldedUtxos, VerifierKey, WalletProvider, ZKConfig, ZKIR };
