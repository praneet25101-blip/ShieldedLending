import { type Binding, type ContractAddress, type IntentHash, type Proof, type RawTokenType, type SignatureEnabled, type Transaction, type TransactionHash, type TransactionId } from '@midnight-ntwrk/ledger-v7';
/**
 * A type representing a prover key derived from a contract circuit.
 */
export type ProverKey = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly ProverKey: unique symbol;
};
/**

 * Creates a branded prover key representation from a prover key binary.
 *
 * @param uint8Array The prover key binary.
 */
export declare const createProverKey: (uint8Array: Uint8Array) => ProverKey;
/**
 * A type representing a verifier key derived from a contract circuit.
 */
export type VerifierKey = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly VerifierKey: unique symbol;
};
/**
 * Creates a branded verifier key representation from a verifier key binary.
 *
 * @param uint8Array The verifier key binary.
 */
export declare const createVerifierKey: (uint8Array: Uint8Array) => VerifierKey;
/**
 * A type representing a zero-knowledge circuit intermediate representation derived from a contract circuit.
 */
export type ZKIR = Uint8Array & {
    /**
     * Unique symbol brand.
     */
    readonly ZKIR: unique symbol;
};
/**
 * Creates a branded ZKIR representation from a ZKIR binary.
 *
 * @param uint8Array The ZKIR binary.
 */
export declare const createZKIR: (uint8Array: Uint8Array) => ZKIR;
/**
 * Contains all information required by the {@link ProofProvider}
 * @typeParam K - The type of the circuit ID.
 */
export interface ZKConfig<K extends string> {
    /**
     * A circuit identifier.
     */
    readonly circuitId: K;
    /**
     * The prover key corresponding to {@link ZKConfig.circuitId}.
     */
    readonly proverKey: ProverKey;
    /**
     * The verifier key corresponding to {@link ZKConfig.circuitId}.
     */
    readonly verifierKey: VerifierKey;
    /**
     * The zero-knowledge intermediate representation corresponding to {@link ZKConfig.circuitId}.
     */
    readonly zkir: ZKIR;
}
/**
 * Converts a ZKConfig object to ProvingKeyMaterial format.
 * @param zkConfig
 */
export declare const zkConfigToProvingKeyMaterial: <K extends string>(zkConfig: ZKConfig<K>) => {
    proverKey: ProverKey;
    verifierKey: VerifierKey;
    ir: ZKIR;
};
/**
 * Indicates that the segment update is invalid.
 */
export declare const SegmentFail: "SegmentFail";
/**
 * Indicates that the segment is valid.
 */
export declare const SegmentSuccess: "SegmentSuccess";
/**
 * Represents the result of a segment operation, which can either be a successful operation
 * (`SegmentSuccess`) or a failed operation (`SegmentFail`).
 */
export type SegmentStatus = typeof SegmentSuccess | typeof SegmentFail;
/**
 * Indicates that the transaction is invalid.
 */
export declare const FailEntirely: "FailEntirely";
/**
 * Indicates that the transaction is valid but the portion of the transcript
 * that is allowed to fail (the portion after a checkpoint) did fail. All effects
 * from the guaranteed part of the transaction are kept but the effects from the
 * fallible part of the transaction are discarded.
 */
export declare const FailFallible: "FailFallible";
/**
 * Indicates that the guaranteed and fallible portions of the transaction were
 * successful.
 */
export declare const SucceedEntirely: "SucceedEntirely";
/**
 * The status of a transaction.
 */
export type TxStatus = typeof FailEntirely | typeof FailFallible | typeof SucceedEntirely;
/**
 * Represents an unshielded UTXO (Unspent Transaction Output).
 * Unshielded UTXOs are outputs that have not been shielded or encrypted, making them visible on the public ledger.
 */
export type UnshieldedUtxo = {
    /**
     * The unique identifier of the unshielded UTXO.
     */
    readonly owner: ContractAddress;
    /**
     * The identifier of the intent associated with the unshielded UTXO.
     * This is used to track the intent behind the creation or use of the UTXO.
     */
    readonly intentHash: IntentHash;
    /**
     * The type of token associated with the unshielded UTXO.
     * This indicates the kind of asset or currency represented by the UTXO.
     */
    readonly tokenType: RawTokenType;
    /**
     * The value of the unshielded UTXO, represented as a bigint.
     */
    readonly value: bigint;
};
/**
 * Represents a collection of unshielded UTXOs, which are unspent transaction outputs that are not shielded.
 * This type is used to manage and track the state of unshielded UTXOs.
 */
export type UnshieldedUtxos = {
    /**
     * Represents the unshielded UTXOs that have been created but not yet spent.
     */
    readonly created: readonly UnshieldedUtxo[];
    /**
     * Represents the unshielded UTXOs that have been spent.
     */
    readonly spent: readonly UnshieldedUtxo[];
};
/**
 * Represents the fees associated with a particular entity or operation.
 *
 * This type includes both the paid fees and the estimated fees. The paid fees represent
 * the amount that has already been settled, while the estimated fees provide a calculation
 * or projection of expected fees.
 */
export type Fees = {
    /**
     * The fees that have already been paid.
     */
    readonly paidFees: string;
    /**
     * The estimated fees that are expected to be incurred.
     */
    readonly estimatedFees: string;
};
/**
 * Block identifier
 */
export type BlockHash = string;
/**
 * Data for any finalized transaction.
 */
export interface FinalizedTxData {
    /**
     * The transaction that was finalized.
     */
    readonly tx: Transaction<SignatureEnabled, Proof, Binding>;
    /**
     * The status of a submitted transaction.
     */
    readonly status: TxStatus;
    /**
     * One of the transaction ID of the submitted transaction.
     */
    readonly txId: TransactionId;
    /**
     * All transaction IDs of the submitted transaction.
     */
    readonly identifiers: readonly TransactionId[];
    /**
     * The transaction hash of the transaction in which the original transaction was included.
     */
    readonly txHash: TransactionHash;
    /**
     * The block hash of the block in which the transaction was included.
     */
    readonly blockHash: BlockHash;
    /**
     * The block height of the block in which the transaction was included.
     */
    readonly blockHeight: number;
    /**
     * The timestamp of the block in which the transaction was included.
     */
    readonly blockTimestamp: number;
    /**
     * The author of the block in which the transaction was included.
     */
    readonly blockAuthor: string | null;
    /**
     * The indexer internal db ID.
     */
    readonly indexerId: number;
    /**
     * The protocol version of the transaction.
     */
    readonly protocolVersion: number;
    /**
     * The fees associated with the transaction, including both paid and estimated fees.
     */
    readonly fees: Fees;
    /**
     * The map that associates segment identifiers (numbers) with their corresponding status {@link SegmentStatus}.
     * The segment identifier is represented as a number (key in the map), and the status indicates the success or failure of the transaction update.
     */
    readonly segmentStatusMap: Map<number, SegmentStatus> | undefined;
    /**
     * Represents the unshielded outputs, typically used for transactions or operations
     * involving data or values that are not encrypted or concealed.
     */
    readonly unshielded: UnshieldedUtxos;
}
/**
 * Represents an unshielded balance, which is a balance that is not shielded or encrypted.
 * This type is used to track the available funds in an account that are visible on the public ledger.
 */
export type UnshieldedBalance = {
    /**
     * Represents the current number of funds available or held in an account.
     */
    readonly balance: bigint;
    /**
     * Represents the type of token in the system.
     */
    readonly tokenType: RawTokenType;
};
/**
 * Represents a collection of unshielded balances, which are balances that are not shielded or encrypted.
 */
export type UnshieldedBalances = UnshieldedBalance[];
//# sourceMappingURL=midnight-types.d.ts.map