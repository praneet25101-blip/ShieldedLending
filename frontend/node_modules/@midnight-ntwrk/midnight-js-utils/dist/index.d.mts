import { NetworkId } from '@midnight-ntwrk/midnight-js-network-id';
import { Buffer } from 'buffer';
import { ContractAddress } from '@midnight-ntwrk/compact-runtime';

/**
 * Asserts that the given value is non-nullable.
 *
 * @param value The value to test for nullability.
 * @param message The error message to use if an error is thrown.
 *
 * @throws Error If the value is nullable.
 */
declare function assertDefined<A>(value: A | null | undefined, message?: string): asserts value is NonNullable<A>;
/**
 * Asserts that the given value is null or undefined.
 *
 * @param value The value to test for nullability.
 * @param message The error message to use if an error is thrown.
 *
 * @throws Error If the value is not undefined or null
 */
declare function assertUndefined<A>(value: A | null | undefined, message?: string): asserts value is undefined | null;

declare const ttlOneHour: () => Date;

/**
 * The result of parsing a string as a hex-encoded string.
 */
type ParsedHexString = {
    /** A flag indicating if the hex-string has a `'0x'` prefix. */
    readonly hasPrefix: boolean;
    /** The captured sequence of _whole_ bytes found in the source string. */
    readonly byteChars: string;
    /** The remaining characters of incomplete bytes and/or the non hexadecimal characters found
     * in the source string. */
    readonly incompleteChars: string;
};
/**
 * Parses a string as a hex-encoded string.
 *
 * @param source The source string to parse.
 * @returns A {@link ParsedHexString} describing the parsed elements of `source`.
 *
 * @example
 * parseHex('Hello') =>
 *   {
 *     hasPrefix: false,
 *     incompleteChars: 'Hello'
 *   }
 *
 * @example
 * parseHex('ab12e') =>
 *   {
 *     hasPrefix: false,
 *     byteChars: 'ab12'
 *     incompleteChars: 'e'
 *   }
 *
 * @example
 * parseHex('0xab12') =>
 *   {
 *     hasPrefix: true,
 *     byteChars: 'ab12'
 *     incompleteChars: ''
 *   }
 */
declare const parseHex: (source: string) => ParsedHexString;
/**
 * Converts a byte string into a hex string.
 *
 * @param bytes The byte string to encode.
 */
declare const toHex: (bytes: Uint8Array) => string;
/**
 * Converts a hex string into a byte string.
 *
 * @param str The hex string to decode.
 */
declare const fromHex: (str: string) => Buffer;
/**
 * Determines if a string represents a hex-encoded sequence of bytes.
 *
 * @param source The source string.
 * @param byteLen An optional number of bytes that `source` should represent. If not specified
 * then any number of bytes can be represented by `source`.
 * @returns `true` if the `source` string is parsable as a hex-string, of non-zero length, and
 * of the optional byte length of `byteLen`; otherwise `false`.
 */
declare const isHex: (source: string, byteLen?: number) => boolean;
/**
 * Asserts that a string represents a hex-encoded sequence of bytes.
 *
 * @param source The source string.
 * @param byteLen An optional number of bytes that `source` should represent. If not specified
 * then any number of bytes can be represented by `source`.
 *
 * @throws `Error`
 * `byteLen` is \<= zero. Valid hex-strings will be required to have at least one byte.
 * @throws `TypeError`
 * `source` is not a hex-encoded string because it:
 * - is empty,
 * - contains invalid or incomplete characters, or
 * - does not represent `byteLen` bytes.
 */
declare function assertIsHex(source: string, byteLen?: number): asserts source is NonNullable<string>;
/**
 * Parses a coin public key (in Bech32m format or hex) into a hex formatted string.
 *
 * @param possibleBech32 The input string, which can be a Bech32m-encoded coin public key or a hex string.
 * @param zswapNetworkId The network ID used for decoding the Bech32m formatted string.
 * @returns The hex string representation of the coin public key.
 *
 * @throws `Error`
 * If the input string is not a valid hex string or a valid Bech32m-encoded coin public key.
 */
declare const parseCoinPublicKeyToHex: (possibleBech32: string, zswapNetworkId: NetworkId) => string;
/**
 * Parses an encryption public key (in Bech32m or hex format) into a hex formatted string.
 *
 * @param possibleBech32 The input string, which can be a Bech32m-encoded encryption public key or a hex string.
 * @param zswapNetworkId The network ID used for decoding the Bech32m formatted string.
 * @returns The hex string representation of the encryption public key.
 *
 * @throws `Error`
 * If the input string is not a valid hex string or a valid Bech32m-encoded encryption public key.
 */
declare const parseEncPublicKeyToHex: (possibleBech32: string, zswapNetworkId: NetworkId) => string;

/**
 * Asserts that a string represents a hex-encoded contract address.
 *
 * @param contractAddress The source string.
 *
 * @throws `TypeError`
 * `contractAddress` is not a correctly formatted {@link ContractAddress}.
 *
 * @internal
 */
declare function assertIsContractAddress(contractAddress: string): asserts contractAddress is ContractAddress;

export { assertDefined, assertIsContractAddress, assertIsHex, assertUndefined, fromHex, isHex, parseCoinPublicKeyToHex, parseEncPublicKeyToHex, parseHex, toHex, ttlOneHour };
export type { ParsedHexString };
