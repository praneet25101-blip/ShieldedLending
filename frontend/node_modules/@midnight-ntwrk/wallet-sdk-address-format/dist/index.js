// This file is part of MIDNIGHT-WALLET-SDK.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { EncryptionSecretKey } from '@midnight-ntwrk/ledger-v7';
import { bech32m } from '@scure/base';
import * as subsquidScale from '@subsquid/scale-codec';
export const mainnet = Symbol('Mainnet');
const NetworkId = {
    toString: (networkId) => {
        return networkId === mainnet ? 'mainnet' : networkId;
    },
};
export const BLSScalar = {
    bytes: 32,
    modulus: BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'),
};
export const ScaleBigInt = {
    encode: (data) => {
        const sink = new subsquidScale.ByteSink();
        sink.compact(data);
        return Buffer.from(sink.toBytes());
    },
    decode: (repr) => {
        const src = new subsquidScale.Src(repr);
        const res = src.compact();
        src.assertEOF();
        return BigInt(res);
    },
};
export const Bech32mSymbol = Symbol('MidnightBech32m');
export class MidnightBech32m {
    static prefix = 'mn';
    static encode(networkId, item) {
        return item[Bech32mSymbol].encode(networkId, item);
    }
    static validateSegment(segmentName, segment) {
        const result = /^[A-Za-z1-9-]+$/.test(segment);
        if (!result) {
            throw new Error(`Segment ${segmentName}: ${segment} contains disallowed characters. Allowed characters are only numbers, latin letters and a hyphen`);
        }
    }
    static parse(bech32string) {
        const bech32parsed = bech32m.decodeToBytes(bech32string);
        const [prefix, type, network = mainnet] = bech32parsed.prefix.split('_');
        if (prefix != MidnightBech32m.prefix) {
            throw new Error(`Expected prefix ${MidnightBech32m.prefix}`);
        }
        MidnightBech32m.validateSegment('type', type);
        if (network != mainnet) {
            MidnightBech32m.validateSegment('network', network);
        }
        return new MidnightBech32m(type, network, Buffer.from(bech32parsed.bytes));
    }
    type;
    network;
    data;
    constructor(type, network, data) {
        this.data = data;
        this.network = network;
        this.type = type;
        MidnightBech32m.validateSegment('type', type);
        if (network != mainnet) {
            MidnightBech32m.validateSegment('network', network);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    decode(tclass, networkId) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return tclass[Bech32mSymbol].decode(networkId, this);
    }
    asString() {
        const networkSegment = this.network == mainnet ? '' : `_${this.network}`;
        return bech32m.encode(`${MidnightBech32m.prefix}_${this.type}${networkSegment}`, bech32m.toWords(this.data), false);
    }
    toString() {
        return this.asString();
    }
}
export class Bech32mCodec {
    type;
    dataToBytes;
    dataFromBytes;
    constructor(type, dataToBytes, dataFromBytes) {
        this.dataFromBytes = dataFromBytes;
        this.dataToBytes = dataToBytes;
        this.type = type;
    }
    encode(networkId, data) {
        const context = Bech32mCodec.createContext(networkId);
        return new MidnightBech32m(this.type, context.networkId, this.dataToBytes(data));
    }
    decode(networkId, repr) {
        const context = Bech32mCodec.createContext(networkId);
        if (repr.type != this.type) {
            throw new Error(`Expected type ${this.type}, got ${repr.type}`);
        }
        if (context.networkId != repr.network) {
            throw new Error(`Expected ${NetworkId.toString(context.networkId)} address, got ${NetworkId.toString(repr.network)} one`);
        }
        return this.dataFromBytes(repr.data);
    }
    static createContext(networkId) {
        if (networkId === 'mainnet') {
            return { networkId: mainnet };
        }
        else {
            return { networkId };
        }
    }
}
export class ShieldedAddress {
    static codec = new Bech32mCodec('shield-addr', (addr) => Buffer.concat([addr.coinPublicKey.data, addr.encryptionPublicKey.data]), (bytes) => {
        const coinPublicKey = new ShieldedCoinPublicKey(bytes.subarray(0, ShieldedCoinPublicKey.keyLength));
        const encryptionPublicKey = new ShieldedEncryptionPublicKey(bytes.subarray(ShieldedCoinPublicKey.keyLength));
        return new ShieldedAddress(coinPublicKey, encryptionPublicKey);
    });
    static [Bech32mSymbol] = ShieldedAddress.codec;
    [Bech32mSymbol] = ShieldedAddress.codec;
    coinPublicKey;
    encryptionPublicKey;
    constructor(coinPublicKey, encryptionPublicKey) {
        this.encryptionPublicKey = encryptionPublicKey;
        this.coinPublicKey = coinPublicKey;
    }
    coinPublicKeyString() {
        return this.coinPublicKey.data.toString('hex');
    }
    encryptionPublicKeyString() {
        return this.encryptionPublicKey.data.toString('hex');
    }
    equals(other) {
        return this.coinPublicKey.equals(other.coinPublicKey) && this.encryptionPublicKey.equals(other.encryptionPublicKey);
    }
}
export class ShieldedEncryptionSecretKey {
    static codec = new Bech32mCodec('shield-esk', (esk) => Buffer.from(esk.zswap.yesIKnowTheSecurityImplicationsOfThis_serialize()), (repr) => new ShieldedEncryptionSecretKey(EncryptionSecretKey.deserialize(repr)));
    // There are some bits in serialization of field elements and elliptic curve points, that are hard to replicate
    // Thus using zswap implementation directly for serialization purposes
    zswap;
    constructor(zswap) {
        this.zswap = zswap;
    }
}
export class ShieldedCoinPublicKey {
    static keyLength = 32;
    static codec = new Bech32mCodec('shield-cpk', (cpk) => cpk.data, (repr) => new ShieldedCoinPublicKey(repr));
    static fromHexString(hexString) {
        return new ShieldedCoinPublicKey(Buffer.from(hexString, 'hex'));
    }
    data;
    constructor(data) {
        this.data = data;
        if (data.length != ShieldedCoinPublicKey.keyLength) {
            throw new Error('Coin public key needs to be 32 bytes long');
        }
    }
    toHexString() {
        return this.data.toString('hex');
    }
    equals(other) {
        const otherKey = typeof other === 'string' ? ShieldedCoinPublicKey.fromHexString(other) : other;
        return otherKey.data.equals(this.data);
    }
}
export class ShieldedEncryptionPublicKey {
    static keyLength = 32;
    static codec = new Bech32mCodec('shield-epk', (cpk) => cpk.data, (repr) => new ShieldedEncryptionPublicKey(repr));
    static fromHexString(hexString) {
        return new ShieldedEncryptionPublicKey(Buffer.from(hexString, 'hex'));
    }
    data;
    constructor(data) {
        this.data = data;
    }
    toHexString() {
        return this.data.toString('hex');
    }
    equals(other) {
        const otherKey = typeof other === 'string' ? ShieldedEncryptionPublicKey.fromHexString(other) : other;
        return otherKey.data.equals(this.data);
    }
}
export class UnshieldedAddress {
    data;
    static keyLength = 32;
    static codec = new Bech32mCodec('addr', (addr) => addr.data, (repr) => new UnshieldedAddress(repr));
    static [Bech32mSymbol] = UnshieldedAddress.codec;
    [Bech32mSymbol] = UnshieldedAddress.codec;
    constructor(data) {
        if (data.length != UnshieldedAddress.keyLength) {
            throw new Error('Unshielded address needs to be 32 bytes long');
        }
        this.data = data;
    }
    get hexString() {
        return this.data.toString('hex');
    }
    equals(other) {
        const otherAddress = typeof other === 'string' ? new UnshieldedAddress(Buffer.from(other, 'hex')) : other;
        return otherAddress.data.equals(this.data);
    }
}
export class DustAddress {
    data;
    static codec = new Bech32mCodec('dust', (daddr) => daddr.serialize(), (repr) => new DustAddress(ScaleBigInt.decode(repr)));
    static [Bech32mSymbol] = DustAddress.codec;
    [Bech32mSymbol] = DustAddress.codec;
    static encodePublicKey = (networkId, publicKey) => {
        return DustAddress.codec.encode(networkId, new DustAddress(publicKey)).asString();
    };
    constructor(data) {
        if (data >= BLSScalar.modulus) {
            throw new Error('Dust address is too large');
        }
        this.data = data;
    }
    serialize() {
        return ScaleBigInt.encode(this.data);
    }
    equals(other) {
        const otherAddress = typeof other === 'bigint' ? other : other.data;
        return otherAddress === this.data;
    }
}
